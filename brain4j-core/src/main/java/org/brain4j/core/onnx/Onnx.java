// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto
// Protobuf Java Version: 4.31.1

package org.brain4j.core.onnx;

@com.google.protobuf.Generated
public final class Onnx {
  private Onnx() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 31,
      /* patch= */ 1,
      /* suffix= */ "",
      Onnx.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Versioning
   *
   * ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
   *
   * To be compatible with both proto2 and proto3, we will use a version number
   * that is not defined by the default value but an explicit enum number.
   * </pre>
   *
   * Protobuf enum {@code Version}
   */
  public enum Version
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * proto3 requires the first enum value to be zero.
     * We add this just to appease the compiler.
     * </pre>
     *
     * <code>_START_VERSION = 0;</code>
     */
    _START_VERSION(0),
    /**
     * <pre>
     * The version field is always serialized and we will use it to store the
     * version that the  graph is generated from. This helps us set up version
     * control.
     * For the IR, we are using simple numbers starting with 0x00000001,
     * which was the version we published on Oct 10, 2017.
     * </pre>
     *
     * <code>IR_VERSION_2017_10_10 = 1;</code>
     */
    IR_VERSION_2017_10_10(1),
    /**
     * <pre>
     * IR_VERSION 2 published on Oct 30, 2017
     * - Added type discriminator to AttributeProto to support proto3 users
     * </pre>
     *
     * <code>IR_VERSION_2017_10_30 = 2;</code>
     */
    IR_VERSION_2017_10_30(2),
    /**
     * <pre>
     * IR VERSION 3 published on Nov 3, 2017
     * - For operator versioning:
     * - Added new message OperatorSetIdProto
     * - Added opset_import in ModelProto
     * - For vendor extensions, added domain in NodeProto
     * </pre>
     *
     * <code>IR_VERSION_2017_11_3 = 3;</code>
     */
    IR_VERSION_2017_11_3(3),
    /**
     * <pre>
     * IR VERSION 4 published on Jan 22, 2019
     * - Relax constraint that initializers should be a subset of graph inputs
     * - Add type BFLOAT16
     * </pre>
     *
     * <code>IR_VERSION_2019_1_22 = 4;</code>
     */
    IR_VERSION_2019_1_22(4),
    /**
     * <pre>
     * IR VERSION 5 published on March 18, 2019
     * - Add message TensorAnnotation.
     * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
     * </pre>
     *
     * <code>IR_VERSION_2019_3_18 = 5;</code>
     */
    IR_VERSION_2019_3_18(5),
    /**
     * <pre>
     * IR VERSION 6 published on Sep 19, 2019
     * - Add support for sparse tensor constants stored in model.
     * - Add message SparseTensorProto
     * - Add sparse initializers
     * </pre>
     *
     * <code>IR_VERSION_2019_9_19 = 6;</code>
     */
    IR_VERSION_2019_9_19(6),
    /**
     * <pre>
     * IR VERSION 7 published on May 8, 2020
     * - Add support to allow function body graph to rely on multiple external operator sets.
     * - Add a list to promote inference graph's initializers to global and
     * mutable variables. Global variables are visible in all graphs of the
     * stored models.
     * - Add message TrainingInfoProto to store initialization
     * method and training algorithm. The execution of TrainingInfoProto
     * can modify the values of mutable variables.
     * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
     * </pre>
     *
     * <code>IR_VERSION_2020_5_8 = 7;</code>
     */
    IR_VERSION_2020_5_8(7),
    /**
     * <pre>
     * IR VERSION 8 published on July 30, 2021
     * Introduce TypeProto.SparseTensor
     * Introduce TypeProto.Optional
     * Added a list of FunctionProtos local to the model
     * Deprecated since_version and operator status from FunctionProto
     * </pre>
     *
     * <code>IR_VERSION_2021_7_30 = 8;</code>
     */
    IR_VERSION_2021_7_30(8),
    /**
     * <pre>
     * IR VERSION 9 published on May 5, 2023
     * Added AttributeProto to FunctionProto so that default attribute values can be set.
     * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.
     * </pre>
     *
     * <code>IR_VERSION_2023_5_5 = 9;</code>
     */
    IR_VERSION_2023_5_5(9),
    /**
     * <pre>
     * IR VERSION 10 published on March 25, 2024
     * Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.
     * </pre>
     *
     * <code>IR_VERSION_2024_3_25 = 10;</code>
     */
    IR_VERSION_2024_3_25(10),
    /**
     * <pre>
     * IR VERSION 11 published on May 12, 2025
     * Added FLOAT4E2M1, multi-device protobuf classes.
     * </pre>
     *
     * <code>IR_VERSION = 11;</code>
     */
    IR_VERSION(11),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        Version.class.getName());
    }
    /**
     * <pre>
     * proto3 requires the first enum value to be zero.
     * We add this just to appease the compiler.
     * </pre>
     *
     * <code>_START_VERSION = 0;</code>
     */
    public static final int _START_VERSION_VALUE = 0;
    /**
     * <pre>
     * The version field is always serialized and we will use it to store the
     * version that the  graph is generated from. This helps us set up version
     * control.
     * For the IR, we are using simple numbers starting with 0x00000001,
     * which was the version we published on Oct 10, 2017.
     * </pre>
     *
     * <code>IR_VERSION_2017_10_10 = 1;</code>
     */
    public static final int IR_VERSION_2017_10_10_VALUE = 1;
    /**
     * <pre>
     * IR_VERSION 2 published on Oct 30, 2017
     * - Added type discriminator to AttributeProto to support proto3 users
     * </pre>
     *
     * <code>IR_VERSION_2017_10_30 = 2;</code>
     */
    public static final int IR_VERSION_2017_10_30_VALUE = 2;
    /**
     * <pre>
     * IR VERSION 3 published on Nov 3, 2017
     * - For operator versioning:
     * - Added new message OperatorSetIdProto
     * - Added opset_import in ModelProto
     * - For vendor extensions, added domain in NodeProto
     * </pre>
     *
     * <code>IR_VERSION_2017_11_3 = 3;</code>
     */
    public static final int IR_VERSION_2017_11_3_VALUE = 3;
    /**
     * <pre>
     * IR VERSION 4 published on Jan 22, 2019
     * - Relax constraint that initializers should be a subset of graph inputs
     * - Add type BFLOAT16
     * </pre>
     *
     * <code>IR_VERSION_2019_1_22 = 4;</code>
     */
    public static final int IR_VERSION_2019_1_22_VALUE = 4;
    /**
     * <pre>
     * IR VERSION 5 published on March 18, 2019
     * - Add message TensorAnnotation.
     * - Add quantization annotation in GraphProto to map tensor with its scale and zero point quantization parameters.
     * </pre>
     *
     * <code>IR_VERSION_2019_3_18 = 5;</code>
     */
    public static final int IR_VERSION_2019_3_18_VALUE = 5;
    /**
     * <pre>
     * IR VERSION 6 published on Sep 19, 2019
     * - Add support for sparse tensor constants stored in model.
     * - Add message SparseTensorProto
     * - Add sparse initializers
     * </pre>
     *
     * <code>IR_VERSION_2019_9_19 = 6;</code>
     */
    public static final int IR_VERSION_2019_9_19_VALUE = 6;
    /**
     * <pre>
     * IR VERSION 7 published on May 8, 2020
     * - Add support to allow function body graph to rely on multiple external operator sets.
     * - Add a list to promote inference graph's initializers to global and
     * mutable variables. Global variables are visible in all graphs of the
     * stored models.
     * - Add message TrainingInfoProto to store initialization
     * method and training algorithm. The execution of TrainingInfoProto
     * can modify the values of mutable variables.
     * - Implicitly add inference graph into each TrainingInfoProto's algorithm.
     * </pre>
     *
     * <code>IR_VERSION_2020_5_8 = 7;</code>
     */
    public static final int IR_VERSION_2020_5_8_VALUE = 7;
    /**
     * <pre>
     * IR VERSION 8 published on July 30, 2021
     * Introduce TypeProto.SparseTensor
     * Introduce TypeProto.Optional
     * Added a list of FunctionProtos local to the model
     * Deprecated since_version and operator status from FunctionProto
     * </pre>
     *
     * <code>IR_VERSION_2021_7_30 = 8;</code>
     */
    public static final int IR_VERSION_2021_7_30_VALUE = 8;
    /**
     * <pre>
     * IR VERSION 9 published on May 5, 2023
     * Added AttributeProto to FunctionProto so that default attribute values can be set.
     * Added FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ.
     * </pre>
     *
     * <code>IR_VERSION_2023_5_5 = 9;</code>
     */
    public static final int IR_VERSION_2023_5_5_VALUE = 9;
    /**
     * <pre>
     * IR VERSION 10 published on March 25, 2024
     * Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.
     * </pre>
     *
     * <code>IR_VERSION_2024_3_25 = 10;</code>
     */
    public static final int IR_VERSION_2024_3_25_VALUE = 10;
    /**
     * <pre>
     * IR VERSION 11 published on May 12, 2025
     * Added FLOAT4E2M1, multi-device protobuf classes.
     * </pre>
     *
     * <code>IR_VERSION = 11;</code>
     */
    public static final int IR_VERSION_VALUE = 11;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Version valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Version forNumber(int value) {
      switch (value) {
        case 0: return _START_VERSION;
        case 1: return IR_VERSION_2017_10_10;
        case 2: return IR_VERSION_2017_10_30;
        case 3: return IR_VERSION_2017_11_3;
        case 4: return IR_VERSION_2019_1_22;
        case 5: return IR_VERSION_2019_3_18;
        case 6: return IR_VERSION_2019_9_19;
        case 7: return IR_VERSION_2020_5_8;
        case 8: return IR_VERSION_2021_7_30;
        case 9: return IR_VERSION_2023_5_5;
        case 10: return IR_VERSION_2024_3_25;
        case 11: return IR_VERSION;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Version>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Version> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Version>() {
            public Version findValueByNumber(int number) {
              return Version.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Onnx.getDescriptor().getEnumTypes().get(0);
    }

    private static final Version[] VALUES = values();

    public static Version valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Version(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:Version)
  }

  /**
   * <pre>
   * Operator/function status.
   * </pre>
   *
   * Protobuf enum {@code OperatorStatus}
   */
  public enum OperatorStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EXPERIMENTAL = 0;</code>
     */
    EXPERIMENTAL(0),
    /**
     * <code>STABLE = 1;</code>
     */
    STABLE(1),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        OperatorStatus.class.getName());
    }
    /**
     * <code>EXPERIMENTAL = 0;</code>
     */
    public static final int EXPERIMENTAL_VALUE = 0;
    /**
     * <code>STABLE = 1;</code>
     */
    public static final int STABLE_VALUE = 1;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static OperatorStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static OperatorStatus forNumber(int value) {
      switch (value) {
        case 0: return EXPERIMENTAL;
        case 1: return STABLE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        OperatorStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<OperatorStatus>() {
            public OperatorStatus findValueByNumber(int number) {
              return OperatorStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Onnx.getDescriptor().getEnumTypes().get(1);
    }

    private static final OperatorStatus[] VALUES = values();

    public static OperatorStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private OperatorStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:OperatorStatus)
  }

  public interface AttributeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:AttributeProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return Whether the refAttrName field is set.
     */
    boolean hasRefAttrName();
    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return The refAttrName.
     */
    java.lang.String getRefAttrName();
    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return The bytes for refAttrName.
     */
    com.google.protobuf.ByteString
        getRefAttrNameBytes();

    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * The type field MUST be present for this version of the IR.
     * For 0.0.1 versions of the IR, this field was not defined, and
     * implementations needed to use has_field heuristics to determine
     * which value field was in use.  For IR_VERSION 0.0.2 or later, this
     * field MUST be set and match the f|i|s|t|... field in use.  This
     * change was made to accommodate proto3 implementations.
     * </pre>
     *
     * <code>optional .AttributeProto.AttributeType type = 20;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * The type field MUST be present for this version of the IR.
     * For 0.0.1 versions of the IR, this field was not defined, and
     * implementations needed to use has_field heuristics to determine
     * which value field was in use.  For IR_VERSION 0.0.2 or later, this
     * field MUST be set and match the f|i|s|t|... field in use.  This
     * change was made to accommodate proto3 implementations.
     * </pre>
     *
     * <code>optional .AttributeProto.AttributeType type = 20;</code>
     * @return The type.
     */
    Onnx.AttributeProto.AttributeType getType();

    /**
     * <pre>
     * Exactly ONE of the following fields must be present for this version of the IR
     * </pre>
     *
     * <code>optional float f = 2;</code>
     * @return Whether the f field is set.
     */
    boolean hasF();
    /**
     * <pre>
     * Exactly ONE of the following fields must be present for this version of the IR
     * </pre>
     *
     * <code>optional float f = 2;</code>
     * @return The f.
     */
    float getF();

    /**
     * <pre>
     * int
     * </pre>
     *
     * <code>optional int64 i = 3;</code>
     * @return Whether the i field is set.
     */
    boolean hasI();
    /**
     * <pre>
     * int
     * </pre>
     *
     * <code>optional int64 i = 3;</code>
     * @return The i.
     */
    long getI();

    /**
     * <pre>
     * UTF-8 string
     * </pre>
     *
     * <code>optional bytes s = 4;</code>
     * @return Whether the s field is set.
     */
    boolean hasS();
    /**
     * <pre>
     * UTF-8 string
     * </pre>
     *
     * <code>optional bytes s = 4;</code>
     * @return The s.
     */
    com.google.protobuf.ByteString getS();

    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     * @return Whether the t field is set.
     */
    boolean hasT();
    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     * @return The t.
     */
    Onnx.TensorProto getT();
    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     */
    Onnx.TensorProtoOrBuilder getTOrBuilder();

    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     * @return Whether the g field is set.
     */
    boolean hasG();
    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     * @return The g.
     */
    Onnx.GraphProto getG();
    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     */
    Onnx.GraphProtoOrBuilder getGOrBuilder();

    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     * @return Whether the sparseTensor field is set.
     */
    boolean hasSparseTensor();
    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     * @return The sparseTensor.
     */
    Onnx.SparseTensorProto getSparseTensor();
    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     */
    Onnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder();

    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     * @return Whether the tp field is set.
     */
    boolean hasTp();
    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     * @return The tp.
     */
    Onnx.TypeProto getTp();
    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     */
    Onnx.TypeProtoOrBuilder getTpOrBuilder();

    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @return A list containing the floats.
     */
    java.util.List<java.lang.Float> getFloatsList();
    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @return The count of floats.
     */
    int getFloatsCount();
    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @param index The index of the element to return.
     * @return The floats at the given index.
     */
    float getFloats(int index);

    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @return A list containing the ints.
     */
    java.util.List<java.lang.Long> getIntsList();
    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @return The count of ints.
     */
    int getIntsCount();
    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @param index The index of the element to return.
     * @return The ints at the given index.
     */
    long getInts(int index);

    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @return A list containing the strings.
     */
    java.util.List<com.google.protobuf.ByteString> getStringsList();
    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @return The count of strings.
     */
    int getStringsCount();
    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @param index The index of the element to return.
     * @return The strings at the given index.
     */
    com.google.protobuf.ByteString getStrings(int index);

    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    java.util.List<Onnx.TensorProto> 
        getTensorsList();
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    Onnx.TensorProto getTensors(int index);
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    int getTensorsCount();
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    java.util.List<? extends Onnx.TensorProtoOrBuilder> 
        getTensorsOrBuilderList();
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    Onnx.TensorProtoOrBuilder getTensorsOrBuilder(
        int index);

    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    java.util.List<Onnx.GraphProto> 
        getGraphsList();
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    Onnx.GraphProto getGraphs(int index);
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    int getGraphsCount();
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    java.util.List<? extends Onnx.GraphProtoOrBuilder> 
        getGraphsOrBuilderList();
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    Onnx.GraphProtoOrBuilder getGraphsOrBuilder(
        int index);

    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    java.util.List<Onnx.SparseTensorProto> 
        getSparseTensorsList();
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    Onnx.SparseTensorProto getSparseTensors(int index);
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    int getSparseTensorsCount();
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
        getSparseTensorsOrBuilderList();
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    Onnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
        int index);

    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    java.util.List<Onnx.TypeProto> 
        getTypeProtosList();
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    Onnx.TypeProto getTypeProtos(int index);
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    int getTypeProtosCount();
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    java.util.List<? extends Onnx.TypeProtoOrBuilder> 
        getTypeProtosOrBuilderList();
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    Onnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Attributes
   *
   * A named attribute containing either singular float, integer, string, graph,
   * and tensor values, or repeated float, integer, string, graph, and tensor values.
   * An AttributeProto MUST contain the name field, and *only one* of the
   * following content fields, effectively enforcing a C/C++ union equivalent.
   * </pre>
   *
   * Protobuf type {@code AttributeProto}
   */
  public static final class AttributeProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:AttributeProto)
      AttributeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        AttributeProto.class.getName());
    }
    // Use AttributeProto.newBuilder() to construct.
    private AttributeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private AttributeProto() {
      name_ = "";
      refAttrName_ = "";
      docString_ = "";
      type_ = 0;
      s_ = com.google.protobuf.ByteString.EMPTY;
      floats_ = emptyFloatList();
      ints_ = emptyLongList();
      strings_ = emptyList(com.google.protobuf.ByteString.class);
      tensors_ = java.util.Collections.emptyList();
      graphs_ = java.util.Collections.emptyList();
      sparseTensors_ = java.util.Collections.emptyList();
      typeProtos_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_AttributeProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_AttributeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.AttributeProto.class, Onnx.AttributeProto.Builder.class);
    }

    /**
     * <pre>
     * Note: this enum is structurally identical to the OpSchema::AttrType
     * enum defined in schema.h.  If you rev one, you likely need to rev the other.
     * </pre>
     *
     * Protobuf enum {@code AttributeProto.AttributeType}
     */
    public enum AttributeType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNDEFINED = 0;</code>
       */
      UNDEFINED(0),
      /**
       * <code>FLOAT = 1;</code>
       */
      FLOAT(1),
      /**
       * <code>INT = 2;</code>
       */
      INT(2),
      /**
       * <code>STRING = 3;</code>
       */
      STRING(3),
      /**
       * <code>TENSOR = 4;</code>
       */
      TENSOR(4),
      /**
       * <code>GRAPH = 5;</code>
       */
      GRAPH(5),
      /**
       * <code>SPARSE_TENSOR = 11;</code>
       */
      SPARSE_TENSOR(11),
      /**
       * <code>TYPE_PROTO = 13;</code>
       */
      TYPE_PROTO(13),
      /**
       * <code>FLOATS = 6;</code>
       */
      FLOATS(6),
      /**
       * <code>INTS = 7;</code>
       */
      INTS(7),
      /**
       * <code>STRINGS = 8;</code>
       */
      STRINGS(8),
      /**
       * <code>TENSORS = 9;</code>
       */
      TENSORS(9),
      /**
       * <code>GRAPHS = 10;</code>
       */
      GRAPHS(10),
      /**
       * <code>SPARSE_TENSORS = 12;</code>
       */
      SPARSE_TENSORS(12),
      /**
       * <code>TYPE_PROTOS = 14;</code>
       */
      TYPE_PROTOS(14),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          AttributeType.class.getName());
      }
      /**
       * <code>UNDEFINED = 0;</code>
       */
      public static final int UNDEFINED_VALUE = 0;
      /**
       * <code>FLOAT = 1;</code>
       */
      public static final int FLOAT_VALUE = 1;
      /**
       * <code>INT = 2;</code>
       */
      public static final int INT_VALUE = 2;
      /**
       * <code>STRING = 3;</code>
       */
      public static final int STRING_VALUE = 3;
      /**
       * <code>TENSOR = 4;</code>
       */
      public static final int TENSOR_VALUE = 4;
      /**
       * <code>GRAPH = 5;</code>
       */
      public static final int GRAPH_VALUE = 5;
      /**
       * <code>SPARSE_TENSOR = 11;</code>
       */
      public static final int SPARSE_TENSOR_VALUE = 11;
      /**
       * <code>TYPE_PROTO = 13;</code>
       */
      public static final int TYPE_PROTO_VALUE = 13;
      /**
       * <code>FLOATS = 6;</code>
       */
      public static final int FLOATS_VALUE = 6;
      /**
       * <code>INTS = 7;</code>
       */
      public static final int INTS_VALUE = 7;
      /**
       * <code>STRINGS = 8;</code>
       */
      public static final int STRINGS_VALUE = 8;
      /**
       * <code>TENSORS = 9;</code>
       */
      public static final int TENSORS_VALUE = 9;
      /**
       * <code>GRAPHS = 10;</code>
       */
      public static final int GRAPHS_VALUE = 10;
      /**
       * <code>SPARSE_TENSORS = 12;</code>
       */
      public static final int SPARSE_TENSORS_VALUE = 12;
      /**
       * <code>TYPE_PROTOS = 14;</code>
       */
      public static final int TYPE_PROTOS_VALUE = 14;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AttributeType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static AttributeType forNumber(int value) {
        switch (value) {
          case 0: return UNDEFINED;
          case 1: return FLOAT;
          case 2: return INT;
          case 3: return STRING;
          case 4: return TENSOR;
          case 5: return GRAPH;
          case 11: return SPARSE_TENSOR;
          case 13: return TYPE_PROTO;
          case 6: return FLOATS;
          case 7: return INTS;
          case 8: return STRINGS;
          case 9: return TENSORS;
          case 10: return GRAPHS;
          case 12: return SPARSE_TENSORS;
          case 14: return TYPE_PROTOS;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<AttributeType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          AttributeType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<AttributeType>() {
              public AttributeType findValueByNumber(int number) {
                return AttributeType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return Onnx.AttributeProto.getDescriptor().getEnumTypes().get(0);
      }

      private static final AttributeType[] VALUES = values();

      public static AttributeType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private AttributeType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:AttributeProto.AttributeType)
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name field MUST be present for this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REF_ATTR_NAME_FIELD_NUMBER = 21;
    @SuppressWarnings("serial")
    private volatile java.lang.Object refAttrName_ = "";
    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return Whether the refAttrName field is set.
     */
    @java.lang.Override
    public boolean hasRefAttrName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return The refAttrName.
     */
    @java.lang.Override
    public java.lang.String getRefAttrName() {
      java.lang.Object ref = refAttrName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          refAttrName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
     * In this case, this AttributeProto does not contain data, and it's a reference of attribute
     * in parent scope.
     * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
     * </pre>
     *
     * <code>optional string ref_attr_name = 21;</code>
     * @return The bytes for refAttrName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getRefAttrNameBytes() {
      java.lang.Object ref = refAttrName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        refAttrName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DOC_STRING_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this attribute. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 13;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 20;
    private int type_ = 0;
    /**
     * <pre>
     * The type field MUST be present for this version of the IR.
     * For 0.0.1 versions of the IR, this field was not defined, and
     * implementations needed to use has_field heuristics to determine
     * which value field was in use.  For IR_VERSION 0.0.2 or later, this
     * field MUST be set and match the f|i|s|t|... field in use.  This
     * change was made to accommodate proto3 implementations.
     * </pre>
     *
     * <code>optional .AttributeProto.AttributeType type = 20;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The type field MUST be present for this version of the IR.
     * For 0.0.1 versions of the IR, this field was not defined, and
     * implementations needed to use has_field heuristics to determine
     * which value field was in use.  For IR_VERSION 0.0.2 or later, this
     * field MUST be set and match the f|i|s|t|... field in use.  This
     * change was made to accommodate proto3 implementations.
     * </pre>
     *
     * <code>optional .AttributeProto.AttributeType type = 20;</code>
     * @return The type.
     */
    @java.lang.Override public Onnx.AttributeProto.AttributeType getType() {
      Onnx.AttributeProto.AttributeType result = Onnx.AttributeProto.AttributeType.forNumber(type_);
      return result == null ? Onnx.AttributeProto.AttributeType.UNDEFINED : result;
    }

    public static final int F_FIELD_NUMBER = 2;
    private float f_ = 0F;
    /**
     * <pre>
     * Exactly ONE of the following fields must be present for this version of the IR
     * </pre>
     *
     * <code>optional float f = 2;</code>
     * @return Whether the f field is set.
     */
    @java.lang.Override
    public boolean hasF() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Exactly ONE of the following fields must be present for this version of the IR
     * </pre>
     *
     * <code>optional float f = 2;</code>
     * @return The f.
     */
    @java.lang.Override
    public float getF() {
      return f_;
    }

    public static final int I_FIELD_NUMBER = 3;
    private long i_ = 0L;
    /**
     * <pre>
     * int
     * </pre>
     *
     * <code>optional int64 i = 3;</code>
     * @return Whether the i field is set.
     */
    @java.lang.Override
    public boolean hasI() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * int
     * </pre>
     *
     * <code>optional int64 i = 3;</code>
     * @return The i.
     */
    @java.lang.Override
    public long getI() {
      return i_;
    }

    public static final int S_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * UTF-8 string
     * </pre>
     *
     * <code>optional bytes s = 4;</code>
     * @return Whether the s field is set.
     */
    @java.lang.Override
    public boolean hasS() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * UTF-8 string
     * </pre>
     *
     * <code>optional bytes s = 4;</code>
     * @return The s.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getS() {
      return s_;
    }

    public static final int T_FIELD_NUMBER = 5;
    private Onnx.TensorProto t_;
    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     * @return Whether the t field is set.
     */
    @java.lang.Override
    public boolean hasT() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     * @return The t.
     */
    @java.lang.Override
    public Onnx.TensorProto getT() {
      return t_ == null ? Onnx.TensorProto.getDefaultInstance() : t_;
    }
    /**
     * <pre>
     * tensor value
     * </pre>
     *
     * <code>optional .TensorProto t = 5;</code>
     */
    @java.lang.Override
    public Onnx.TensorProtoOrBuilder getTOrBuilder() {
      return t_ == null ? Onnx.TensorProto.getDefaultInstance() : t_;
    }

    public static final int G_FIELD_NUMBER = 6;
    private Onnx.GraphProto g_;
    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     * @return Whether the g field is set.
     */
    @java.lang.Override
    public boolean hasG() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     * @return The g.
     */
    @java.lang.Override
    public Onnx.GraphProto getG() {
      return g_ == null ? Onnx.GraphProto.getDefaultInstance() : g_;
    }
    /**
     * <pre>
     * graph
     * </pre>
     *
     * <code>optional .GraphProto g = 6;</code>
     */
    @java.lang.Override
    public Onnx.GraphProtoOrBuilder getGOrBuilder() {
      return g_ == null ? Onnx.GraphProto.getDefaultInstance() : g_;
    }

    public static final int SPARSE_TENSOR_FIELD_NUMBER = 22;
    private Onnx.SparseTensorProto sparseTensor_;
    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     * @return Whether the sparseTensor field is set.
     */
    @java.lang.Override
    public boolean hasSparseTensor() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     * @return The sparseTensor.
     */
    @java.lang.Override
    public Onnx.SparseTensorProto getSparseTensor() {
      return sparseTensor_ == null ? Onnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
    }
    /**
     * <pre>
     * sparse tensor value
     * </pre>
     *
     * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
     */
    @java.lang.Override
    public Onnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
      return sparseTensor_ == null ? Onnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
    }

    public static final int TP_FIELD_NUMBER = 14;
    private Onnx.TypeProto tp_;
    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     * @return Whether the tp field is set.
     */
    @java.lang.Override
    public boolean hasTp() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     * @return The tp.
     */
    @java.lang.Override
    public Onnx.TypeProto getTp() {
      return tp_ == null ? Onnx.TypeProto.getDefaultInstance() : tp_;
    }
    /**
     * <pre>
     * Do not use field below, it's deprecated.
     * optional ValueProto v = 12;         // value - subsumes everything but graph
     * </pre>
     *
     * <code>optional .TypeProto tp = 14;</code>
     */
    @java.lang.Override
    public Onnx.TypeProtoOrBuilder getTpOrBuilder() {
      return tp_ == null ? Onnx.TypeProto.getDefaultInstance() : tp_;
    }

    public static final int FLOATS_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.FloatList floats_ =
        emptyFloatList();
    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @return A list containing the floats.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getFloatsList() {
      return floats_;
    }
    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @return The count of floats.
     */
    public int getFloatsCount() {
      return floats_.size();
    }
    /**
     * <pre>
     * list of floats
     * </pre>
     *
     * <code>repeated float floats = 7;</code>
     * @param index The index of the element to return.
     * @return The floats at the given index.
     */
    public float getFloats(int index) {
      return floats_.getFloat(index);
    }

    public static final int INTS_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList ints_ =
        emptyLongList();
    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @return A list containing the ints.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getIntsList() {
      return ints_;
    }
    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @return The count of ints.
     */
    public int getIntsCount() {
      return ints_.size();
    }
    /**
     * <pre>
     * list of ints
     * </pre>
     *
     * <code>repeated int64 ints = 8;</code>
     * @param index The index of the element to return.
     * @return The ints at the given index.
     */
    public long getInts(int index) {
      return ints_.getLong(index);
    }

    public static final int STRINGS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @return A list containing the strings.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getStringsList() {
      return strings_;
    }
    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @return The count of strings.
     */
    public int getStringsCount() {
      return strings_.size();
    }
    /**
     * <pre>
     * list of UTF-8 strings
     * </pre>
     *
     * <code>repeated bytes strings = 9;</code>
     * @param index The index of the element to return.
     * @return The strings at the given index.
     */
    public com.google.protobuf.ByteString getStrings(int index) {
      return strings_.get(index);
    }

    public static final int TENSORS_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TensorProto> tensors_;
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TensorProto> getTensorsList() {
      return tensors_;
    }
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TensorProtoOrBuilder> 
        getTensorsOrBuilderList() {
      return tensors_;
    }
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    @java.lang.Override
    public int getTensorsCount() {
      return tensors_.size();
    }
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    @java.lang.Override
    public Onnx.TensorProto getTensors(int index) {
      return tensors_.get(index);
    }
    /**
     * <pre>
     * list of tensors
     * </pre>
     *
     * <code>repeated .TensorProto tensors = 10;</code>
     */
    @java.lang.Override
    public Onnx.TensorProtoOrBuilder getTensorsOrBuilder(
        int index) {
      return tensors_.get(index);
    }

    public static final int GRAPHS_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.GraphProto> graphs_;
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.GraphProto> getGraphsList() {
      return graphs_;
    }
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.GraphProtoOrBuilder> 
        getGraphsOrBuilderList() {
      return graphs_;
    }
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    @java.lang.Override
    public int getGraphsCount() {
      return graphs_.size();
    }
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    @java.lang.Override
    public Onnx.GraphProto getGraphs(int index) {
      return graphs_.get(index);
    }
    /**
     * <pre>
     * list of graph
     * </pre>
     *
     * <code>repeated .GraphProto graphs = 11;</code>
     */
    @java.lang.Override
    public Onnx.GraphProtoOrBuilder getGraphsOrBuilder(
        int index) {
      return graphs_.get(index);
    }

    public static final int SPARSE_TENSORS_FIELD_NUMBER = 23;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.SparseTensorProto> sparseTensors_;
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.SparseTensorProto> getSparseTensorsList() {
      return sparseTensors_;
    }
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
        getSparseTensorsOrBuilderList() {
      return sparseTensors_;
    }
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    @java.lang.Override
    public int getSparseTensorsCount() {
      return sparseTensors_.size();
    }
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    @java.lang.Override
    public Onnx.SparseTensorProto getSparseTensors(int index) {
      return sparseTensors_.get(index);
    }
    /**
     * <pre>
     * list of sparse tensors
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
     */
    @java.lang.Override
    public Onnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
        int index) {
      return sparseTensors_.get(index);
    }

    public static final int TYPE_PROTOS_FIELD_NUMBER = 15;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TypeProto> typeProtos_;
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TypeProto> getTypeProtosList() {
      return typeProtos_;
    }
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TypeProtoOrBuilder> 
        getTypeProtosOrBuilderList() {
      return typeProtos_;
    }
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    @java.lang.Override
    public int getTypeProtosCount() {
      return typeProtos_.size();
    }
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto getTypeProtos(int index) {
      return typeProtos_.get(index);
    }
    /**
     * <pre>
     * list of type protos
     * </pre>
     *
     * <code>repeated .TypeProto type_protos = 15;</code>
     */
    @java.lang.Override
    public Onnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
        int index) {
      return typeProtos_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeFloat(2, f_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt64(3, i_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBytes(4, s_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(5, getT());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(6, getG());
      }
      for (int i = 0; i < floats_.size(); i++) {
        output.writeFloat(7, floats_.getFloat(i));
      }
      for (int i = 0; i < ints_.size(); i++) {
        output.writeInt64(8, ints_.getLong(i));
      }
      for (int i = 0; i < strings_.size(); i++) {
        output.writeBytes(9, strings_.get(i));
      }
      for (int i = 0; i < tensors_.size(); i++) {
        output.writeMessage(10, tensors_.get(i));
      }
      for (int i = 0; i < graphs_.size(); i++) {
        output.writeMessage(11, graphs_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 13, docString_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(14, getTp());
      }
      for (int i = 0; i < typeProtos_.size(); i++) {
        output.writeMessage(15, typeProtos_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeEnum(20, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 21, refAttrName_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(22, getSparseTensor());
      }
      for (int i = 0; i < sparseTensors_.size(); i++) {
        output.writeMessage(23, sparseTensors_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(2, f_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, i_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, s_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getT());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getG());
      }
      {
        int dataSize = 0;
        dataSize = 4 * getFloatsList().size();
        size += dataSize;
        size += 1 * getFloatsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < ints_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(ints_.getLong(i));
        }
        size += dataSize;
        size += 1 * getIntsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < strings_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(strings_.get(i));
        }
        size += dataSize;
        size += 1 * getStringsList().size();
      }
      for (int i = 0; i < tensors_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, tensors_.get(i));
      }
      for (int i = 0; i < graphs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, graphs_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(13, docString_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getTp());
      }
      for (int i = 0; i < typeProtos_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, typeProtos_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(20, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(21, refAttrName_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getSparseTensor());
      }
      for (int i = 0; i < sparseTensors_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(23, sparseTensors_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.AttributeProto)) {
        return super.equals(obj);
      }
      Onnx.AttributeProto other = (Onnx.AttributeProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasRefAttrName() != other.hasRefAttrName()) return false;
      if (hasRefAttrName()) {
        if (!getRefAttrName()
            .equals(other.getRefAttrName())) return false;
      }
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasF() != other.hasF()) return false;
      if (hasF()) {
        if (java.lang.Float.floatToIntBits(getF())
            != java.lang.Float.floatToIntBits(
                other.getF())) return false;
      }
      if (hasI() != other.hasI()) return false;
      if (hasI()) {
        if (getI()
            != other.getI()) return false;
      }
      if (hasS() != other.hasS()) return false;
      if (hasS()) {
        if (!getS()
            .equals(other.getS())) return false;
      }
      if (hasT() != other.hasT()) return false;
      if (hasT()) {
        if (!getT()
            .equals(other.getT())) return false;
      }
      if (hasG() != other.hasG()) return false;
      if (hasG()) {
        if (!getG()
            .equals(other.getG())) return false;
      }
      if (hasSparseTensor() != other.hasSparseTensor()) return false;
      if (hasSparseTensor()) {
        if (!getSparseTensor()
            .equals(other.getSparseTensor())) return false;
      }
      if (hasTp() != other.hasTp()) return false;
      if (hasTp()) {
        if (!getTp()
            .equals(other.getTp())) return false;
      }
      if (!getFloatsList()
          .equals(other.getFloatsList())) return false;
      if (!getIntsList()
          .equals(other.getIntsList())) return false;
      if (!getStringsList()
          .equals(other.getStringsList())) return false;
      if (!getTensorsList()
          .equals(other.getTensorsList())) return false;
      if (!getGraphsList()
          .equals(other.getGraphsList())) return false;
      if (!getSparseTensorsList()
          .equals(other.getSparseTensorsList())) return false;
      if (!getTypeProtosList()
          .equals(other.getTypeProtosList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasRefAttrName()) {
        hash = (37 * hash) + REF_ATTR_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getRefAttrName().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasF()) {
        hash = (37 * hash) + F_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getF());
      }
      if (hasI()) {
        hash = (37 * hash) + I_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getI());
      }
      if (hasS()) {
        hash = (37 * hash) + S_FIELD_NUMBER;
        hash = (53 * hash) + getS().hashCode();
      }
      if (hasT()) {
        hash = (37 * hash) + T_FIELD_NUMBER;
        hash = (53 * hash) + getT().hashCode();
      }
      if (hasG()) {
        hash = (37 * hash) + G_FIELD_NUMBER;
        hash = (53 * hash) + getG().hashCode();
      }
      if (hasSparseTensor()) {
        hash = (37 * hash) + SPARSE_TENSOR_FIELD_NUMBER;
        hash = (53 * hash) + getSparseTensor().hashCode();
      }
      if (hasTp()) {
        hash = (37 * hash) + TP_FIELD_NUMBER;
        hash = (53 * hash) + getTp().hashCode();
      }
      if (getFloatsCount() > 0) {
        hash = (37 * hash) + FLOATS_FIELD_NUMBER;
        hash = (53 * hash) + getFloatsList().hashCode();
      }
      if (getIntsCount() > 0) {
        hash = (37 * hash) + INTS_FIELD_NUMBER;
        hash = (53 * hash) + getIntsList().hashCode();
      }
      if (getStringsCount() > 0) {
        hash = (37 * hash) + STRINGS_FIELD_NUMBER;
        hash = (53 * hash) + getStringsList().hashCode();
      }
      if (getTensorsCount() > 0) {
        hash = (37 * hash) + TENSORS_FIELD_NUMBER;
        hash = (53 * hash) + getTensorsList().hashCode();
      }
      if (getGraphsCount() > 0) {
        hash = (37 * hash) + GRAPHS_FIELD_NUMBER;
        hash = (53 * hash) + getGraphsList().hashCode();
      }
      if (getSparseTensorsCount() > 0) {
        hash = (37 * hash) + SPARSE_TENSORS_FIELD_NUMBER;
        hash = (53 * hash) + getSparseTensorsList().hashCode();
      }
      if (getTypeProtosCount() > 0) {
        hash = (37 * hash) + TYPE_PROTOS_FIELD_NUMBER;
        hash = (53 * hash) + getTypeProtosList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.AttributeProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.AttributeProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.AttributeProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.AttributeProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.AttributeProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.AttributeProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.AttributeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.AttributeProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.AttributeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.AttributeProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.AttributeProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.AttributeProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.AttributeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Attributes
     *
     * A named attribute containing either singular float, integer, string, graph,
     * and tensor values, or repeated float, integer, string, graph, and tensor values.
     * An AttributeProto MUST contain the name field, and *only one* of the
     * following content fields, effectively enforcing a C/C++ union equivalent.
     * </pre>
     *
     * Protobuf type {@code AttributeProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:AttributeProto)
        Onnx.AttributeProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_AttributeProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_AttributeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.AttributeProto.class, Onnx.AttributeProto.Builder.class);
      }

      // Construct using Onnx.AttributeProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetTFieldBuilder();
          internalGetGFieldBuilder();
          internalGetSparseTensorFieldBuilder();
          internalGetTpFieldBuilder();
          internalGetTensorsFieldBuilder();
          internalGetGraphsFieldBuilder();
          internalGetSparseTensorsFieldBuilder();
          internalGetTypeProtosFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        refAttrName_ = "";
        docString_ = "";
        type_ = 0;
        f_ = 0F;
        i_ = 0L;
        s_ = com.google.protobuf.ByteString.EMPTY;
        t_ = null;
        if (tBuilder_ != null) {
          tBuilder_.dispose();
          tBuilder_ = null;
        }
        g_ = null;
        if (gBuilder_ != null) {
          gBuilder_.dispose();
          gBuilder_ = null;
        }
        sparseTensor_ = null;
        if (sparseTensorBuilder_ != null) {
          sparseTensorBuilder_.dispose();
          sparseTensorBuilder_ = null;
        }
        tp_ = null;
        if (tpBuilder_ != null) {
          tpBuilder_.dispose();
          tpBuilder_ = null;
        }
        floats_ = emptyFloatList();
        ints_ = emptyLongList();
        strings_ = emptyList(com.google.protobuf.ByteString.class);
        if (tensorsBuilder_ == null) {
          tensors_ = java.util.Collections.emptyList();
        } else {
          tensors_ = null;
          tensorsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        if (graphsBuilder_ == null) {
          graphs_ = java.util.Collections.emptyList();
        } else {
          graphs_ = null;
          graphsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00008000);
        if (sparseTensorsBuilder_ == null) {
          sparseTensors_ = java.util.Collections.emptyList();
        } else {
          sparseTensors_ = null;
          sparseTensorsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00010000);
        if (typeProtosBuilder_ == null) {
          typeProtos_ = java.util.Collections.emptyList();
        } else {
          typeProtos_ = null;
          typeProtosBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00020000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_AttributeProto_descriptor;
      }

      @java.lang.Override
      public Onnx.AttributeProto getDefaultInstanceForType() {
        return Onnx.AttributeProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.AttributeProto build() {
        Onnx.AttributeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.AttributeProto buildPartial() {
        Onnx.AttributeProto result = new Onnx.AttributeProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.AttributeProto result) {
        if (tensorsBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0)) {
            tensors_ = java.util.Collections.unmodifiableList(tensors_);
            bitField0_ = (bitField0_ & ~0x00004000);
          }
          result.tensors_ = tensors_;
        } else {
          result.tensors_ = tensorsBuilder_.build();
        }
        if (graphsBuilder_ == null) {
          if (((bitField0_ & 0x00008000) != 0)) {
            graphs_ = java.util.Collections.unmodifiableList(graphs_);
            bitField0_ = (bitField0_ & ~0x00008000);
          }
          result.graphs_ = graphs_;
        } else {
          result.graphs_ = graphsBuilder_.build();
        }
        if (sparseTensorsBuilder_ == null) {
          if (((bitField0_ & 0x00010000) != 0)) {
            sparseTensors_ = java.util.Collections.unmodifiableList(sparseTensors_);
            bitField0_ = (bitField0_ & ~0x00010000);
          }
          result.sparseTensors_ = sparseTensors_;
        } else {
          result.sparseTensors_ = sparseTensorsBuilder_.build();
        }
        if (typeProtosBuilder_ == null) {
          if (((bitField0_ & 0x00020000) != 0)) {
            typeProtos_ = java.util.Collections.unmodifiableList(typeProtos_);
            bitField0_ = (bitField0_ & ~0x00020000);
          }
          result.typeProtos_ = typeProtos_;
        } else {
          result.typeProtos_ = typeProtosBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.AttributeProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.refAttrName_ = refAttrName_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.f_ = f_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.i_ = i_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.s_ = s_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.t_ = tBuilder_ == null
              ? t_
              : tBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.g_ = gBuilder_ == null
              ? g_
              : gBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.sparseTensor_ = sparseTensorBuilder_ == null
              ? sparseTensor_
              : sparseTensorBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.tp_ = tpBuilder_ == null
              ? tp_
              : tpBuilder_.build();
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          floats_.makeImmutable();
          result.floats_ = floats_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          ints_.makeImmutable();
          result.ints_ = ints_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          strings_.makeImmutable();
          result.strings_ = strings_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.AttributeProto) {
          return mergeFrom((Onnx.AttributeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.AttributeProto other) {
        if (other == Onnx.AttributeProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRefAttrName()) {
          refAttrName_ = other.refAttrName_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasF()) {
          setF(other.getF());
        }
        if (other.hasI()) {
          setI(other.getI());
        }
        if (other.hasS()) {
          setS(other.getS());
        }
        if (other.hasT()) {
          mergeT(other.getT());
        }
        if (other.hasG()) {
          mergeG(other.getG());
        }
        if (other.hasSparseTensor()) {
          mergeSparseTensor(other.getSparseTensor());
        }
        if (other.hasTp()) {
          mergeTp(other.getTp());
        }
        if (!other.floats_.isEmpty()) {
          if (floats_.isEmpty()) {
            floats_ = other.floats_;
            floats_.makeImmutable();
            bitField0_ |= 0x00000800;
          } else {
            ensureFloatsIsMutable();
            floats_.addAll(other.floats_);
          }
          onChanged();
        }
        if (!other.ints_.isEmpty()) {
          if (ints_.isEmpty()) {
            ints_ = other.ints_;
            ints_.makeImmutable();
            bitField0_ |= 0x00001000;
          } else {
            ensureIntsIsMutable();
            ints_.addAll(other.ints_);
          }
          onChanged();
        }
        if (!other.strings_.isEmpty()) {
          if (strings_.isEmpty()) {
            strings_ = other.strings_;
            strings_.makeImmutable();
            bitField0_ |= 0x00002000;
          } else {
            ensureStringsIsMutable();
            strings_.addAll(other.strings_);
          }
          onChanged();
        }
        if (tensorsBuilder_ == null) {
          if (!other.tensors_.isEmpty()) {
            if (tensors_.isEmpty()) {
              tensors_ = other.tensors_;
              bitField0_ = (bitField0_ & ~0x00004000);
            } else {
              ensureTensorsIsMutable();
              tensors_.addAll(other.tensors_);
            }
            onChanged();
          }
        } else {
          if (!other.tensors_.isEmpty()) {
            if (tensorsBuilder_.isEmpty()) {
              tensorsBuilder_.dispose();
              tensorsBuilder_ = null;
              tensors_ = other.tensors_;
              bitField0_ = (bitField0_ & ~0x00004000);
              tensorsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetTensorsFieldBuilder() : null;
            } else {
              tensorsBuilder_.addAllMessages(other.tensors_);
            }
          }
        }
        if (graphsBuilder_ == null) {
          if (!other.graphs_.isEmpty()) {
            if (graphs_.isEmpty()) {
              graphs_ = other.graphs_;
              bitField0_ = (bitField0_ & ~0x00008000);
            } else {
              ensureGraphsIsMutable();
              graphs_.addAll(other.graphs_);
            }
            onChanged();
          }
        } else {
          if (!other.graphs_.isEmpty()) {
            if (graphsBuilder_.isEmpty()) {
              graphsBuilder_.dispose();
              graphsBuilder_ = null;
              graphs_ = other.graphs_;
              bitField0_ = (bitField0_ & ~0x00008000);
              graphsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetGraphsFieldBuilder() : null;
            } else {
              graphsBuilder_.addAllMessages(other.graphs_);
            }
          }
        }
        if (sparseTensorsBuilder_ == null) {
          if (!other.sparseTensors_.isEmpty()) {
            if (sparseTensors_.isEmpty()) {
              sparseTensors_ = other.sparseTensors_;
              bitField0_ = (bitField0_ & ~0x00010000);
            } else {
              ensureSparseTensorsIsMutable();
              sparseTensors_.addAll(other.sparseTensors_);
            }
            onChanged();
          }
        } else {
          if (!other.sparseTensors_.isEmpty()) {
            if (sparseTensorsBuilder_.isEmpty()) {
              sparseTensorsBuilder_.dispose();
              sparseTensorsBuilder_ = null;
              sparseTensors_ = other.sparseTensors_;
              bitField0_ = (bitField0_ & ~0x00010000);
              sparseTensorsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetSparseTensorsFieldBuilder() : null;
            } else {
              sparseTensorsBuilder_.addAllMessages(other.sparseTensors_);
            }
          }
        }
        if (typeProtosBuilder_ == null) {
          if (!other.typeProtos_.isEmpty()) {
            if (typeProtos_.isEmpty()) {
              typeProtos_ = other.typeProtos_;
              bitField0_ = (bitField0_ & ~0x00020000);
            } else {
              ensureTypeProtosIsMutable();
              typeProtos_.addAll(other.typeProtos_);
            }
            onChanged();
          }
        } else {
          if (!other.typeProtos_.isEmpty()) {
            if (typeProtosBuilder_.isEmpty()) {
              typeProtosBuilder_.dispose();
              typeProtosBuilder_ = null;
              typeProtos_ = other.typeProtos_;
              bitField0_ = (bitField0_ & ~0x00020000);
              typeProtosBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetTypeProtosFieldBuilder() : null;
            } else {
              typeProtosBuilder_.addAllMessages(other.typeProtos_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 21: {
                f_ = input.readFloat();
                bitField0_ |= 0x00000010;
                break;
              } // case 21
              case 24: {
                i_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 24
              case 34: {
                s_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    internalGetTFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    internalGetGFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 50
              case 61: {
                float v = input.readFloat();
                ensureFloatsIsMutable();
                floats_.addFloat(v);
                break;
              } // case 61
              case 58: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                int alloc = length > 4096 ? 4096 : length;
                ensureFloatsIsMutable(alloc / 4);
                while (input.getBytesUntilLimit() > 0) {
                  floats_.addFloat(input.readFloat());
                }
                input.popLimit(limit);
                break;
              } // case 58
              case 64: {
                long v = input.readInt64();
                ensureIntsIsMutable();
                ints_.addLong(v);
                break;
              } // case 64
              case 66: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureIntsIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  ints_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 66
              case 74: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureStringsIsMutable();
                strings_.add(v);
                break;
              } // case 74
              case 82: {
                Onnx.TensorProto m =
                    input.readMessage(
                        Onnx.TensorProto.parser(),
                        extensionRegistry);
                if (tensorsBuilder_ == null) {
                  ensureTensorsIsMutable();
                  tensors_.add(m);
                } else {
                  tensorsBuilder_.addMessage(m);
                }
                break;
              } // case 82
              case 90: {
                Onnx.GraphProto m =
                    input.readMessage(
                        Onnx.GraphProto.parser(),
                        extensionRegistry);
                if (graphsBuilder_ == null) {
                  ensureGraphsIsMutable();
                  graphs_.add(m);
                } else {
                  graphsBuilder_.addMessage(m);
                }
                break;
              } // case 90
              case 106: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 106
              case 114: {
                input.readMessage(
                    internalGetTpFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 114
              case 122: {
                Onnx.TypeProto m =
                    input.readMessage(
                        Onnx.TypeProto.parser(),
                        extensionRegistry);
                if (typeProtosBuilder_ == null) {
                  ensureTypeProtosIsMutable();
                  typeProtos_.add(m);
                } else {
                  typeProtosBuilder_.addMessage(m);
                }
                break;
              } // case 122
              case 160: {
                int tmpRaw = input.readEnum();
                Onnx.AttributeProto.AttributeType tmpValue =
                    Onnx.AttributeProto.AttributeType.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(20, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000008;
                }
                break;
              } // case 160
              case 170: {
                refAttrName_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 170
              case 178: {
                input.readMessage(
                    internalGetSparseTensorFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000200;
                break;
              } // case 178
              case 186: {
                Onnx.SparseTensorProto m =
                    input.readMessage(
                        Onnx.SparseTensorProto.parser(),
                        extensionRegistry);
                if (sparseTensorsBuilder_ == null) {
                  ensureSparseTensorsIsMutable();
                  sparseTensors_.add(m);
                } else {
                  sparseTensorsBuilder_.addMessage(m);
                }
                break;
              } // case 186
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object refAttrName_ = "";
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @return Whether the refAttrName field is set.
       */
      public boolean hasRefAttrName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @return The refAttrName.
       */
      public java.lang.String getRefAttrName() {
        java.lang.Object ref = refAttrName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            refAttrName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @return The bytes for refAttrName.
       */
      public com.google.protobuf.ByteString
          getRefAttrNameBytes() {
        java.lang.Object ref = refAttrName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          refAttrName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @param value The refAttrName to set.
       * @return This builder for chaining.
       */
      public Builder setRefAttrName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        refAttrName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @return This builder for chaining.
       */
      public Builder clearRefAttrName() {
        refAttrName_ = getDefaultInstance().getRefAttrName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
       * In this case, this AttributeProto does not contain data, and it's a reference of attribute
       * in parent scope.
       * NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
       * </pre>
       *
       * <code>optional string ref_attr_name = 21;</code>
       * @param value The bytes for refAttrName to set.
       * @return This builder for chaining.
       */
      public Builder setRefAttrNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        refAttrName_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this attribute. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 13;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private int type_ = 0;
      /**
       * <pre>
       * The type field MUST be present for this version of the IR.
       * For 0.0.1 versions of the IR, this field was not defined, and
       * implementations needed to use has_field heuristics to determine
       * which value field was in use.  For IR_VERSION 0.0.2 or later, this
       * field MUST be set and match the f|i|s|t|... field in use.  This
       * change was made to accommodate proto3 implementations.
       * </pre>
       *
       * <code>optional .AttributeProto.AttributeType type = 20;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The type field MUST be present for this version of the IR.
       * For 0.0.1 versions of the IR, this field was not defined, and
       * implementations needed to use has_field heuristics to determine
       * which value field was in use.  For IR_VERSION 0.0.2 or later, this
       * field MUST be set and match the f|i|s|t|... field in use.  This
       * change was made to accommodate proto3 implementations.
       * </pre>
       *
       * <code>optional .AttributeProto.AttributeType type = 20;</code>
       * @return The type.
       */
      @java.lang.Override
      public Onnx.AttributeProto.AttributeType getType() {
        Onnx.AttributeProto.AttributeType result = Onnx.AttributeProto.AttributeType.forNumber(type_);
        return result == null ? Onnx.AttributeProto.AttributeType.UNDEFINED : result;
      }
      /**
       * <pre>
       * The type field MUST be present for this version of the IR.
       * For 0.0.1 versions of the IR, this field was not defined, and
       * implementations needed to use has_field heuristics to determine
       * which value field was in use.  For IR_VERSION 0.0.2 or later, this
       * field MUST be set and match the f|i|s|t|... field in use.  This
       * change was made to accommodate proto3 implementations.
       * </pre>
       *
       * <code>optional .AttributeProto.AttributeType type = 20;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(Onnx.AttributeProto.AttributeType value) {
        if (value == null) { throw new NullPointerException(); }
        bitField0_ |= 0x00000008;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type field MUST be present for this version of the IR.
       * For 0.0.1 versions of the IR, this field was not defined, and
       * implementations needed to use has_field heuristics to determine
       * which value field was in use.  For IR_VERSION 0.0.2 or later, this
       * field MUST be set and match the f|i|s|t|... field in use.  This
       * change was made to accommodate proto3 implementations.
       * </pre>
       *
       * <code>optional .AttributeProto.AttributeType type = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000008);
        type_ = 0;
        onChanged();
        return this;
      }

      private float f_ ;
      /**
       * <pre>
       * Exactly ONE of the following fields must be present for this version of the IR
       * </pre>
       *
       * <code>optional float f = 2;</code>
       * @return Whether the f field is set.
       */
      @java.lang.Override
      public boolean hasF() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Exactly ONE of the following fields must be present for this version of the IR
       * </pre>
       *
       * <code>optional float f = 2;</code>
       * @return The f.
       */
      @java.lang.Override
      public float getF() {
        return f_;
      }
      /**
       * <pre>
       * Exactly ONE of the following fields must be present for this version of the IR
       * </pre>
       *
       * <code>optional float f = 2;</code>
       * @param value The f to set.
       * @return This builder for chaining.
       */
      public Builder setF(float value) {

        f_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Exactly ONE of the following fields must be present for this version of the IR
       * </pre>
       *
       * <code>optional float f = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearF() {
        bitField0_ = (bitField0_ & ~0x00000010);
        f_ = 0F;
        onChanged();
        return this;
      }

      private long i_ ;
      /**
       * <pre>
       * int
       * </pre>
       *
       * <code>optional int64 i = 3;</code>
       * @return Whether the i field is set.
       */
      @java.lang.Override
      public boolean hasI() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * int
       * </pre>
       *
       * <code>optional int64 i = 3;</code>
       * @return The i.
       */
      @java.lang.Override
      public long getI() {
        return i_;
      }
      /**
       * <pre>
       * int
       * </pre>
       *
       * <code>optional int64 i = 3;</code>
       * @param value The i to set.
       * @return This builder for chaining.
       */
      public Builder setI(long value) {

        i_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * int
       * </pre>
       *
       * <code>optional int64 i = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearI() {
        bitField0_ = (bitField0_ & ~0x00000020);
        i_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString s_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * UTF-8 string
       * </pre>
       *
       * <code>optional bytes s = 4;</code>
       * @return Whether the s field is set.
       */
      @java.lang.Override
      public boolean hasS() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * UTF-8 string
       * </pre>
       *
       * <code>optional bytes s = 4;</code>
       * @return The s.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getS() {
        return s_;
      }
      /**
       * <pre>
       * UTF-8 string
       * </pre>
       *
       * <code>optional bytes s = 4;</code>
       * @param value The s to set.
       * @return This builder for chaining.
       */
      public Builder setS(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        s_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * UTF-8 string
       * </pre>
       *
       * <code>optional bytes s = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearS() {
        bitField0_ = (bitField0_ & ~0x00000040);
        s_ = getDefaultInstance().getS();
        onChanged();
        return this;
      }

      private Onnx.TensorProto t_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> tBuilder_;
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       * @return Whether the t field is set.
       */
      public boolean hasT() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       * @return The t.
       */
      public Onnx.TensorProto getT() {
        if (tBuilder_ == null) {
          return t_ == null ? Onnx.TensorProto.getDefaultInstance() : t_;
        } else {
          return tBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Builder setT(Onnx.TensorProto value) {
        if (tBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          t_ = value;
        } else {
          tBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Builder setT(
          Onnx.TensorProto.Builder builderForValue) {
        if (tBuilder_ == null) {
          t_ = builderForValue.build();
        } else {
          tBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Builder mergeT(Onnx.TensorProto value) {
        if (tBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            t_ != null &&
            t_ != Onnx.TensorProto.getDefaultInstance()) {
            getTBuilder().mergeFrom(value);
          } else {
            t_ = value;
          }
        } else {
          tBuilder_.mergeFrom(value);
        }
        if (t_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Builder clearT() {
        bitField0_ = (bitField0_ & ~0x00000080);
        t_ = null;
        if (tBuilder_ != null) {
          tBuilder_.dispose();
          tBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Onnx.TensorProto.Builder getTBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return internalGetTFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      public Onnx.TensorProtoOrBuilder getTOrBuilder() {
        if (tBuilder_ != null) {
          return tBuilder_.getMessageOrBuilder();
        } else {
          return t_ == null ?
              Onnx.TensorProto.getDefaultInstance() : t_;
        }
      }
      /**
       * <pre>
       * tensor value
       * </pre>
       *
       * <code>optional .TensorProto t = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> 
          internalGetTFieldBuilder() {
        if (tBuilder_ == null) {
          tBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder>(
                  getT(),
                  getParentForChildren(),
                  isClean());
          t_ = null;
        }
        return tBuilder_;
      }

      private Onnx.GraphProto g_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> gBuilder_;
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       * @return Whether the g field is set.
       */
      public boolean hasG() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       * @return The g.
       */
      public Onnx.GraphProto getG() {
        if (gBuilder_ == null) {
          return g_ == null ? Onnx.GraphProto.getDefaultInstance() : g_;
        } else {
          return gBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Builder setG(Onnx.GraphProto value) {
        if (gBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          g_ = value;
        } else {
          gBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Builder setG(
          Onnx.GraphProto.Builder builderForValue) {
        if (gBuilder_ == null) {
          g_ = builderForValue.build();
        } else {
          gBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Builder mergeG(Onnx.GraphProto value) {
        if (gBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            g_ != null &&
            g_ != Onnx.GraphProto.getDefaultInstance()) {
            getGBuilder().mergeFrom(value);
          } else {
            g_ = value;
          }
        } else {
          gBuilder_.mergeFrom(value);
        }
        if (g_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Builder clearG() {
        bitField0_ = (bitField0_ & ~0x00000100);
        g_ = null;
        if (gBuilder_ != null) {
          gBuilder_.dispose();
          gBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Onnx.GraphProto.Builder getGBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return internalGetGFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      public Onnx.GraphProtoOrBuilder getGOrBuilder() {
        if (gBuilder_ != null) {
          return gBuilder_.getMessageOrBuilder();
        } else {
          return g_ == null ?
              Onnx.GraphProto.getDefaultInstance() : g_;
        }
      }
      /**
       * <pre>
       * graph
       * </pre>
       *
       * <code>optional .GraphProto g = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> 
          internalGetGFieldBuilder() {
        if (gBuilder_ == null) {
          gBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder>(
                  getG(),
                  getParentForChildren(),
                  isClean());
          g_ = null;
        }
        return gBuilder_;
      }

      private Onnx.SparseTensorProto sparseTensor_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> sparseTensorBuilder_;
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       * @return Whether the sparseTensor field is set.
       */
      public boolean hasSparseTensor() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       * @return The sparseTensor.
       */
      public Onnx.SparseTensorProto getSparseTensor() {
        if (sparseTensorBuilder_ == null) {
          return sparseTensor_ == null ? Onnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        } else {
          return sparseTensorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Builder setSparseTensor(Onnx.SparseTensorProto value) {
        if (sparseTensorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          sparseTensor_ = value;
        } else {
          sparseTensorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Builder setSparseTensor(
          Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseTensorBuilder_ == null) {
          sparseTensor_ = builderForValue.build();
        } else {
          sparseTensorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Builder mergeSparseTensor(Onnx.SparseTensorProto value) {
        if (sparseTensorBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
            sparseTensor_ != null &&
            sparseTensor_ != Onnx.SparseTensorProto.getDefaultInstance()) {
            getSparseTensorBuilder().mergeFrom(value);
          } else {
            sparseTensor_ = value;
          }
        } else {
          sparseTensorBuilder_.mergeFrom(value);
        }
        if (sparseTensor_ != null) {
          bitField0_ |= 0x00000200;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Builder clearSparseTensor() {
        bitField0_ = (bitField0_ & ~0x00000200);
        sparseTensor_ = null;
        if (sparseTensorBuilder_ != null) {
          sparseTensorBuilder_.dispose();
          sparseTensorBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Onnx.SparseTensorProto.Builder getSparseTensorBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return internalGetSparseTensorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      public Onnx.SparseTensorProtoOrBuilder getSparseTensorOrBuilder() {
        if (sparseTensorBuilder_ != null) {
          return sparseTensorBuilder_.getMessageOrBuilder();
        } else {
          return sparseTensor_ == null ?
              Onnx.SparseTensorProto.getDefaultInstance() : sparseTensor_;
        }
      }
      /**
       * <pre>
       * sparse tensor value
       * </pre>
       *
       * <code>optional .SparseTensorProto sparse_tensor = 22;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> 
          internalGetSparseTensorFieldBuilder() {
        if (sparseTensorBuilder_ == null) {
          sparseTensorBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder>(
                  getSparseTensor(),
                  getParentForChildren(),
                  isClean());
          sparseTensor_ = null;
        }
        return sparseTensorBuilder_;
      }

      private Onnx.TypeProto tp_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> tpBuilder_;
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       * @return Whether the tp field is set.
       */
      public boolean hasTp() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       * @return The tp.
       */
      public Onnx.TypeProto getTp() {
        if (tpBuilder_ == null) {
          return tp_ == null ? Onnx.TypeProto.getDefaultInstance() : tp_;
        } else {
          return tpBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Builder setTp(Onnx.TypeProto value) {
        if (tpBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tp_ = value;
        } else {
          tpBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Builder setTp(
          Onnx.TypeProto.Builder builderForValue) {
        if (tpBuilder_ == null) {
          tp_ = builderForValue.build();
        } else {
          tpBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Builder mergeTp(Onnx.TypeProto value) {
        if (tpBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            tp_ != null &&
            tp_ != Onnx.TypeProto.getDefaultInstance()) {
            getTpBuilder().mergeFrom(value);
          } else {
            tp_ = value;
          }
        } else {
          tpBuilder_.mergeFrom(value);
        }
        if (tp_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Builder clearTp() {
        bitField0_ = (bitField0_ & ~0x00000400);
        tp_ = null;
        if (tpBuilder_ != null) {
          tpBuilder_.dispose();
          tpBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Onnx.TypeProto.Builder getTpBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return internalGetTpFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      public Onnx.TypeProtoOrBuilder getTpOrBuilder() {
        if (tpBuilder_ != null) {
          return tpBuilder_.getMessageOrBuilder();
        } else {
          return tp_ == null ?
              Onnx.TypeProto.getDefaultInstance() : tp_;
        }
      }
      /**
       * <pre>
       * Do not use field below, it's deprecated.
       * optional ValueProto v = 12;         // value - subsumes everything but graph
       * </pre>
       *
       * <code>optional .TypeProto tp = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
          internalGetTpFieldBuilder() {
        if (tpBuilder_ == null) {
          tpBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                  getTp(),
                  getParentForChildren(),
                  isClean());
          tp_ = null;
        }
        return tpBuilder_;
      }

      private com.google.protobuf.Internal.FloatList floats_ = emptyFloatList();
      private void ensureFloatsIsMutable() {
        if (!floats_.isModifiable()) {
          floats_ = makeMutableCopy(floats_);
        }
        bitField0_ |= 0x00000800;
      }
      private void ensureFloatsIsMutable(int capacity) {
        if (!floats_.isModifiable()) {
          floats_ = makeMutableCopy(floats_, capacity);
        }
        bitField0_ |= 0x00000800;
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @return A list containing the floats.
       */
      public java.util.List<java.lang.Float>
          getFloatsList() {
        floats_.makeImmutable();
        return floats_;
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @return The count of floats.
       */
      public int getFloatsCount() {
        return floats_.size();
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @param index The index of the element to return.
       * @return The floats at the given index.
       */
      public float getFloats(int index) {
        return floats_.getFloat(index);
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @param index The index to set the value at.
       * @param value The floats to set.
       * @return This builder for chaining.
       */
      public Builder setFloats(
          int index, float value) {

        ensureFloatsIsMutable();
        floats_.setFloat(index, value);
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @param value The floats to add.
       * @return This builder for chaining.
       */
      public Builder addFloats(float value) {

        ensureFloatsIsMutable();
        floats_.addFloat(value);
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @param values The floats to add.
       * @return This builder for chaining.
       */
      public Builder addAllFloats(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureFloatsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, floats_);
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of floats
       * </pre>
       *
       * <code>repeated float floats = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFloats() {
        floats_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList ints_ = emptyLongList();
      private void ensureIntsIsMutable() {
        if (!ints_.isModifiable()) {
          ints_ = makeMutableCopy(ints_);
        }
        bitField0_ |= 0x00001000;
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @return A list containing the ints.
       */
      public java.util.List<java.lang.Long>
          getIntsList() {
        ints_.makeImmutable();
        return ints_;
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @return The count of ints.
       */
      public int getIntsCount() {
        return ints_.size();
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @param index The index of the element to return.
       * @return The ints at the given index.
       */
      public long getInts(int index) {
        return ints_.getLong(index);
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @param index The index to set the value at.
       * @param value The ints to set.
       * @return This builder for chaining.
       */
      public Builder setInts(
          int index, long value) {

        ensureIntsIsMutable();
        ints_.setLong(index, value);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @param value The ints to add.
       * @return This builder for chaining.
       */
      public Builder addInts(long value) {

        ensureIntsIsMutable();
        ints_.addLong(value);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @param values The ints to add.
       * @return This builder for chaining.
       */
      public Builder addAllInts(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureIntsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, ints_);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of ints
       * </pre>
       *
       * <code>repeated int64 ints = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearInts() {
        ints_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> strings_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureStringsIsMutable() {
        if (!strings_.isModifiable()) {
          strings_ = makeMutableCopy(strings_);
        }
        bitField0_ |= 0x00002000;
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @return A list containing the strings.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getStringsList() {
        strings_.makeImmutable();
        return strings_;
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @return The count of strings.
       */
      public int getStringsCount() {
        return strings_.size();
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @param index The index of the element to return.
       * @return The strings at the given index.
       */
      public com.google.protobuf.ByteString getStrings(int index) {
        return strings_.get(index);
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @param index The index to set the value at.
       * @param value The strings to set.
       * @return This builder for chaining.
       */
      public Builder setStrings(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStringsIsMutable();
        strings_.set(index, value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @param value The strings to add.
       * @return This builder for chaining.
       */
      public Builder addStrings(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStringsIsMutable();
        strings_.add(value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @param values The strings to add.
       * @return This builder for chaining.
       */
      public Builder addAllStrings(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureStringsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, strings_);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * list of UTF-8 strings
       * </pre>
       *
       * <code>repeated bytes strings = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearStrings() {
        strings_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }

      private java.util.List<Onnx.TensorProto> tensors_ =
        java.util.Collections.emptyList();
      private void ensureTensorsIsMutable() {
        if (!((bitField0_ & 0x00004000) != 0)) {
          tensors_ = new java.util.ArrayList<Onnx.TensorProto>(tensors_);
          bitField0_ |= 0x00004000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> tensorsBuilder_;

      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public java.util.List<Onnx.TensorProto> getTensorsList() {
        if (tensorsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tensors_);
        } else {
          return tensorsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public int getTensorsCount() {
        if (tensorsBuilder_ == null) {
          return tensors_.size();
        } else {
          return tensorsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Onnx.TensorProto getTensors(int index) {
        if (tensorsBuilder_ == null) {
          return tensors_.get(index);
        } else {
          return tensorsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder setTensors(
          int index, Onnx.TensorProto value) {
        if (tensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTensorsIsMutable();
          tensors_.set(index, value);
          onChanged();
        } else {
          tensorsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder setTensors(
          int index, Onnx.TensorProto.Builder builderForValue) {
        if (tensorsBuilder_ == null) {
          ensureTensorsIsMutable();
          tensors_.set(index, builderForValue.build());
          onChanged();
        } else {
          tensorsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder addTensors(Onnx.TensorProto value) {
        if (tensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTensorsIsMutable();
          tensors_.add(value);
          onChanged();
        } else {
          tensorsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder addTensors(
          int index, Onnx.TensorProto value) {
        if (tensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTensorsIsMutable();
          tensors_.add(index, value);
          onChanged();
        } else {
          tensorsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder addTensors(
          Onnx.TensorProto.Builder builderForValue) {
        if (tensorsBuilder_ == null) {
          ensureTensorsIsMutable();
          tensors_.add(builderForValue.build());
          onChanged();
        } else {
          tensorsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder addTensors(
          int index, Onnx.TensorProto.Builder builderForValue) {
        if (tensorsBuilder_ == null) {
          ensureTensorsIsMutable();
          tensors_.add(index, builderForValue.build());
          onChanged();
        } else {
          tensorsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder addAllTensors(
          java.lang.Iterable<? extends Onnx.TensorProto> values) {
        if (tensorsBuilder_ == null) {
          ensureTensorsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tensors_);
          onChanged();
        } else {
          tensorsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder clearTensors() {
        if (tensorsBuilder_ == null) {
          tensors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00004000);
          onChanged();
        } else {
          tensorsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Builder removeTensors(int index) {
        if (tensorsBuilder_ == null) {
          ensureTensorsIsMutable();
          tensors_.remove(index);
          onChanged();
        } else {
          tensorsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Onnx.TensorProto.Builder getTensorsBuilder(
          int index) {
        return internalGetTensorsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Onnx.TensorProtoOrBuilder getTensorsOrBuilder(
          int index) {
        if (tensorsBuilder_ == null) {
          return tensors_.get(index);  } else {
          return tensorsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public java.util.List<? extends Onnx.TensorProtoOrBuilder> 
           getTensorsOrBuilderList() {
        if (tensorsBuilder_ != null) {
          return tensorsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tensors_);
        }
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Onnx.TensorProto.Builder addTensorsBuilder() {
        return internalGetTensorsFieldBuilder().addBuilder(
            Onnx.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public Onnx.TensorProto.Builder addTensorsBuilder(
          int index) {
        return internalGetTensorsFieldBuilder().addBuilder(
            index, Onnx.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of tensors
       * </pre>
       *
       * <code>repeated .TensorProto tensors = 10;</code>
       */
      public java.util.List<Onnx.TensorProto.Builder> 
           getTensorsBuilderList() {
        return internalGetTensorsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> 
          internalGetTensorsFieldBuilder() {
        if (tensorsBuilder_ == null) {
          tensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder>(
                  tensors_,
                  ((bitField0_ & 0x00004000) != 0),
                  getParentForChildren(),
                  isClean());
          tensors_ = null;
        }
        return tensorsBuilder_;
      }

      private java.util.List<Onnx.GraphProto> graphs_ =
        java.util.Collections.emptyList();
      private void ensureGraphsIsMutable() {
        if (!((bitField0_ & 0x00008000) != 0)) {
          graphs_ = new java.util.ArrayList<Onnx.GraphProto>(graphs_);
          bitField0_ |= 0x00008000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> graphsBuilder_;

      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public java.util.List<Onnx.GraphProto> getGraphsList() {
        if (graphsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(graphs_);
        } else {
          return graphsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public int getGraphsCount() {
        if (graphsBuilder_ == null) {
          return graphs_.size();
        } else {
          return graphsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Onnx.GraphProto getGraphs(int index) {
        if (graphsBuilder_ == null) {
          return graphs_.get(index);
        } else {
          return graphsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder setGraphs(
          int index, Onnx.GraphProto value) {
        if (graphsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGraphsIsMutable();
          graphs_.set(index, value);
          onChanged();
        } else {
          graphsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder setGraphs(
          int index, Onnx.GraphProto.Builder builderForValue) {
        if (graphsBuilder_ == null) {
          ensureGraphsIsMutable();
          graphs_.set(index, builderForValue.build());
          onChanged();
        } else {
          graphsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder addGraphs(Onnx.GraphProto value) {
        if (graphsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGraphsIsMutable();
          graphs_.add(value);
          onChanged();
        } else {
          graphsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder addGraphs(
          int index, Onnx.GraphProto value) {
        if (graphsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGraphsIsMutable();
          graphs_.add(index, value);
          onChanged();
        } else {
          graphsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder addGraphs(
          Onnx.GraphProto.Builder builderForValue) {
        if (graphsBuilder_ == null) {
          ensureGraphsIsMutable();
          graphs_.add(builderForValue.build());
          onChanged();
        } else {
          graphsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder addGraphs(
          int index, Onnx.GraphProto.Builder builderForValue) {
        if (graphsBuilder_ == null) {
          ensureGraphsIsMutable();
          graphs_.add(index, builderForValue.build());
          onChanged();
        } else {
          graphsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder addAllGraphs(
          java.lang.Iterable<? extends Onnx.GraphProto> values) {
        if (graphsBuilder_ == null) {
          ensureGraphsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, graphs_);
          onChanged();
        } else {
          graphsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder clearGraphs() {
        if (graphsBuilder_ == null) {
          graphs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00008000);
          onChanged();
        } else {
          graphsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Builder removeGraphs(int index) {
        if (graphsBuilder_ == null) {
          ensureGraphsIsMutable();
          graphs_.remove(index);
          onChanged();
        } else {
          graphsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Onnx.GraphProto.Builder getGraphsBuilder(
          int index) {
        return internalGetGraphsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Onnx.GraphProtoOrBuilder getGraphsOrBuilder(
          int index) {
        if (graphsBuilder_ == null) {
          return graphs_.get(index);  } else {
          return graphsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public java.util.List<? extends Onnx.GraphProtoOrBuilder> 
           getGraphsOrBuilderList() {
        if (graphsBuilder_ != null) {
          return graphsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(graphs_);
        }
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Onnx.GraphProto.Builder addGraphsBuilder() {
        return internalGetGraphsFieldBuilder().addBuilder(
            Onnx.GraphProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public Onnx.GraphProto.Builder addGraphsBuilder(
          int index) {
        return internalGetGraphsFieldBuilder().addBuilder(
            index, Onnx.GraphProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of graph
       * </pre>
       *
       * <code>repeated .GraphProto graphs = 11;</code>
       */
      public java.util.List<Onnx.GraphProto.Builder> 
           getGraphsBuilderList() {
        return internalGetGraphsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> 
          internalGetGraphsFieldBuilder() {
        if (graphsBuilder_ == null) {
          graphsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder>(
                  graphs_,
                  ((bitField0_ & 0x00008000) != 0),
                  getParentForChildren(),
                  isClean());
          graphs_ = null;
        }
        return graphsBuilder_;
      }

      private java.util.List<Onnx.SparseTensorProto> sparseTensors_ =
        java.util.Collections.emptyList();
      private void ensureSparseTensorsIsMutable() {
        if (!((bitField0_ & 0x00010000) != 0)) {
          sparseTensors_ = new java.util.ArrayList<Onnx.SparseTensorProto>(sparseTensors_);
          bitField0_ |= 0x00010000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> sparseTensorsBuilder_;

      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public java.util.List<Onnx.SparseTensorProto> getSparseTensorsList() {
        if (sparseTensorsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(sparseTensors_);
        } else {
          return sparseTensorsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public int getSparseTensorsCount() {
        if (sparseTensorsBuilder_ == null) {
          return sparseTensors_.size();
        } else {
          return sparseTensorsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Onnx.SparseTensorProto getSparseTensors(int index) {
        if (sparseTensorsBuilder_ == null) {
          return sparseTensors_.get(index);
        } else {
          return sparseTensorsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder setSparseTensors(
          int index, Onnx.SparseTensorProto value) {
        if (sparseTensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseTensorsIsMutable();
          sparseTensors_.set(index, value);
          onChanged();
        } else {
          sparseTensorsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder setSparseTensors(
          int index, Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseTensorsBuilder_ == null) {
          ensureSparseTensorsIsMutable();
          sparseTensors_.set(index, builderForValue.build());
          onChanged();
        } else {
          sparseTensorsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder addSparseTensors(Onnx.SparseTensorProto value) {
        if (sparseTensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseTensorsIsMutable();
          sparseTensors_.add(value);
          onChanged();
        } else {
          sparseTensorsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder addSparseTensors(
          int index, Onnx.SparseTensorProto value) {
        if (sparseTensorsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseTensorsIsMutable();
          sparseTensors_.add(index, value);
          onChanged();
        } else {
          sparseTensorsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder addSparseTensors(
          Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseTensorsBuilder_ == null) {
          ensureSparseTensorsIsMutable();
          sparseTensors_.add(builderForValue.build());
          onChanged();
        } else {
          sparseTensorsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder addSparseTensors(
          int index, Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseTensorsBuilder_ == null) {
          ensureSparseTensorsIsMutable();
          sparseTensors_.add(index, builderForValue.build());
          onChanged();
        } else {
          sparseTensorsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder addAllSparseTensors(
          java.lang.Iterable<? extends Onnx.SparseTensorProto> values) {
        if (sparseTensorsBuilder_ == null) {
          ensureSparseTensorsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, sparseTensors_);
          onChanged();
        } else {
          sparseTensorsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder clearSparseTensors() {
        if (sparseTensorsBuilder_ == null) {
          sparseTensors_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00010000);
          onChanged();
        } else {
          sparseTensorsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Builder removeSparseTensors(int index) {
        if (sparseTensorsBuilder_ == null) {
          ensureSparseTensorsIsMutable();
          sparseTensors_.remove(index);
          onChanged();
        } else {
          sparseTensorsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Onnx.SparseTensorProto.Builder getSparseTensorsBuilder(
          int index) {
        return internalGetSparseTensorsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Onnx.SparseTensorProtoOrBuilder getSparseTensorsOrBuilder(
          int index) {
        if (sparseTensorsBuilder_ == null) {
          return sparseTensors_.get(index);  } else {
          return sparseTensorsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
           getSparseTensorsOrBuilderList() {
        if (sparseTensorsBuilder_ != null) {
          return sparseTensorsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(sparseTensors_);
        }
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Onnx.SparseTensorProto.Builder addSparseTensorsBuilder() {
        return internalGetSparseTensorsFieldBuilder().addBuilder(
            Onnx.SparseTensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public Onnx.SparseTensorProto.Builder addSparseTensorsBuilder(
          int index) {
        return internalGetSparseTensorsFieldBuilder().addBuilder(
            index, Onnx.SparseTensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of sparse tensors
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_tensors = 23;</code>
       */
      public java.util.List<Onnx.SparseTensorProto.Builder> 
           getSparseTensorsBuilderList() {
        return internalGetSparseTensorsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> 
          internalGetSparseTensorsFieldBuilder() {
        if (sparseTensorsBuilder_ == null) {
          sparseTensorsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder>(
                  sparseTensors_,
                  ((bitField0_ & 0x00010000) != 0),
                  getParentForChildren(),
                  isClean());
          sparseTensors_ = null;
        }
        return sparseTensorsBuilder_;
      }

      private java.util.List<Onnx.TypeProto> typeProtos_ =
        java.util.Collections.emptyList();
      private void ensureTypeProtosIsMutable() {
        if (!((bitField0_ & 0x00020000) != 0)) {
          typeProtos_ = new java.util.ArrayList<Onnx.TypeProto>(typeProtos_);
          bitField0_ |= 0x00020000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> typeProtosBuilder_;

      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public java.util.List<Onnx.TypeProto> getTypeProtosList() {
        if (typeProtosBuilder_ == null) {
          return java.util.Collections.unmodifiableList(typeProtos_);
        } else {
          return typeProtosBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public int getTypeProtosCount() {
        if (typeProtosBuilder_ == null) {
          return typeProtos_.size();
        } else {
          return typeProtosBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Onnx.TypeProto getTypeProtos(int index) {
        if (typeProtosBuilder_ == null) {
          return typeProtos_.get(index);
        } else {
          return typeProtosBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder setTypeProtos(
          int index, Onnx.TypeProto value) {
        if (typeProtosBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTypeProtosIsMutable();
          typeProtos_.set(index, value);
          onChanged();
        } else {
          typeProtosBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder setTypeProtos(
          int index, Onnx.TypeProto.Builder builderForValue) {
        if (typeProtosBuilder_ == null) {
          ensureTypeProtosIsMutable();
          typeProtos_.set(index, builderForValue.build());
          onChanged();
        } else {
          typeProtosBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder addTypeProtos(Onnx.TypeProto value) {
        if (typeProtosBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTypeProtosIsMutable();
          typeProtos_.add(value);
          onChanged();
        } else {
          typeProtosBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder addTypeProtos(
          int index, Onnx.TypeProto value) {
        if (typeProtosBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTypeProtosIsMutable();
          typeProtos_.add(index, value);
          onChanged();
        } else {
          typeProtosBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder addTypeProtos(
          Onnx.TypeProto.Builder builderForValue) {
        if (typeProtosBuilder_ == null) {
          ensureTypeProtosIsMutable();
          typeProtos_.add(builderForValue.build());
          onChanged();
        } else {
          typeProtosBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder addTypeProtos(
          int index, Onnx.TypeProto.Builder builderForValue) {
        if (typeProtosBuilder_ == null) {
          ensureTypeProtosIsMutable();
          typeProtos_.add(index, builderForValue.build());
          onChanged();
        } else {
          typeProtosBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder addAllTypeProtos(
          java.lang.Iterable<? extends Onnx.TypeProto> values) {
        if (typeProtosBuilder_ == null) {
          ensureTypeProtosIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, typeProtos_);
          onChanged();
        } else {
          typeProtosBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder clearTypeProtos() {
        if (typeProtosBuilder_ == null) {
          typeProtos_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
          onChanged();
        } else {
          typeProtosBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Builder removeTypeProtos(int index) {
        if (typeProtosBuilder_ == null) {
          ensureTypeProtosIsMutable();
          typeProtos_.remove(index);
          onChanged();
        } else {
          typeProtosBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Onnx.TypeProto.Builder getTypeProtosBuilder(
          int index) {
        return internalGetTypeProtosFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Onnx.TypeProtoOrBuilder getTypeProtosOrBuilder(
          int index) {
        if (typeProtosBuilder_ == null) {
          return typeProtos_.get(index);  } else {
          return typeProtosBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public java.util.List<? extends Onnx.TypeProtoOrBuilder> 
           getTypeProtosOrBuilderList() {
        if (typeProtosBuilder_ != null) {
          return typeProtosBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(typeProtos_);
        }
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Onnx.TypeProto.Builder addTypeProtosBuilder() {
        return internalGetTypeProtosFieldBuilder().addBuilder(
            Onnx.TypeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public Onnx.TypeProto.Builder addTypeProtosBuilder(
          int index) {
        return internalGetTypeProtosFieldBuilder().addBuilder(
            index, Onnx.TypeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * list of type protos
       * </pre>
       *
       * <code>repeated .TypeProto type_protos = 15;</code>
       */
      public java.util.List<Onnx.TypeProto.Builder> 
           getTypeProtosBuilderList() {
        return internalGetTypeProtosFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
          internalGetTypeProtosFieldBuilder() {
        if (typeProtosBuilder_ == null) {
          typeProtosBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                  typeProtos_,
                  ((bitField0_ & 0x00020000) != 0),
                  getParentForChildren(),
                  isClean());
          typeProtos_ = null;
        }
        return typeProtosBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:AttributeProto)
    }

    // @@protoc_insertion_point(class_scope:AttributeProto)
    private static final Onnx.AttributeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.AttributeProto();
    }

    public static Onnx.AttributeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AttributeProto>
        PARSER = new com.google.protobuf.AbstractParser<AttributeProto>() {
      @java.lang.Override
      public AttributeProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<AttributeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AttributeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.AttributeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValueInfoProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ValueInfoProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     * @return The type.
     */
    Onnx.TypeProto getType();
    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     */
    Onnx.TypeProtoOrBuilder getTypeOrBuilder();

    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Defines information on value, including the name, the type, and
   * the shape of the value.
   * </pre>
   *
   * Protobuf type {@code ValueInfoProto}
   */
  public static final class ValueInfoProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:ValueInfoProto)
      ValueInfoProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        ValueInfoProto.class.getName());
    }
    // Use ValueInfoProto.newBuilder() to construct.
    private ValueInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ValueInfoProto() {
      name_ = "";
      docString_ = "";
      metadataProps_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_ValueInfoProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_ValueInfoProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.ValueInfoProto.class, Onnx.ValueInfoProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private Onnx.TypeProto type_;
    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     * @return The type.
     */
    @java.lang.Override
    public Onnx.TypeProto getType() {
      return type_ == null ? Onnx.TypeProto.getDefaultInstance() : type_;
    }
    /**
     * <pre>
     * This field MUST be present in this version of the IR for
     * inputs and outputs of the top-level graph.
     * </pre>
     *
     * <code>optional .TypeProto type = 2;</code>
     */
    @java.lang.Override
    public Onnx.TypeProtoOrBuilder getTypeOrBuilder() {
      return type_ == null ? Onnx.TypeProto.getDefaultInstance() : type_;
    }

    public static final int DOC_STRING_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this value. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 3;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int METADATA_PROPS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getType());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, docString_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(4, metadataProps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getType());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, docString_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, metadataProps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.ValueInfoProto)) {
        return super.equals(obj);
      }
      Onnx.ValueInfoProto other = (Onnx.ValueInfoProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.ValueInfoProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ValueInfoProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ValueInfoProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ValueInfoProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ValueInfoProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ValueInfoProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ValueInfoProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ValueInfoProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.ValueInfoProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.ValueInfoProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.ValueInfoProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ValueInfoProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.ValueInfoProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Defines information on value, including the name, the type, and
     * the shape of the value.
     * </pre>
     *
     * Protobuf type {@code ValueInfoProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ValueInfoProto)
        Onnx.ValueInfoProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_ValueInfoProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_ValueInfoProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.ValueInfoProto.class, Onnx.ValueInfoProto.Builder.class);
      }

      // Construct using Onnx.ValueInfoProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetTypeFieldBuilder();
          internalGetMetadataPropsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        type_ = null;
        if (typeBuilder_ != null) {
          typeBuilder_.dispose();
          typeBuilder_ = null;
        }
        docString_ = "";
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_ValueInfoProto_descriptor;
      }

      @java.lang.Override
      public Onnx.ValueInfoProto getDefaultInstanceForType() {
        return Onnx.ValueInfoProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.ValueInfoProto build() {
        Onnx.ValueInfoProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.ValueInfoProto buildPartial() {
        Onnx.ValueInfoProto result = new Onnx.ValueInfoProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.ValueInfoProto result) {
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.ValueInfoProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.type_ = typeBuilder_ == null
              ? type_
              : typeBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.ValueInfoProto) {
          return mergeFrom((Onnx.ValueInfoProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.ValueInfoProto other) {
        if (other == Onnx.ValueInfoProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasType()) {
          mergeType(other.getType());
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000008);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    internalGetTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private Onnx.TypeProto type_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> typeBuilder_;
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       * @return The type.
       */
      public Onnx.TypeProto getType() {
        if (typeBuilder_ == null) {
          return type_ == null ? Onnx.TypeProto.getDefaultInstance() : type_;
        } else {
          return typeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Builder setType(Onnx.TypeProto value) {
        if (typeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
        } else {
          typeBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Builder setType(
          Onnx.TypeProto.Builder builderForValue) {
        if (typeBuilder_ == null) {
          type_ = builderForValue.build();
        } else {
          typeBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Builder mergeType(Onnx.TypeProto value) {
        if (typeBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            type_ != null &&
            type_ != Onnx.TypeProto.getDefaultInstance()) {
            getTypeBuilder().mergeFrom(value);
          } else {
            type_ = value;
          }
        } else {
          typeBuilder_.mergeFrom(value);
        }
        if (type_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        type_ = null;
        if (typeBuilder_ != null) {
          typeBuilder_.dispose();
          typeBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Onnx.TypeProto.Builder getTypeBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return internalGetTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      public Onnx.TypeProtoOrBuilder getTypeOrBuilder() {
        if (typeBuilder_ != null) {
          return typeBuilder_.getMessageOrBuilder();
        } else {
          return type_ == null ?
              Onnx.TypeProto.getDefaultInstance() : type_;
        }
      }
      /**
       * <pre>
       * This field MUST be present in this version of the IR for
       * inputs and outputs of the top-level graph.
       * </pre>
       *
       * <code>optional .TypeProto type = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
          internalGetTypeFieldBuilder() {
        if (typeBuilder_ == null) {
          typeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                  getType(),
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        return typeBuilder_;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this value. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 3;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 4;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:ValueInfoProto)
    }

    // @@protoc_insertion_point(class_scope:ValueInfoProto)
    private static final Onnx.ValueInfoProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.ValueInfoProto();
    }

    public static Onnx.ValueInfoProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValueInfoProto>
        PARSER = new com.google.protobuf.AbstractParser<ValueInfoProto>() {
      @java.lang.Override
      public ValueInfoProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ValueInfoProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValueInfoProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.ValueInfoProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:NodeProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @return A list containing the input.
     */
    java.util.List<java.lang.String>
        getInputList();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @return The count of input.
     */
    int getInputCount();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @param index The index of the element to return.
     * @return The input at the given index.
     */
    java.lang.String getInput(int index);
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the input at the given index.
     */
    com.google.protobuf.ByteString
        getInputBytes(int index);

    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @return A list containing the output.
     */
    java.util.List<java.lang.String>
        getOutputList();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @return The count of output.
     */
    int getOutputCount();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @param index The index of the element to return.
     * @return The output at the given index.
     */
    java.lang.String getOutput(int index);
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the output at the given index.
     */
    com.google.protobuf.ByteString
        getOutputBytes(int index);

    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return Whether the opType field is set.
     */
    boolean hasOpType();
    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return The opType.
     */
    java.lang.String getOpType();
    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return The bytes for opType.
     */
    com.google.protobuf.ByteString
        getOpTypeBytes();

    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return Whether the domain field is set.
     */
    boolean hasDomain();
    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return The domain.
     */
    java.lang.String getDomain();
    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return The bytes for domain.
     */
    com.google.protobuf.ByteString
        getDomainBytes();

    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return Whether the overload field is set.
     */
    boolean hasOverload();
    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return The overload.
     */
    java.lang.String getOverload();
    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return The bytes for overload.
     */
    com.google.protobuf.ByteString
        getOverloadBytes();

    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    java.util.List<Onnx.AttributeProto> 
        getAttributeList();
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    Onnx.AttributeProto getAttribute(int index);
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    int getAttributeCount();
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
        getAttributeOrBuilderList();
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    Onnx.AttributeProtoOrBuilder getAttributeOrBuilder(
        int index);

    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);

    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    java.util.List<Onnx.NodeDeviceConfigurationProto> 
        getDeviceConfigurationsList();
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    Onnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index);
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    int getDeviceConfigurationsCount();
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    java.util.List<? extends Onnx.NodeDeviceConfigurationProtoOrBuilder> 
        getDeviceConfigurationsOrBuilderList();
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    Onnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Nodes
   *
   * Computation graphs are made up of a DAG of nodes, which represent what is
   * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
   *
   * For example, it can be a node of type "Conv" that takes in an image, a filter
   * tensor and a bias tensor, and produces the convolved output.
   * </pre>
   *
   * Protobuf type {@code NodeProto}
   */
  public static final class NodeProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:NodeProto)
      NodeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        NodeProto.class.getName());
    }
    // Use NodeProto.newBuilder() to construct.
    private NodeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private NodeProto() {
      input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      name_ = "";
      opType_ = "";
      domain_ = "";
      overload_ = "";
      attribute_ = java.util.Collections.emptyList();
      docString_ = "";
      metadataProps_ = java.util.Collections.emptyList();
      deviceConfigurations_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_NodeProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_NodeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.NodeProto.class, Onnx.NodeProto.Builder.class);
    }

    private int bitField0_;
    public static final int INPUT_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList input_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @return A list containing the input.
     */
    public com.google.protobuf.ProtocolStringList
        getInputList() {
      return input_;
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @return The count of input.
     */
    public int getInputCount() {
      return input_.size();
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @param index The index of the element to return.
     * @return The input at the given index.
     */
    public java.lang.String getInput(int index) {
      return input_.get(index);
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string input = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the input at the given index.
     */
    public com.google.protobuf.ByteString
        getInputBytes(int index) {
      return input_.getByteString(index);
    }

    public static final int OUTPUT_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList output_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @return A list containing the output.
     */
    public com.google.protobuf.ProtocolStringList
        getOutputList() {
      return output_;
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @return The count of output.
     */
    public int getOutputCount() {
      return output_.size();
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @param index The index of the element to return.
     * @return The output at the given index.
     */
    public java.lang.String getOutput(int index) {
      return output_.get(index);
    }
    /**
     * <pre>
     * namespace Value
     * </pre>
     *
     * <code>repeated string output = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the output at the given index.
     */
    public com.google.protobuf.ByteString
        getOutputBytes(int index) {
      return output_.getByteString(index);
    }

    public static final int NAME_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * An optional identifier for this node in a graph.
     * This field MAY be absent in this version of the IR.
     * </pre>
     *
     * <code>optional string name = 3;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OP_TYPE_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object opType_ = "";
    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return Whether the opType field is set.
     */
    @java.lang.Override
    public boolean hasOpType() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return The opType.
     */
    @java.lang.Override
    public java.lang.String getOpType() {
      java.lang.Object ref = opType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          opType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The symbolic identifier of the Operator to execute.
     * </pre>
     *
     * <code>optional string op_type = 4;</code>
     * @return The bytes for opType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOpTypeBytes() {
      java.lang.Object ref = opType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        opType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DOMAIN_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private volatile java.lang.Object domain_ = "";
    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return Whether the domain field is set.
     */
    @java.lang.Override
    public boolean hasDomain() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return The domain.
     */
    @java.lang.Override
    public java.lang.String getDomain() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          domain_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The domain of the OperatorSet that specifies the operator named by op_type.
     * </pre>
     *
     * <code>optional string domain = 7;</code>
     * @return The bytes for domain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDomainBytes() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        domain_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OVERLOAD_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object overload_ = "";
    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return Whether the overload field is set.
     */
    @java.lang.Override
    public boolean hasOverload() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return The overload.
     */
    @java.lang.Override
    public java.lang.String getOverload() {
      java.lang.Object ref = overload_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          overload_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Overload identifier, used only to map this to a model-local function.
     * </pre>
     *
     * <code>optional string overload = 8;</code>
     * @return The bytes for overload.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOverloadBytes() {
      java.lang.Object ref = overload_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        overload_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ATTRIBUTE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.AttributeProto> attribute_;
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.AttributeProto> getAttributeList() {
      return attribute_;
    }
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
        getAttributeOrBuilderList() {
      return attribute_;
    }
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    @java.lang.Override
    public int getAttributeCount() {
      return attribute_.size();
    }
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    @java.lang.Override
    public Onnx.AttributeProto getAttribute(int index) {
      return attribute_.get(index);
    }
    /**
     * <pre>
     * Additional named attributes.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute = 5;</code>
     */
    @java.lang.Override
    public Onnx.AttributeProtoOrBuilder getAttributeOrBuilder(
        int index) {
      return attribute_.get(index);
    }

    public static final int DOC_STRING_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this node. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int METADATA_PROPS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    public static final int DEVICE_CONFIGURATIONS_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.NodeDeviceConfigurationProto> deviceConfigurations_;
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.NodeDeviceConfigurationProto> getDeviceConfigurationsList() {
      return deviceConfigurations_;
    }
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.NodeDeviceConfigurationProtoOrBuilder> 
        getDeviceConfigurationsOrBuilderList() {
      return deviceConfigurations_;
    }
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    @java.lang.Override
    public int getDeviceConfigurationsCount() {
      return deviceConfigurations_.size();
    }
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    @java.lang.Override
    public Onnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index) {
      return deviceConfigurations_.get(index);
    }
    /**
     * <pre>
     * Configuration of multi-device annotations.
     * </pre>
     *
     * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
     */
    @java.lang.Override
    public Onnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
        int index) {
      return deviceConfigurations_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < input_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, input_.getRaw(i));
      }
      for (int i = 0; i < output_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, output_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, opType_);
      }
      for (int i = 0; i < attribute_.size(); i++) {
        output.writeMessage(5, attribute_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, domain_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, overload_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(9, metadataProps_.get(i));
      }
      for (int i = 0; i < deviceConfigurations_.size(); i++) {
        output.writeMessage(10, deviceConfigurations_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < input_.size(); i++) {
          dataSize += computeStringSizeNoTag(input_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getInputList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < output_.size(); i++) {
          dataSize += computeStringSizeNoTag(output_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getOutputList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, opType_);
      }
      for (int i = 0; i < attribute_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, attribute_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(7, domain_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, overload_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, metadataProps_.get(i));
      }
      for (int i = 0; i < deviceConfigurations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, deviceConfigurations_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.NodeProto)) {
        return super.equals(obj);
      }
      Onnx.NodeProto other = (Onnx.NodeProto) obj;

      if (!getInputList()
          .equals(other.getInputList())) return false;
      if (!getOutputList()
          .equals(other.getOutputList())) return false;
      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasOpType() != other.hasOpType()) return false;
      if (hasOpType()) {
        if (!getOpType()
            .equals(other.getOpType())) return false;
      }
      if (hasDomain() != other.hasDomain()) return false;
      if (hasDomain()) {
        if (!getDomain()
            .equals(other.getDomain())) return false;
      }
      if (hasOverload() != other.hasOverload()) return false;
      if (hasOverload()) {
        if (!getOverload()
            .equals(other.getOverload())) return false;
      }
      if (!getAttributeList()
          .equals(other.getAttributeList())) return false;
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getDeviceConfigurationsList()
          .equals(other.getDeviceConfigurationsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInputCount() > 0) {
        hash = (37 * hash) + INPUT_FIELD_NUMBER;
        hash = (53 * hash) + getInputList().hashCode();
      }
      if (getOutputCount() > 0) {
        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getOutputList().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasOpType()) {
        hash = (37 * hash) + OP_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getOpType().hashCode();
      }
      if (hasDomain()) {
        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
        hash = (53 * hash) + getDomain().hashCode();
      }
      if (hasOverload()) {
        hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;
        hash = (53 * hash) + getOverload().hashCode();
      }
      if (getAttributeCount() > 0) {
        hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;
        hash = (53 * hash) + getAttributeList().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      if (getDeviceConfigurationsCount() > 0) {
        hash = (37 * hash) + DEVICE_CONFIGURATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceConfigurationsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.NodeProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.NodeProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.NodeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.NodeProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.NodeProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.NodeProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.NodeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Nodes
     *
     * Computation graphs are made up of a DAG of nodes, which represent what is
     * commonly called a "layer" or "pipeline stage" in machine learning frameworks.
     *
     * For example, it can be a node of type "Conv" that takes in an image, a filter
     * tensor and a bias tensor, and produces the convolved output.
     * </pre>
     *
     * Protobuf type {@code NodeProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:NodeProto)
        Onnx.NodeProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_NodeProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_NodeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.NodeProto.class, Onnx.NodeProto.Builder.class);
      }

      // Construct using Onnx.NodeProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        input_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        output_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        name_ = "";
        opType_ = "";
        domain_ = "";
        overload_ = "";
        if (attributeBuilder_ == null) {
          attribute_ = java.util.Collections.emptyList();
        } else {
          attribute_ = null;
          attributeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        docString_ = "";
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (deviceConfigurationsBuilder_ == null) {
          deviceConfigurations_ = java.util.Collections.emptyList();
        } else {
          deviceConfigurations_ = null;
          deviceConfigurationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_NodeProto_descriptor;
      }

      @java.lang.Override
      public Onnx.NodeProto getDefaultInstanceForType() {
        return Onnx.NodeProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.NodeProto build() {
        Onnx.NodeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.NodeProto buildPartial() {
        Onnx.NodeProto result = new Onnx.NodeProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.NodeProto result) {
        if (attributeBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            attribute_ = java.util.Collections.unmodifiableList(attribute_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.attribute_ = attribute_;
        } else {
          result.attribute_ = attributeBuilder_.build();
        }
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
        if (deviceConfigurationsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            deviceConfigurations_ = java.util.Collections.unmodifiableList(deviceConfigurations_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.deviceConfigurations_ = deviceConfigurations_;
        } else {
          result.deviceConfigurations_ = deviceConfigurationsBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.NodeProto result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          input_.makeImmutable();
          result.input_ = input_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          output_.makeImmutable();
          result.output_ = output_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.opType_ = opType_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.domain_ = domain_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.overload_ = overload_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.NodeProto) {
          return mergeFrom((Onnx.NodeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.NodeProto other) {
        if (other == Onnx.NodeProto.getDefaultInstance()) return this;
        if (!other.input_.isEmpty()) {
          if (input_.isEmpty()) {
            input_ = other.input_;
            bitField0_ |= 0x00000001;
          } else {
            ensureInputIsMutable();
            input_.addAll(other.input_);
          }
          onChanged();
        }
        if (!other.output_.isEmpty()) {
          if (output_.isEmpty()) {
            output_ = other.output_;
            bitField0_ |= 0x00000002;
          } else {
            ensureOutputIsMutable();
            output_.addAll(other.output_);
          }
          onChanged();
        }
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasOpType()) {
          opType_ = other.opType_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasDomain()) {
          domain_ = other.domain_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasOverload()) {
          overload_ = other.overload_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        if (attributeBuilder_ == null) {
          if (!other.attribute_.isEmpty()) {
            if (attribute_.isEmpty()) {
              attribute_ = other.attribute_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureAttributeIsMutable();
              attribute_.addAll(other.attribute_);
            }
            onChanged();
          }
        } else {
          if (!other.attribute_.isEmpty()) {
            if (attributeBuilder_.isEmpty()) {
              attributeBuilder_.dispose();
              attributeBuilder_ = null;
              attribute_ = other.attribute_;
              bitField0_ = (bitField0_ & ~0x00000040);
              attributeBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributeFieldBuilder() : null;
            } else {
              attributeBuilder_.addAllMessages(other.attribute_);
            }
          }
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000100);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        if (deviceConfigurationsBuilder_ == null) {
          if (!other.deviceConfigurations_.isEmpty()) {
            if (deviceConfigurations_.isEmpty()) {
              deviceConfigurations_ = other.deviceConfigurations_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureDeviceConfigurationsIsMutable();
              deviceConfigurations_.addAll(other.deviceConfigurations_);
            }
            onChanged();
          }
        } else {
          if (!other.deviceConfigurations_.isEmpty()) {
            if (deviceConfigurationsBuilder_.isEmpty()) {
              deviceConfigurationsBuilder_.dispose();
              deviceConfigurationsBuilder_ = null;
              deviceConfigurations_ = other.deviceConfigurations_;
              bitField0_ = (bitField0_ & ~0x00000200);
              deviceConfigurationsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetDeviceConfigurationsFieldBuilder() : null;
            } else {
              deviceConfigurationsBuilder_.addAllMessages(other.deviceConfigurations_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureInputIsMutable();
                input_.add(bs);
                break;
              } // case 10
              case 18: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureOutputIsMutable();
                output_.add(bs);
                break;
              } // case 18
              case 26: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                opType_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                Onnx.AttributeProto m =
                    input.readMessage(
                        Onnx.AttributeProto.parser(),
                        extensionRegistry);
                if (attributeBuilder_ == null) {
                  ensureAttributeIsMutable();
                  attribute_.add(m);
                } else {
                  attributeBuilder_.addMessage(m);
                }
                break;
              } // case 42
              case 50: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 50
              case 58: {
                domain_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 58
              case 66: {
                overload_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 66
              case 74: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 74
              case 82: {
                Onnx.NodeDeviceConfigurationProto m =
                    input.readMessage(
                        Onnx.NodeDeviceConfigurationProto.parser(),
                        extensionRegistry);
                if (deviceConfigurationsBuilder_ == null) {
                  ensureDeviceConfigurationsIsMutable();
                  deviceConfigurations_.add(m);
                } else {
                  deviceConfigurationsBuilder_.addMessage(m);
                }
                break;
              } // case 82
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureInputIsMutable() {
        if (!input_.isModifiable()) {
          input_ = new com.google.protobuf.LazyStringArrayList(input_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @return A list containing the input.
       */
      public com.google.protobuf.ProtocolStringList
          getInputList() {
        input_.makeImmutable();
        return input_;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @return The count of input.
       */
      public int getInputCount() {
        return input_.size();
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param index The index of the element to return.
       * @return The input at the given index.
       */
      public java.lang.String getInput(int index) {
        return input_.get(index);
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the input at the given index.
       */
      public com.google.protobuf.ByteString
          getInputBytes(int index) {
        return input_.getByteString(index);
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param index The index to set the value at.
       * @param value The input to set.
       * @return This builder for chaining.
       */
      public Builder setInput(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param value The input to add.
       * @return This builder for chaining.
       */
      public Builder addInput(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param values The input to add.
       * @return This builder for chaining.
       */
      public Builder addAllInput(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, input_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInput() {
        input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string input = 1;</code>
       * @param value The bytes of the input to add.
       * @return This builder for chaining.
       */
      public Builder addInputBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureOutputIsMutable() {
        if (!output_.isModifiable()) {
          output_ = new com.google.protobuf.LazyStringArrayList(output_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @return A list containing the output.
       */
      public com.google.protobuf.ProtocolStringList
          getOutputList() {
        output_.makeImmutable();
        return output_;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @return The count of output.
       */
      public int getOutputCount() {
        return output_.size();
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param index The index of the element to return.
       * @return The output at the given index.
       */
      public java.lang.String getOutput(int index) {
        return output_.get(index);
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the output at the given index.
       */
      public com.google.protobuf.ByteString
          getOutputBytes(int index) {
        return output_.getByteString(index);
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param index The index to set the value at.
       * @param value The output to set.
       * @return This builder for chaining.
       */
      public Builder setOutput(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param value The output to add.
       * @return This builder for chaining.
       */
      public Builder addOutput(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param values The output to add.
       * @return This builder for chaining.
       */
      public Builder addAllOutput(
          java.lang.Iterable<java.lang.String> values) {
        ensureOutputIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, output_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutput() {
        output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * namespace Value
       * </pre>
       *
       * <code>repeated string output = 2;</code>
       * @param value The bytes of the output to add.
       * @return This builder for chaining.
       */
      public Builder addOutputBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional identifier for this node in a graph.
       * This field MAY be absent in this version of the IR.
       * </pre>
       *
       * <code>optional string name = 3;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object opType_ = "";
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @return Whether the opType field is set.
       */
      public boolean hasOpType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @return The opType.
       */
      public java.lang.String getOpType() {
        java.lang.Object ref = opType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            opType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @return The bytes for opType.
       */
      public com.google.protobuf.ByteString
          getOpTypeBytes() {
        java.lang.Object ref = opType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          opType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @param value The opType to set.
       * @return This builder for chaining.
       */
      public Builder setOpType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        opType_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearOpType() {
        opType_ = getDefaultInstance().getOpType();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The symbolic identifier of the Operator to execute.
       * </pre>
       *
       * <code>optional string op_type = 4;</code>
       * @param value The bytes for opType to set.
       * @return This builder for chaining.
       */
      public Builder setOpTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        opType_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object domain_ = "";
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @return Whether the domain field is set.
       */
      public boolean hasDomain() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @return The domain.
       */
      public java.lang.String getDomain() {
        java.lang.Object ref = domain_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            domain_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @return The bytes for domain.
       */
      public com.google.protobuf.ByteString
          getDomainBytes() {
        java.lang.Object ref = domain_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          domain_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @param value The domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomain(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDomain() {
        domain_ = getDefaultInstance().getDomain();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain of the OperatorSet that specifies the operator named by op_type.
       * </pre>
       *
       * <code>optional string domain = 7;</code>
       * @param value The bytes for domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomainBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.lang.Object overload_ = "";
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @return Whether the overload field is set.
       */
      public boolean hasOverload() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @return The overload.
       */
      public java.lang.String getOverload() {
        java.lang.Object ref = overload_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            overload_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @return The bytes for overload.
       */
      public com.google.protobuf.ByteString
          getOverloadBytes() {
        java.lang.Object ref = overload_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          overload_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @param value The overload to set.
       * @return This builder for chaining.
       */
      public Builder setOverload(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        overload_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearOverload() {
        overload_ = getDefaultInstance().getOverload();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Overload identifier, used only to map this to a model-local function.
       * </pre>
       *
       * <code>optional string overload = 8;</code>
       * @param value The bytes for overload to set.
       * @return This builder for chaining.
       */
      public Builder setOverloadBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        overload_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.AttributeProto> attribute_ =
        java.util.Collections.emptyList();
      private void ensureAttributeIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          attribute_ = new java.util.ArrayList<Onnx.AttributeProto>(attribute_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder> attributeBuilder_;

      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public java.util.List<Onnx.AttributeProto> getAttributeList() {
        if (attributeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attribute_);
        } else {
          return attributeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public int getAttributeCount() {
        if (attributeBuilder_ == null) {
          return attribute_.size();
        } else {
          return attributeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Onnx.AttributeProto getAttribute(int index) {
        if (attributeBuilder_ == null) {
          return attribute_.get(index);
        } else {
          return attributeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder setAttribute(
          int index, Onnx.AttributeProto value) {
        if (attributeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeIsMutable();
          attribute_.set(index, value);
          onChanged();
        } else {
          attributeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder setAttribute(
          int index, Onnx.AttributeProto.Builder builderForValue) {
        if (attributeBuilder_ == null) {
          ensureAttributeIsMutable();
          attribute_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder addAttribute(Onnx.AttributeProto value) {
        if (attributeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeIsMutable();
          attribute_.add(value);
          onChanged();
        } else {
          attributeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder addAttribute(
          int index, Onnx.AttributeProto value) {
        if (attributeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeIsMutable();
          attribute_.add(index, value);
          onChanged();
        } else {
          attributeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder addAttribute(
          Onnx.AttributeProto.Builder builderForValue) {
        if (attributeBuilder_ == null) {
          ensureAttributeIsMutable();
          attribute_.add(builderForValue.build());
          onChanged();
        } else {
          attributeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder addAttribute(
          int index, Onnx.AttributeProto.Builder builderForValue) {
        if (attributeBuilder_ == null) {
          ensureAttributeIsMutable();
          attribute_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder addAllAttribute(
          java.lang.Iterable<? extends Onnx.AttributeProto> values) {
        if (attributeBuilder_ == null) {
          ensureAttributeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attribute_);
          onChanged();
        } else {
          attributeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder clearAttribute() {
        if (attributeBuilder_ == null) {
          attribute_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          attributeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Builder removeAttribute(int index) {
        if (attributeBuilder_ == null) {
          ensureAttributeIsMutable();
          attribute_.remove(index);
          onChanged();
        } else {
          attributeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Onnx.AttributeProto.Builder getAttributeBuilder(
          int index) {
        return internalGetAttributeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Onnx.AttributeProtoOrBuilder getAttributeOrBuilder(
          int index) {
        if (attributeBuilder_ == null) {
          return attribute_.get(index);  } else {
          return attributeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
           getAttributeOrBuilderList() {
        if (attributeBuilder_ != null) {
          return attributeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attribute_);
        }
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Onnx.AttributeProto.Builder addAttributeBuilder() {
        return internalGetAttributeFieldBuilder().addBuilder(
            Onnx.AttributeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public Onnx.AttributeProto.Builder addAttributeBuilder(
          int index) {
        return internalGetAttributeFieldBuilder().addBuilder(
            index, Onnx.AttributeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Additional named attributes.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute = 5;</code>
       */
      public java.util.List<Onnx.AttributeProto.Builder> 
           getAttributeBuilderList() {
        return internalGetAttributeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder> 
          internalGetAttributeFieldBuilder() {
        if (attributeBuilder_ == null) {
          attributeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder>(
                  attribute_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          attribute_ = null;
        }
        return attributeBuilder_;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this node. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 9;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      private java.util.List<Onnx.NodeDeviceConfigurationProto> deviceConfigurations_ =
        java.util.Collections.emptyList();
      private void ensureDeviceConfigurationsIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          deviceConfigurations_ = new java.util.ArrayList<Onnx.NodeDeviceConfigurationProto>(deviceConfigurations_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeDeviceConfigurationProto, Onnx.NodeDeviceConfigurationProto.Builder, Onnx.NodeDeviceConfigurationProtoOrBuilder> deviceConfigurationsBuilder_;

      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public java.util.List<Onnx.NodeDeviceConfigurationProto> getDeviceConfigurationsList() {
        if (deviceConfigurationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(deviceConfigurations_);
        } else {
          return deviceConfigurationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public int getDeviceConfigurationsCount() {
        if (deviceConfigurationsBuilder_ == null) {
          return deviceConfigurations_.size();
        } else {
          return deviceConfigurationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Onnx.NodeDeviceConfigurationProto getDeviceConfigurations(int index) {
        if (deviceConfigurationsBuilder_ == null) {
          return deviceConfigurations_.get(index);
        } else {
          return deviceConfigurationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder setDeviceConfigurations(
          int index, Onnx.NodeDeviceConfigurationProto value) {
        if (deviceConfigurationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.set(index, value);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder setDeviceConfigurations(
          int index, Onnx.NodeDeviceConfigurationProto.Builder builderForValue) {
        if (deviceConfigurationsBuilder_ == null) {
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.set(index, builderForValue.build());
          onChanged();
        } else {
          deviceConfigurationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder addDeviceConfigurations(Onnx.NodeDeviceConfigurationProto value) {
        if (deviceConfigurationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.add(value);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder addDeviceConfigurations(
          int index, Onnx.NodeDeviceConfigurationProto value) {
        if (deviceConfigurationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.add(index, value);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder addDeviceConfigurations(
          Onnx.NodeDeviceConfigurationProto.Builder builderForValue) {
        if (deviceConfigurationsBuilder_ == null) {
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.add(builderForValue.build());
          onChanged();
        } else {
          deviceConfigurationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder addDeviceConfigurations(
          int index, Onnx.NodeDeviceConfigurationProto.Builder builderForValue) {
        if (deviceConfigurationsBuilder_ == null) {
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.add(index, builderForValue.build());
          onChanged();
        } else {
          deviceConfigurationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder addAllDeviceConfigurations(
          java.lang.Iterable<? extends Onnx.NodeDeviceConfigurationProto> values) {
        if (deviceConfigurationsBuilder_ == null) {
          ensureDeviceConfigurationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, deviceConfigurations_);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder clearDeviceConfigurations() {
        if (deviceConfigurationsBuilder_ == null) {
          deviceConfigurations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Builder removeDeviceConfigurations(int index) {
        if (deviceConfigurationsBuilder_ == null) {
          ensureDeviceConfigurationsIsMutable();
          deviceConfigurations_.remove(index);
          onChanged();
        } else {
          deviceConfigurationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Onnx.NodeDeviceConfigurationProto.Builder getDeviceConfigurationsBuilder(
          int index) {
        return internalGetDeviceConfigurationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Onnx.NodeDeviceConfigurationProtoOrBuilder getDeviceConfigurationsOrBuilder(
          int index) {
        if (deviceConfigurationsBuilder_ == null) {
          return deviceConfigurations_.get(index);  } else {
          return deviceConfigurationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public java.util.List<? extends Onnx.NodeDeviceConfigurationProtoOrBuilder> 
           getDeviceConfigurationsOrBuilderList() {
        if (deviceConfigurationsBuilder_ != null) {
          return deviceConfigurationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(deviceConfigurations_);
        }
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Onnx.NodeDeviceConfigurationProto.Builder addDeviceConfigurationsBuilder() {
        return internalGetDeviceConfigurationsFieldBuilder().addBuilder(
            Onnx.NodeDeviceConfigurationProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public Onnx.NodeDeviceConfigurationProto.Builder addDeviceConfigurationsBuilder(
          int index) {
        return internalGetDeviceConfigurationsFieldBuilder().addBuilder(
            index, Onnx.NodeDeviceConfigurationProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Configuration of multi-device annotations.
       * </pre>
       *
       * <code>repeated .NodeDeviceConfigurationProto device_configurations = 10;</code>
       */
      public java.util.List<Onnx.NodeDeviceConfigurationProto.Builder> 
           getDeviceConfigurationsBuilderList() {
        return internalGetDeviceConfigurationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeDeviceConfigurationProto, Onnx.NodeDeviceConfigurationProto.Builder, Onnx.NodeDeviceConfigurationProtoOrBuilder> 
          internalGetDeviceConfigurationsFieldBuilder() {
        if (deviceConfigurationsBuilder_ == null) {
          deviceConfigurationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.NodeDeviceConfigurationProto, Onnx.NodeDeviceConfigurationProto.Builder, Onnx.NodeDeviceConfigurationProtoOrBuilder>(
                  deviceConfigurations_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          deviceConfigurations_ = null;
        }
        return deviceConfigurationsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:NodeProto)
    }

    // @@protoc_insertion_point(class_scope:NodeProto)
    private static final Onnx.NodeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.NodeProto();
    }

    public static Onnx.NodeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeProto>
        PARSER = new com.google.protobuf.AbstractParser<NodeProto>() {
      @java.lang.Override
      public NodeProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<NodeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.NodeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface IntIntListEntryProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:IntIntListEntryProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional int64 key = 1;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional int64 key = 1;</code>
     * @return The key.
     */
    long getKey();

    /**
     * <code>repeated int64 value = 2;</code>
     * @return A list containing the value.
     */
    java.util.List<java.lang.Long> getValueList();
    /**
     * <code>repeated int64 value = 2;</code>
     * @return The count of value.
     */
    int getValueCount();
    /**
     * <code>repeated int64 value = 2;</code>
     * @param index The index of the element to return.
     * @return The value at the given index.
     */
    long getValue(int index);
  }
  /**
   * <pre>
   * IntIntListEntryProto follows the pattern for cross-proto-version maps.
   * See https://developers.google.com/protocol-buffers/docs/proto3#maps
   * </pre>
   *
   * Protobuf type {@code IntIntListEntryProto}
   */
  public static final class IntIntListEntryProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:IntIntListEntryProto)
      IntIntListEntryProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        IntIntListEntryProto.class.getName());
    }
    // Use IntIntListEntryProto.newBuilder() to construct.
    private IntIntListEntryProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private IntIntListEntryProto() {
      value_ = emptyLongList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_IntIntListEntryProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_IntIntListEntryProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.IntIntListEntryProto.class, Onnx.IntIntListEntryProto.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    private long key_ = 0L;
    /**
     * <code>optional int64 key = 1;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional int64 key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public long getKey() {
      return key_;
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList value_ =
        emptyLongList();
    /**
     * <code>repeated int64 value = 2;</code>
     * @return A list containing the value.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getValueList() {
      return value_;
    }
    /**
     * <code>repeated int64 value = 2;</code>
     * @return The count of value.
     */
    public int getValueCount() {
      return value_.size();
    }
    /**
     * <code>repeated int64 value = 2;</code>
     * @param index The index of the element to return.
     * @return The value at the given index.
     */
    public long getValue(int index) {
      return value_.getLong(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, key_);
      }
      for (int i = 0; i < value_.size(); i++) {
        output.writeInt64(2, value_.getLong(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, key_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < value_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(value_.getLong(i));
        }
        size += dataSize;
        size += 1 * getValueList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.IntIntListEntryProto)) {
        return super.equals(obj);
      }
      Onnx.IntIntListEntryProto other = (Onnx.IntIntListEntryProto) obj;

      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (getKey()
            != other.getKey()) return false;
      }
      if (!getValueList()
          .equals(other.getValueList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getKey());
      }
      if (getValueCount() > 0) {
        hash = (37 * hash) + VALUE_FIELD_NUMBER;
        hash = (53 * hash) + getValueList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.IntIntListEntryProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.IntIntListEntryProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.IntIntListEntryProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.IntIntListEntryProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.IntIntListEntryProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.IntIntListEntryProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.IntIntListEntryProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * IntIntListEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code IntIntListEntryProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:IntIntListEntryProto)
        Onnx.IntIntListEntryProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_IntIntListEntryProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_IntIntListEntryProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.IntIntListEntryProto.class, Onnx.IntIntListEntryProto.Builder.class);
      }

      // Construct using Onnx.IntIntListEntryProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = 0L;
        value_ = emptyLongList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_IntIntListEntryProto_descriptor;
      }

      @java.lang.Override
      public Onnx.IntIntListEntryProto getDefaultInstanceForType() {
        return Onnx.IntIntListEntryProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.IntIntListEntryProto build() {
        Onnx.IntIntListEntryProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.IntIntListEntryProto buildPartial() {
        Onnx.IntIntListEntryProto result = new Onnx.IntIntListEntryProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.IntIntListEntryProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          value_.makeImmutable();
          result.value_ = value_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.IntIntListEntryProto) {
          return mergeFrom((Onnx.IntIntListEntryProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.IntIntListEntryProto other) {
        if (other == Onnx.IntIntListEntryProto.getDefaultInstance()) return this;
        if (other.hasKey()) {
          setKey(other.getKey());
        }
        if (!other.value_.isEmpty()) {
          if (value_.isEmpty()) {
            value_ = other.value_;
            value_.makeImmutable();
            bitField0_ |= 0x00000002;
          } else {
            ensureValueIsMutable();
            value_.addAll(other.value_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                key_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                long v = input.readInt64();
                ensureValueIsMutable();
                value_.addLong(v);
                break;
              } // case 16
              case 18: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureValueIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  value_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long key_ ;
      /**
       * <code>optional int64 key = 1;</code>
       * @return Whether the key field is set.
       */
      @java.lang.Override
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional int64 key = 1;</code>
       * @return The key.
       */
      @java.lang.Override
      public long getKey() {
        return key_;
      }
      /**
       * <code>optional int64 key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(long value) {

        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList value_ = emptyLongList();
      private void ensureValueIsMutable() {
        if (!value_.isModifiable()) {
          value_ = makeMutableCopy(value_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @return A list containing the value.
       */
      public java.util.List<java.lang.Long>
          getValueList() {
        value_.makeImmutable();
        return value_;
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @return The count of value.
       */
      public int getValueCount() {
        return value_.size();
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @param index The index of the element to return.
       * @return The value at the given index.
       */
      public long getValue(int index) {
        return value_.getLong(index);
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @param index The index to set the value at.
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          int index, long value) {

        ensureValueIsMutable();
        value_.setLong(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @param value The value to add.
       * @return This builder for chaining.
       */
      public Builder addValue(long value) {

        ensureValueIsMutable();
        value_.addLong(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @param values The value to add.
       * @return This builder for chaining.
       */
      public Builder addAllValue(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureValueIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, value_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>repeated int64 value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:IntIntListEntryProto)
    }

    // @@protoc_insertion_point(class_scope:IntIntListEntryProto)
    private static final Onnx.IntIntListEntryProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.IntIntListEntryProto();
    }

    public static Onnx.IntIntListEntryProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<IntIntListEntryProto>
        PARSER = new com.google.protobuf.AbstractParser<IntIntListEntryProto>() {
      @java.lang.Override
      public IntIntListEntryProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<IntIntListEntryProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<IntIntListEntryProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.IntIntListEntryProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeDeviceConfigurationProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:NodeDeviceConfigurationProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return Whether the configurationId field is set.
     */
    boolean hasConfigurationId();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return The configurationId.
     */
    java.lang.String getConfigurationId();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return The bytes for configurationId.
     */
    com.google.protobuf.ByteString
        getConfigurationIdBytes();

    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    java.util.List<Onnx.ShardingSpecProto> 
        getShardingSpecList();
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    Onnx.ShardingSpecProto getShardingSpec(int index);
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    int getShardingSpecCount();
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    java.util.List<? extends Onnx.ShardingSpecProtoOrBuilder> 
        getShardingSpecOrBuilderList();
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    Onnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
        int index);

    /**
     * <pre>
     * Pipeline stage of this node.
     * </pre>
     *
     * <code>optional int32 pipeline_stage = 3;</code>
     * @return Whether the pipelineStage field is set.
     */
    boolean hasPipelineStage();
    /**
     * <pre>
     * Pipeline stage of this node.
     * </pre>
     *
     * <code>optional int32 pipeline_stage = 3;</code>
     * @return The pipelineStage.
     */
    int getPipelineStage();
  }
  /**
   * <pre>
   * Multi-device configuration proto for NodeProto.
   * </pre>
   *
   * Protobuf type {@code NodeDeviceConfigurationProto}
   */
  public static final class NodeDeviceConfigurationProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:NodeDeviceConfigurationProto)
      NodeDeviceConfigurationProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        NodeDeviceConfigurationProto.class.getName());
    }
    // Use NodeDeviceConfigurationProto.newBuilder() to construct.
    private NodeDeviceConfigurationProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private NodeDeviceConfigurationProto() {
      configurationId_ = "";
      shardingSpec_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.NodeDeviceConfigurationProto.class, Onnx.NodeDeviceConfigurationProto.Builder.class);
    }

    private int bitField0_;
    public static final int CONFIGURATION_ID_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object configurationId_ = "";
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return Whether the configurationId field is set.
     */
    @java.lang.Override
    public boolean hasConfigurationId() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return The configurationId.
     */
    @java.lang.Override
    public java.lang.String getConfigurationId() {
      java.lang.Object ref = configurationId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          configurationId_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
     * </pre>
     *
     * <code>optional string configuration_id = 1;</code>
     * @return The bytes for configurationId.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getConfigurationIdBytes() {
      java.lang.Object ref = configurationId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        configurationId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SHARDING_SPEC_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ShardingSpecProto> shardingSpec_;
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ShardingSpecProto> getShardingSpecList() {
      return shardingSpec_;
    }
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ShardingSpecProtoOrBuilder> 
        getShardingSpecOrBuilderList() {
      return shardingSpec_;
    }
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    @java.lang.Override
    public int getShardingSpecCount() {
      return shardingSpec_.size();
    }
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    @java.lang.Override
    public Onnx.ShardingSpecProto getShardingSpec(int index) {
      return shardingSpec_.get(index);
    }
    /**
     * <pre>
     * Sharding spec for the node.
     * </pre>
     *
     * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
     */
    @java.lang.Override
    public Onnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
        int index) {
      return shardingSpec_.get(index);
    }

    public static final int PIPELINE_STAGE_FIELD_NUMBER = 3;
    private int pipelineStage_ = 0;
    /**
     * <pre>
     * Pipeline stage of this node.
     * </pre>
     *
     * <code>optional int32 pipeline_stage = 3;</code>
     * @return Whether the pipelineStage field is set.
     */
    @java.lang.Override
    public boolean hasPipelineStage() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Pipeline stage of this node.
     * </pre>
     *
     * <code>optional int32 pipeline_stage = 3;</code>
     * @return The pipelineStage.
     */
    @java.lang.Override
    public int getPipelineStage() {
      return pipelineStage_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, configurationId_);
      }
      for (int i = 0; i < shardingSpec_.size(); i++) {
        output.writeMessage(2, shardingSpec_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(3, pipelineStage_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, configurationId_);
      }
      for (int i = 0; i < shardingSpec_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, shardingSpec_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, pipelineStage_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.NodeDeviceConfigurationProto)) {
        return super.equals(obj);
      }
      Onnx.NodeDeviceConfigurationProto other = (Onnx.NodeDeviceConfigurationProto) obj;

      if (hasConfigurationId() != other.hasConfigurationId()) return false;
      if (hasConfigurationId()) {
        if (!getConfigurationId()
            .equals(other.getConfigurationId())) return false;
      }
      if (!getShardingSpecList()
          .equals(other.getShardingSpecList())) return false;
      if (hasPipelineStage() != other.hasPipelineStage()) return false;
      if (hasPipelineStage()) {
        if (getPipelineStage()
            != other.getPipelineStage()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfigurationId()) {
        hash = (37 * hash) + CONFIGURATION_ID_FIELD_NUMBER;
        hash = (53 * hash) + getConfigurationId().hashCode();
      }
      if (getShardingSpecCount() > 0) {
        hash = (37 * hash) + SHARDING_SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getShardingSpecList().hashCode();
      }
      if (hasPipelineStage()) {
        hash = (37 * hash) + PIPELINE_STAGE_FIELD_NUMBER;
        hash = (53 * hash) + getPipelineStage();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.NodeDeviceConfigurationProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.NodeDeviceConfigurationProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.NodeDeviceConfigurationProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.NodeDeviceConfigurationProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Multi-device configuration proto for NodeProto.
     * </pre>
     *
     * Protobuf type {@code NodeDeviceConfigurationProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:NodeDeviceConfigurationProto)
        Onnx.NodeDeviceConfigurationProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.NodeDeviceConfigurationProto.class, Onnx.NodeDeviceConfigurationProto.Builder.class);
      }

      // Construct using Onnx.NodeDeviceConfigurationProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        configurationId_ = "";
        if (shardingSpecBuilder_ == null) {
          shardingSpec_ = java.util.Collections.emptyList();
        } else {
          shardingSpec_ = null;
          shardingSpecBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        pipelineStage_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
      }

      @java.lang.Override
      public Onnx.NodeDeviceConfigurationProto getDefaultInstanceForType() {
        return Onnx.NodeDeviceConfigurationProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.NodeDeviceConfigurationProto build() {
        Onnx.NodeDeviceConfigurationProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.NodeDeviceConfigurationProto buildPartial() {
        Onnx.NodeDeviceConfigurationProto result = new Onnx.NodeDeviceConfigurationProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.NodeDeviceConfigurationProto result) {
        if (shardingSpecBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            shardingSpec_ = java.util.Collections.unmodifiableList(shardingSpec_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.shardingSpec_ = shardingSpec_;
        } else {
          result.shardingSpec_ = shardingSpecBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.NodeDeviceConfigurationProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.configurationId_ = configurationId_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.pipelineStage_ = pipelineStage_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.NodeDeviceConfigurationProto) {
          return mergeFrom((Onnx.NodeDeviceConfigurationProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.NodeDeviceConfigurationProto other) {
        if (other == Onnx.NodeDeviceConfigurationProto.getDefaultInstance()) return this;
        if (other.hasConfigurationId()) {
          configurationId_ = other.configurationId_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (shardingSpecBuilder_ == null) {
          if (!other.shardingSpec_.isEmpty()) {
            if (shardingSpec_.isEmpty()) {
              shardingSpec_ = other.shardingSpec_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureShardingSpecIsMutable();
              shardingSpec_.addAll(other.shardingSpec_);
            }
            onChanged();
          }
        } else {
          if (!other.shardingSpec_.isEmpty()) {
            if (shardingSpecBuilder_.isEmpty()) {
              shardingSpecBuilder_.dispose();
              shardingSpecBuilder_ = null;
              shardingSpec_ = other.shardingSpec_;
              bitField0_ = (bitField0_ & ~0x00000002);
              shardingSpecBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetShardingSpecFieldBuilder() : null;
            } else {
              shardingSpecBuilder_.addAllMessages(other.shardingSpec_);
            }
          }
        }
        if (other.hasPipelineStage()) {
          setPipelineStage(other.getPipelineStage());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                configurationId_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                Onnx.ShardingSpecProto m =
                    input.readMessage(
                        Onnx.ShardingSpecProto.parser(),
                        extensionRegistry);
                if (shardingSpecBuilder_ == null) {
                  ensureShardingSpecIsMutable();
                  shardingSpec_.add(m);
                } else {
                  shardingSpecBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 24: {
                pipelineStage_ = input.readInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object configurationId_ = "";
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @return Whether the configurationId field is set.
       */
      public boolean hasConfigurationId() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @return The configurationId.
       */
      public java.lang.String getConfigurationId() {
        java.lang.Object ref = configurationId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            configurationId_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @return The bytes for configurationId.
       */
      public com.google.protobuf.ByteString
          getConfigurationIdBytes() {
        java.lang.Object ref = configurationId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          configurationId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @param value The configurationId to set.
       * @return This builder for chaining.
       */
      public Builder setConfigurationId(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        configurationId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfigurationId() {
        configurationId_ = getDefaultInstance().getConfigurationId();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * ID of the configuration. MUST match the name of a DeviceConfigurationProto.
       * </pre>
       *
       * <code>optional string configuration_id = 1;</code>
       * @param value The bytes for configurationId to set.
       * @return This builder for chaining.
       */
      public Builder setConfigurationIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        configurationId_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.ShardingSpecProto> shardingSpec_ =
        java.util.Collections.emptyList();
      private void ensureShardingSpecIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          shardingSpec_ = new java.util.ArrayList<Onnx.ShardingSpecProto>(shardingSpec_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ShardingSpecProto, Onnx.ShardingSpecProto.Builder, Onnx.ShardingSpecProtoOrBuilder> shardingSpecBuilder_;

      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public java.util.List<Onnx.ShardingSpecProto> getShardingSpecList() {
        if (shardingSpecBuilder_ == null) {
          return java.util.Collections.unmodifiableList(shardingSpec_);
        } else {
          return shardingSpecBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public int getShardingSpecCount() {
        if (shardingSpecBuilder_ == null) {
          return shardingSpec_.size();
        } else {
          return shardingSpecBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Onnx.ShardingSpecProto getShardingSpec(int index) {
        if (shardingSpecBuilder_ == null) {
          return shardingSpec_.get(index);
        } else {
          return shardingSpecBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder setShardingSpec(
          int index, Onnx.ShardingSpecProto value) {
        if (shardingSpecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardingSpecIsMutable();
          shardingSpec_.set(index, value);
          onChanged();
        } else {
          shardingSpecBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder setShardingSpec(
          int index, Onnx.ShardingSpecProto.Builder builderForValue) {
        if (shardingSpecBuilder_ == null) {
          ensureShardingSpecIsMutable();
          shardingSpec_.set(index, builderForValue.build());
          onChanged();
        } else {
          shardingSpecBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder addShardingSpec(Onnx.ShardingSpecProto value) {
        if (shardingSpecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardingSpecIsMutable();
          shardingSpec_.add(value);
          onChanged();
        } else {
          shardingSpecBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder addShardingSpec(
          int index, Onnx.ShardingSpecProto value) {
        if (shardingSpecBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardingSpecIsMutable();
          shardingSpec_.add(index, value);
          onChanged();
        } else {
          shardingSpecBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder addShardingSpec(
          Onnx.ShardingSpecProto.Builder builderForValue) {
        if (shardingSpecBuilder_ == null) {
          ensureShardingSpecIsMutable();
          shardingSpec_.add(builderForValue.build());
          onChanged();
        } else {
          shardingSpecBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder addShardingSpec(
          int index, Onnx.ShardingSpecProto.Builder builderForValue) {
        if (shardingSpecBuilder_ == null) {
          ensureShardingSpecIsMutable();
          shardingSpec_.add(index, builderForValue.build());
          onChanged();
        } else {
          shardingSpecBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder addAllShardingSpec(
          java.lang.Iterable<? extends Onnx.ShardingSpecProto> values) {
        if (shardingSpecBuilder_ == null) {
          ensureShardingSpecIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, shardingSpec_);
          onChanged();
        } else {
          shardingSpecBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder clearShardingSpec() {
        if (shardingSpecBuilder_ == null) {
          shardingSpec_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          shardingSpecBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Builder removeShardingSpec(int index) {
        if (shardingSpecBuilder_ == null) {
          ensureShardingSpecIsMutable();
          shardingSpec_.remove(index);
          onChanged();
        } else {
          shardingSpecBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Onnx.ShardingSpecProto.Builder getShardingSpecBuilder(
          int index) {
        return internalGetShardingSpecFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Onnx.ShardingSpecProtoOrBuilder getShardingSpecOrBuilder(
          int index) {
        if (shardingSpecBuilder_ == null) {
          return shardingSpec_.get(index);  } else {
          return shardingSpecBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public java.util.List<? extends Onnx.ShardingSpecProtoOrBuilder> 
           getShardingSpecOrBuilderList() {
        if (shardingSpecBuilder_ != null) {
          return shardingSpecBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(shardingSpec_);
        }
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Onnx.ShardingSpecProto.Builder addShardingSpecBuilder() {
        return internalGetShardingSpecFieldBuilder().addBuilder(
            Onnx.ShardingSpecProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public Onnx.ShardingSpecProto.Builder addShardingSpecBuilder(
          int index) {
        return internalGetShardingSpecFieldBuilder().addBuilder(
            index, Onnx.ShardingSpecProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Sharding spec for the node.
       * </pre>
       *
       * <code>repeated .ShardingSpecProto sharding_spec = 2;</code>
       */
      public java.util.List<Onnx.ShardingSpecProto.Builder> 
           getShardingSpecBuilderList() {
        return internalGetShardingSpecFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ShardingSpecProto, Onnx.ShardingSpecProto.Builder, Onnx.ShardingSpecProtoOrBuilder> 
          internalGetShardingSpecFieldBuilder() {
        if (shardingSpecBuilder_ == null) {
          shardingSpecBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ShardingSpecProto, Onnx.ShardingSpecProto.Builder, Onnx.ShardingSpecProtoOrBuilder>(
                  shardingSpec_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          shardingSpec_ = null;
        }
        return shardingSpecBuilder_;
      }

      private int pipelineStage_ ;
      /**
       * <pre>
       * Pipeline stage of this node.
       * </pre>
       *
       * <code>optional int32 pipeline_stage = 3;</code>
       * @return Whether the pipelineStage field is set.
       */
      @java.lang.Override
      public boolean hasPipelineStage() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Pipeline stage of this node.
       * </pre>
       *
       * <code>optional int32 pipeline_stage = 3;</code>
       * @return The pipelineStage.
       */
      @java.lang.Override
      public int getPipelineStage() {
        return pipelineStage_;
      }
      /**
       * <pre>
       * Pipeline stage of this node.
       * </pre>
       *
       * <code>optional int32 pipeline_stage = 3;</code>
       * @param value The pipelineStage to set.
       * @return This builder for chaining.
       */
      public Builder setPipelineStage(int value) {

        pipelineStage_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Pipeline stage of this node.
       * </pre>
       *
       * <code>optional int32 pipeline_stage = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPipelineStage() {
        bitField0_ = (bitField0_ & ~0x00000004);
        pipelineStage_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:NodeDeviceConfigurationProto)
    }

    // @@protoc_insertion_point(class_scope:NodeDeviceConfigurationProto)
    private static final Onnx.NodeDeviceConfigurationProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.NodeDeviceConfigurationProto();
    }

    public static Onnx.NodeDeviceConfigurationProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeDeviceConfigurationProto>
        PARSER = new com.google.protobuf.AbstractParser<NodeDeviceConfigurationProto>() {
      @java.lang.Override
      public NodeDeviceConfigurationProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<NodeDeviceConfigurationProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeDeviceConfigurationProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.NodeDeviceConfigurationProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ShardingSpecProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ShardingSpecProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return Whether the tensorName field is set.
     */
    boolean hasTensorName();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return The tensorName.
     */
    java.lang.String getTensorName();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return The bytes for tensorName.
     */
    com.google.protobuf.ByteString
        getTensorNameBytes();

    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @return A list containing the device.
     */
    java.util.List<java.lang.Long> getDeviceList();
    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @return The count of device.
     */
    int getDeviceCount();
    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @param index The index of the element to return.
     * @return The device at the given index.
     */
    long getDevice(int index);

    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    java.util.List<Onnx.IntIntListEntryProto> 
        getIndexToDeviceGroupMapList();
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    Onnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index);
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    int getIndexToDeviceGroupMapCount();
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    java.util.List<? extends Onnx.IntIntListEntryProtoOrBuilder> 
        getIndexToDeviceGroupMapOrBuilderList();
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    Onnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
        int index);

    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    java.util.List<Onnx.ShardedDimProto> 
        getShardedDimList();
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    Onnx.ShardedDimProto getShardedDim(int index);
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    int getShardedDimCount();
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    java.util.List<? extends Onnx.ShardedDimProtoOrBuilder> 
        getShardedDimOrBuilderList();
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    Onnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ShardingSpecProto: This describes the sharding spec for a specific
   * input or output tensor of a node.
   * </pre>
   *
   * Protobuf type {@code ShardingSpecProto}
   */
  public static final class ShardingSpecProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:ShardingSpecProto)
      ShardingSpecProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        ShardingSpecProto.class.getName());
    }
    // Use ShardingSpecProto.newBuilder() to construct.
    private ShardingSpecProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ShardingSpecProto() {
      tensorName_ = "";
      device_ = emptyLongList();
      indexToDeviceGroupMap_ = java.util.Collections.emptyList();
      shardedDim_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_ShardingSpecProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_ShardingSpecProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.ShardingSpecProto.class, Onnx.ShardingSpecProto.Builder.class);
    }

    private int bitField0_;
    public static final int TENSOR_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object tensorName_ = "";
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return Whether the tensorName field is set.
     */
    @java.lang.Override
    public boolean hasTensorName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return The tensorName.
     */
    @java.lang.Override
    public java.lang.String getTensorName() {
      java.lang.Object ref = tensorName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          tensorName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Identifies the input or output of the node that is being sharded.
     * Required to match a name specified in the node's input or output list of ValueInfoProtos.
     * It is called `logical tensor` in subsequent descriptions.
     * </pre>
     *
     * <code>optional string tensor_name = 1;</code>
     * @return The bytes for tensorName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTensorNameBytes() {
      java.lang.Object ref = tensorName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tensorName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEVICE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList device_ =
        emptyLongList();
    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @return A list containing the device.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getDeviceList() {
      return device_;
    }
    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @return The count of device.
     */
    public int getDeviceCount() {
      return device_.size();
    }
    /**
     * <pre>
     * The following is the list of devices across which the logical
     * tensor is sharded or replicated.
     * </pre>
     *
     * <code>repeated int64 device = 2;</code>
     * @param index The index of the element to return.
     * @return The device at the given index.
     */
    public long getDevice(int index) {
      return device_.getLong(index);
    }

    public static final int INDEX_TO_DEVICE_GROUP_MAP_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.IntIntListEntryProto> indexToDeviceGroupMap_;
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.IntIntListEntryProto> getIndexToDeviceGroupMapList() {
      return indexToDeviceGroupMap_;
    }
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.IntIntListEntryProtoOrBuilder> 
        getIndexToDeviceGroupMapOrBuilderList() {
      return indexToDeviceGroupMap_;
    }
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    @java.lang.Override
    public int getIndexToDeviceGroupMapCount() {
      return indexToDeviceGroupMap_.size();
    }
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    @java.lang.Override
    public Onnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index) {
      return indexToDeviceGroupMap_.get(index);
    }
    /**
     * <pre>
     * Each element v in above field devices may represent either a
     * device or a set of devices (when we want the same shard/tensor
     * to be replicated across a subset of devices), as indicated by
     * the following optional map. If the map contains an entry for v,
     * then v represents a device group, and the map indicates the set
     * of devices in that group.
     * </pre>
     *
     * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
     */
    @java.lang.Override
    public Onnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
        int index) {
      return indexToDeviceGroupMap_.get(index);
    }

    public static final int SHARDED_DIM_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ShardedDimProto> shardedDim_;
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ShardedDimProto> getShardedDimList() {
      return shardedDim_;
    }
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ShardedDimProtoOrBuilder> 
        getShardedDimOrBuilderList() {
      return shardedDim_;
    }
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    @java.lang.Override
    public int getShardedDimCount() {
      return shardedDim_.size();
    }
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    @java.lang.Override
    public Onnx.ShardedDimProto getShardedDim(int index) {
      return shardedDim_.get(index);
    }
    /**
     * <pre>
     * The following is the sharded-shape of the tensor, consisting of
     * the sharding-spec for each axis of the tensor.
     * </pre>
     *
     * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
     */
    @java.lang.Override
    public Onnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
        int index) {
      return shardedDim_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, tensorName_);
      }
      for (int i = 0; i < device_.size(); i++) {
        output.writeInt64(2, device_.getLong(i));
      }
      for (int i = 0; i < indexToDeviceGroupMap_.size(); i++) {
        output.writeMessage(3, indexToDeviceGroupMap_.get(i));
      }
      for (int i = 0; i < shardedDim_.size(); i++) {
        output.writeMessage(4, shardedDim_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tensorName_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < device_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(device_.getLong(i));
        }
        size += dataSize;
        size += 1 * getDeviceList().size();
      }
      for (int i = 0; i < indexToDeviceGroupMap_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, indexToDeviceGroupMap_.get(i));
      }
      for (int i = 0; i < shardedDim_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, shardedDim_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.ShardingSpecProto)) {
        return super.equals(obj);
      }
      Onnx.ShardingSpecProto other = (Onnx.ShardingSpecProto) obj;

      if (hasTensorName() != other.hasTensorName()) return false;
      if (hasTensorName()) {
        if (!getTensorName()
            .equals(other.getTensorName())) return false;
      }
      if (!getDeviceList()
          .equals(other.getDeviceList())) return false;
      if (!getIndexToDeviceGroupMapList()
          .equals(other.getIndexToDeviceGroupMapList())) return false;
      if (!getShardedDimList()
          .equals(other.getShardedDimList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTensorName()) {
        hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getTensorName().hashCode();
      }
      if (getDeviceCount() > 0) {
        hash = (37 * hash) + DEVICE_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceList().hashCode();
      }
      if (getIndexToDeviceGroupMapCount() > 0) {
        hash = (37 * hash) + INDEX_TO_DEVICE_GROUP_MAP_FIELD_NUMBER;
        hash = (53 * hash) + getIndexToDeviceGroupMapList().hashCode();
      }
      if (getShardedDimCount() > 0) {
        hash = (37 * hash) + SHARDED_DIM_FIELD_NUMBER;
        hash = (53 * hash) + getShardedDimList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.ShardingSpecProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardingSpecProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardingSpecProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.ShardingSpecProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.ShardingSpecProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ShardingSpecProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.ShardingSpecProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ShardingSpecProto: This describes the sharding spec for a specific
     * input or output tensor of a node.
     * </pre>
     *
     * Protobuf type {@code ShardingSpecProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ShardingSpecProto)
        Onnx.ShardingSpecProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_ShardingSpecProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_ShardingSpecProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.ShardingSpecProto.class, Onnx.ShardingSpecProto.Builder.class);
      }

      // Construct using Onnx.ShardingSpecProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        tensorName_ = "";
        device_ = emptyLongList();
        if (indexToDeviceGroupMapBuilder_ == null) {
          indexToDeviceGroupMap_ = java.util.Collections.emptyList();
        } else {
          indexToDeviceGroupMap_ = null;
          indexToDeviceGroupMapBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (shardedDimBuilder_ == null) {
          shardedDim_ = java.util.Collections.emptyList();
        } else {
          shardedDim_ = null;
          shardedDimBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_ShardingSpecProto_descriptor;
      }

      @java.lang.Override
      public Onnx.ShardingSpecProto getDefaultInstanceForType() {
        return Onnx.ShardingSpecProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.ShardingSpecProto build() {
        Onnx.ShardingSpecProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.ShardingSpecProto buildPartial() {
        Onnx.ShardingSpecProto result = new Onnx.ShardingSpecProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.ShardingSpecProto result) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            indexToDeviceGroupMap_ = java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.indexToDeviceGroupMap_ = indexToDeviceGroupMap_;
        } else {
          result.indexToDeviceGroupMap_ = indexToDeviceGroupMapBuilder_.build();
        }
        if (shardedDimBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            shardedDim_ = java.util.Collections.unmodifiableList(shardedDim_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.shardedDim_ = shardedDim_;
        } else {
          result.shardedDim_ = shardedDimBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.ShardingSpecProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.tensorName_ = tensorName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          device_.makeImmutable();
          result.device_ = device_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.ShardingSpecProto) {
          return mergeFrom((Onnx.ShardingSpecProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.ShardingSpecProto other) {
        if (other == Onnx.ShardingSpecProto.getDefaultInstance()) return this;
        if (other.hasTensorName()) {
          tensorName_ = other.tensorName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.device_.isEmpty()) {
          if (device_.isEmpty()) {
            device_ = other.device_;
            device_.makeImmutable();
            bitField0_ |= 0x00000002;
          } else {
            ensureDeviceIsMutable();
            device_.addAll(other.device_);
          }
          onChanged();
        }
        if (indexToDeviceGroupMapBuilder_ == null) {
          if (!other.indexToDeviceGroupMap_.isEmpty()) {
            if (indexToDeviceGroupMap_.isEmpty()) {
              indexToDeviceGroupMap_ = other.indexToDeviceGroupMap_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureIndexToDeviceGroupMapIsMutable();
              indexToDeviceGroupMap_.addAll(other.indexToDeviceGroupMap_);
            }
            onChanged();
          }
        } else {
          if (!other.indexToDeviceGroupMap_.isEmpty()) {
            if (indexToDeviceGroupMapBuilder_.isEmpty()) {
              indexToDeviceGroupMapBuilder_.dispose();
              indexToDeviceGroupMapBuilder_ = null;
              indexToDeviceGroupMap_ = other.indexToDeviceGroupMap_;
              bitField0_ = (bitField0_ & ~0x00000004);
              indexToDeviceGroupMapBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetIndexToDeviceGroupMapFieldBuilder() : null;
            } else {
              indexToDeviceGroupMapBuilder_.addAllMessages(other.indexToDeviceGroupMap_);
            }
          }
        }
        if (shardedDimBuilder_ == null) {
          if (!other.shardedDim_.isEmpty()) {
            if (shardedDim_.isEmpty()) {
              shardedDim_ = other.shardedDim_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureShardedDimIsMutable();
              shardedDim_.addAll(other.shardedDim_);
            }
            onChanged();
          }
        } else {
          if (!other.shardedDim_.isEmpty()) {
            if (shardedDimBuilder_.isEmpty()) {
              shardedDimBuilder_.dispose();
              shardedDimBuilder_ = null;
              shardedDim_ = other.shardedDim_;
              bitField0_ = (bitField0_ & ~0x00000008);
              shardedDimBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetShardedDimFieldBuilder() : null;
            } else {
              shardedDimBuilder_.addAllMessages(other.shardedDim_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                tensorName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                long v = input.readInt64();
                ensureDeviceIsMutable();
                device_.addLong(v);
                break;
              } // case 16
              case 18: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureDeviceIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  device_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 18
              case 26: {
                Onnx.IntIntListEntryProto m =
                    input.readMessage(
                        Onnx.IntIntListEntryProto.parser(),
                        extensionRegistry);
                if (indexToDeviceGroupMapBuilder_ == null) {
                  ensureIndexToDeviceGroupMapIsMutable();
                  indexToDeviceGroupMap_.add(m);
                } else {
                  indexToDeviceGroupMapBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                Onnx.ShardedDimProto m =
                    input.readMessage(
                        Onnx.ShardedDimProto.parser(),
                        extensionRegistry);
                if (shardedDimBuilder_ == null) {
                  ensureShardedDimIsMutable();
                  shardedDim_.add(m);
                } else {
                  shardedDimBuilder_.addMessage(m);
                }
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object tensorName_ = "";
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @return Whether the tensorName field is set.
       */
      public boolean hasTensorName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @return The tensorName.
       */
      public java.lang.String getTensorName() {
        java.lang.Object ref = tensorName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            tensorName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @return The bytes for tensorName.
       */
      public com.google.protobuf.ByteString
          getTensorNameBytes() {
        java.lang.Object ref = tensorName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tensorName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @param value The tensorName to set.
       * @return This builder for chaining.
       */
      public Builder setTensorName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        tensorName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTensorName() {
        tensorName_ = getDefaultInstance().getTensorName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Identifies the input or output of the node that is being sharded.
       * Required to match a name specified in the node's input or output list of ValueInfoProtos.
       * It is called `logical tensor` in subsequent descriptions.
       * </pre>
       *
       * <code>optional string tensor_name = 1;</code>
       * @param value The bytes for tensorName to set.
       * @return This builder for chaining.
       */
      public Builder setTensorNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        tensorName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList device_ = emptyLongList();
      private void ensureDeviceIsMutable() {
        if (!device_.isModifiable()) {
          device_ = makeMutableCopy(device_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @return A list containing the device.
       */
      public java.util.List<java.lang.Long>
          getDeviceList() {
        device_.makeImmutable();
        return device_;
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @return The count of device.
       */
      public int getDeviceCount() {
        return device_.size();
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @param index The index of the element to return.
       * @return The device at the given index.
       */
      public long getDevice(int index) {
        return device_.getLong(index);
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @param index The index to set the value at.
       * @param value The device to set.
       * @return This builder for chaining.
       */
      public Builder setDevice(
          int index, long value) {

        ensureDeviceIsMutable();
        device_.setLong(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @param value The device to add.
       * @return This builder for chaining.
       */
      public Builder addDevice(long value) {

        ensureDeviceIsMutable();
        device_.addLong(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @param values The device to add.
       * @return This builder for chaining.
       */
      public Builder addAllDevice(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureDeviceIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, device_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The following is the list of devices across which the logical
       * tensor is sharded or replicated.
       * </pre>
       *
       * <code>repeated int64 device = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDevice() {
        device_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private java.util.List<Onnx.IntIntListEntryProto> indexToDeviceGroupMap_ =
        java.util.Collections.emptyList();
      private void ensureIndexToDeviceGroupMapIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          indexToDeviceGroupMap_ = new java.util.ArrayList<Onnx.IntIntListEntryProto>(indexToDeviceGroupMap_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.IntIntListEntryProto, Onnx.IntIntListEntryProto.Builder, Onnx.IntIntListEntryProtoOrBuilder> indexToDeviceGroupMapBuilder_;

      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public java.util.List<Onnx.IntIntListEntryProto> getIndexToDeviceGroupMapList() {
        if (indexToDeviceGroupMapBuilder_ == null) {
          return java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
        } else {
          return indexToDeviceGroupMapBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public int getIndexToDeviceGroupMapCount() {
        if (indexToDeviceGroupMapBuilder_ == null) {
          return indexToDeviceGroupMap_.size();
        } else {
          return indexToDeviceGroupMapBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Onnx.IntIntListEntryProto getIndexToDeviceGroupMap(int index) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          return indexToDeviceGroupMap_.get(index);
        } else {
          return indexToDeviceGroupMapBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder setIndexToDeviceGroupMap(
          int index, Onnx.IntIntListEntryProto value) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.set(index, value);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder setIndexToDeviceGroupMap(
          int index, Onnx.IntIntListEntryProto.Builder builderForValue) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.set(index, builderForValue.build());
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder addIndexToDeviceGroupMap(Onnx.IntIntListEntryProto value) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.add(value);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder addIndexToDeviceGroupMap(
          int index, Onnx.IntIntListEntryProto value) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.add(index, value);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder addIndexToDeviceGroupMap(
          Onnx.IntIntListEntryProto.Builder builderForValue) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.add(builderForValue.build());
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder addIndexToDeviceGroupMap(
          int index, Onnx.IntIntListEntryProto.Builder builderForValue) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.add(index, builderForValue.build());
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder addAllIndexToDeviceGroupMap(
          java.lang.Iterable<? extends Onnx.IntIntListEntryProto> values) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          ensureIndexToDeviceGroupMapIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, indexToDeviceGroupMap_);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder clearIndexToDeviceGroupMap() {
        if (indexToDeviceGroupMapBuilder_ == null) {
          indexToDeviceGroupMap_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Builder removeIndexToDeviceGroupMap(int index) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          ensureIndexToDeviceGroupMapIsMutable();
          indexToDeviceGroupMap_.remove(index);
          onChanged();
        } else {
          indexToDeviceGroupMapBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Onnx.IntIntListEntryProto.Builder getIndexToDeviceGroupMapBuilder(
          int index) {
        return internalGetIndexToDeviceGroupMapFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Onnx.IntIntListEntryProtoOrBuilder getIndexToDeviceGroupMapOrBuilder(
          int index) {
        if (indexToDeviceGroupMapBuilder_ == null) {
          return indexToDeviceGroupMap_.get(index);  } else {
          return indexToDeviceGroupMapBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public java.util.List<? extends Onnx.IntIntListEntryProtoOrBuilder> 
           getIndexToDeviceGroupMapOrBuilderList() {
        if (indexToDeviceGroupMapBuilder_ != null) {
          return indexToDeviceGroupMapBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(indexToDeviceGroupMap_);
        }
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Onnx.IntIntListEntryProto.Builder addIndexToDeviceGroupMapBuilder() {
        return internalGetIndexToDeviceGroupMapFieldBuilder().addBuilder(
            Onnx.IntIntListEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public Onnx.IntIntListEntryProto.Builder addIndexToDeviceGroupMapBuilder(
          int index) {
        return internalGetIndexToDeviceGroupMapFieldBuilder().addBuilder(
            index, Onnx.IntIntListEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Each element v in above field devices may represent either a
       * device or a set of devices (when we want the same shard/tensor
       * to be replicated across a subset of devices), as indicated by
       * the following optional map. If the map contains an entry for v,
       * then v represents a device group, and the map indicates the set
       * of devices in that group.
       * </pre>
       *
       * <code>repeated .IntIntListEntryProto index_to_device_group_map = 3;</code>
       */
      public java.util.List<Onnx.IntIntListEntryProto.Builder> 
           getIndexToDeviceGroupMapBuilderList() {
        return internalGetIndexToDeviceGroupMapFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.IntIntListEntryProto, Onnx.IntIntListEntryProto.Builder, Onnx.IntIntListEntryProtoOrBuilder> 
          internalGetIndexToDeviceGroupMapFieldBuilder() {
        if (indexToDeviceGroupMapBuilder_ == null) {
          indexToDeviceGroupMapBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.IntIntListEntryProto, Onnx.IntIntListEntryProto.Builder, Onnx.IntIntListEntryProtoOrBuilder>(
                  indexToDeviceGroupMap_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          indexToDeviceGroupMap_ = null;
        }
        return indexToDeviceGroupMapBuilder_;
      }

      private java.util.List<Onnx.ShardedDimProto> shardedDim_ =
        java.util.Collections.emptyList();
      private void ensureShardedDimIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          shardedDim_ = new java.util.ArrayList<Onnx.ShardedDimProto>(shardedDim_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ShardedDimProto, Onnx.ShardedDimProto.Builder, Onnx.ShardedDimProtoOrBuilder> shardedDimBuilder_;

      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public java.util.List<Onnx.ShardedDimProto> getShardedDimList() {
        if (shardedDimBuilder_ == null) {
          return java.util.Collections.unmodifiableList(shardedDim_);
        } else {
          return shardedDimBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public int getShardedDimCount() {
        if (shardedDimBuilder_ == null) {
          return shardedDim_.size();
        } else {
          return shardedDimBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Onnx.ShardedDimProto getShardedDim(int index) {
        if (shardedDimBuilder_ == null) {
          return shardedDim_.get(index);
        } else {
          return shardedDimBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder setShardedDim(
          int index, Onnx.ShardedDimProto value) {
        if (shardedDimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardedDimIsMutable();
          shardedDim_.set(index, value);
          onChanged();
        } else {
          shardedDimBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder setShardedDim(
          int index, Onnx.ShardedDimProto.Builder builderForValue) {
        if (shardedDimBuilder_ == null) {
          ensureShardedDimIsMutable();
          shardedDim_.set(index, builderForValue.build());
          onChanged();
        } else {
          shardedDimBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder addShardedDim(Onnx.ShardedDimProto value) {
        if (shardedDimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardedDimIsMutable();
          shardedDim_.add(value);
          onChanged();
        } else {
          shardedDimBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder addShardedDim(
          int index, Onnx.ShardedDimProto value) {
        if (shardedDimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureShardedDimIsMutable();
          shardedDim_.add(index, value);
          onChanged();
        } else {
          shardedDimBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder addShardedDim(
          Onnx.ShardedDimProto.Builder builderForValue) {
        if (shardedDimBuilder_ == null) {
          ensureShardedDimIsMutable();
          shardedDim_.add(builderForValue.build());
          onChanged();
        } else {
          shardedDimBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder addShardedDim(
          int index, Onnx.ShardedDimProto.Builder builderForValue) {
        if (shardedDimBuilder_ == null) {
          ensureShardedDimIsMutable();
          shardedDim_.add(index, builderForValue.build());
          onChanged();
        } else {
          shardedDimBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder addAllShardedDim(
          java.lang.Iterable<? extends Onnx.ShardedDimProto> values) {
        if (shardedDimBuilder_ == null) {
          ensureShardedDimIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, shardedDim_);
          onChanged();
        } else {
          shardedDimBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder clearShardedDim() {
        if (shardedDimBuilder_ == null) {
          shardedDim_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          shardedDimBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Builder removeShardedDim(int index) {
        if (shardedDimBuilder_ == null) {
          ensureShardedDimIsMutable();
          shardedDim_.remove(index);
          onChanged();
        } else {
          shardedDimBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Onnx.ShardedDimProto.Builder getShardedDimBuilder(
          int index) {
        return internalGetShardedDimFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Onnx.ShardedDimProtoOrBuilder getShardedDimOrBuilder(
          int index) {
        if (shardedDimBuilder_ == null) {
          return shardedDim_.get(index);  } else {
          return shardedDimBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public java.util.List<? extends Onnx.ShardedDimProtoOrBuilder> 
           getShardedDimOrBuilderList() {
        if (shardedDimBuilder_ != null) {
          return shardedDimBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(shardedDim_);
        }
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Onnx.ShardedDimProto.Builder addShardedDimBuilder() {
        return internalGetShardedDimFieldBuilder().addBuilder(
            Onnx.ShardedDimProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public Onnx.ShardedDimProto.Builder addShardedDimBuilder(
          int index) {
        return internalGetShardedDimFieldBuilder().addBuilder(
            index, Onnx.ShardedDimProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The following is the sharded-shape of the tensor, consisting of
       * the sharding-spec for each axis of the tensor.
       * </pre>
       *
       * <code>repeated .ShardedDimProto sharded_dim = 4;</code>
       */
      public java.util.List<Onnx.ShardedDimProto.Builder> 
           getShardedDimBuilderList() {
        return internalGetShardedDimFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ShardedDimProto, Onnx.ShardedDimProto.Builder, Onnx.ShardedDimProtoOrBuilder> 
          internalGetShardedDimFieldBuilder() {
        if (shardedDimBuilder_ == null) {
          shardedDimBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ShardedDimProto, Onnx.ShardedDimProto.Builder, Onnx.ShardedDimProtoOrBuilder>(
                  shardedDim_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          shardedDim_ = null;
        }
        return shardedDimBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:ShardingSpecProto)
    }

    // @@protoc_insertion_point(class_scope:ShardingSpecProto)
    private static final Onnx.ShardingSpecProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.ShardingSpecProto();
    }

    public static Onnx.ShardingSpecProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ShardingSpecProto>
        PARSER = new com.google.protobuf.AbstractParser<ShardingSpecProto>() {
      @java.lang.Override
      public ShardingSpecProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ShardingSpecProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ShardingSpecProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.ShardingSpecProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ShardedDimProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ShardedDimProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * The axis this sharding corresponds to. Must be in the range of
     * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
     * counting from the back.
     * </pre>
     *
     * <code>optional int64 axis = 1;</code>
     * @return Whether the axis field is set.
     */
    boolean hasAxis();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * The axis this sharding corresponds to. Must be in the range of
     * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
     * counting from the back.
     * </pre>
     *
     * <code>optional int64 axis = 1;</code>
     * @return The axis.
     */
    long getAxis();

    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    java.util.List<Onnx.SimpleShardedDimProto> 
        getSimpleShardingList();
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    Onnx.SimpleShardedDimProto getSimpleSharding(int index);
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    int getSimpleShardingCount();
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    java.util.List<? extends Onnx.SimpleShardedDimProtoOrBuilder> 
        getSimpleShardingOrBuilderList();
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    Onnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ShardedDimProto: This describes the sharding spec for a single
   * axis of a sharded tensor.
   * </pre>
   *
   * Protobuf type {@code ShardedDimProto}
   */
  public static final class ShardedDimProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:ShardedDimProto)
      ShardedDimProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        ShardedDimProto.class.getName());
    }
    // Use ShardedDimProto.newBuilder() to construct.
    private ShardedDimProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ShardedDimProto() {
      simpleSharding_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_ShardedDimProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_ShardedDimProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.ShardedDimProto.class, Onnx.ShardedDimProto.Builder.class);
    }

    private int bitField0_;
    public static final int AXIS_FIELD_NUMBER = 1;
    private long axis_ = 0L;
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * The axis this sharding corresponds to. Must be in the range of
     * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
     * counting from the back.
     * </pre>
     *
     * <code>optional int64 axis = 1;</code>
     * @return Whether the axis field is set.
     */
    @java.lang.Override
    public boolean hasAxis() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * The axis this sharding corresponds to. Must be in the range of
     * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
     * counting from the back.
     * </pre>
     *
     * <code>optional int64 axis = 1;</code>
     * @return The axis.
     */
    @java.lang.Override
    public long getAxis() {
      return axis_;
    }

    public static final int SIMPLE_SHARDING_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.SimpleShardedDimProto> simpleSharding_;
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.SimpleShardedDimProto> getSimpleShardingList() {
      return simpleSharding_;
    }
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.SimpleShardedDimProtoOrBuilder> 
        getSimpleShardingOrBuilderList() {
      return simpleSharding_;
    }
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    @java.lang.Override
    public int getSimpleShardingCount() {
      return simpleSharding_.size();
    }
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    @java.lang.Override
    public Onnx.SimpleShardedDimProto getSimpleSharding(int index) {
      return simpleSharding_.get(index);
    }
    /**
     * <pre>
     * Describes how the tensor on the provided axis is sharded.
     * The common-case is described by a single instance of SimpleShardedDimProto.
     * Multiple instances can be used to handle cases where a sharded
     * tensor is reshaped, fusing multiple axes into one.
     * </pre>
     *
     * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
     */
    @java.lang.Override
    public Onnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
        int index) {
      return simpleSharding_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, axis_);
      }
      for (int i = 0; i < simpleSharding_.size(); i++) {
        output.writeMessage(2, simpleSharding_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, axis_);
      }
      for (int i = 0; i < simpleSharding_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, simpleSharding_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.ShardedDimProto)) {
        return super.equals(obj);
      }
      Onnx.ShardedDimProto other = (Onnx.ShardedDimProto) obj;

      if (hasAxis() != other.hasAxis()) return false;
      if (hasAxis()) {
        if (getAxis()
            != other.getAxis()) return false;
      }
      if (!getSimpleShardingList()
          .equals(other.getSimpleShardingList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAxis()) {
        hash = (37 * hash) + AXIS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getAxis());
      }
      if (getSimpleShardingCount() > 0) {
        hash = (37 * hash) + SIMPLE_SHARDING_FIELD_NUMBER;
        hash = (53 * hash) + getSimpleShardingList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.ShardedDimProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardedDimProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardedDimProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardedDimProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardedDimProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ShardedDimProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ShardedDimProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ShardedDimProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.ShardedDimProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.ShardedDimProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.ShardedDimProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ShardedDimProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.ShardedDimProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ShardedDimProto: This describes the sharding spec for a single
     * axis of a sharded tensor.
     * </pre>
     *
     * Protobuf type {@code ShardedDimProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ShardedDimProto)
        Onnx.ShardedDimProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_ShardedDimProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_ShardedDimProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.ShardedDimProto.class, Onnx.ShardedDimProto.Builder.class);
      }

      // Construct using Onnx.ShardedDimProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        axis_ = 0L;
        if (simpleShardingBuilder_ == null) {
          simpleSharding_ = java.util.Collections.emptyList();
        } else {
          simpleSharding_ = null;
          simpleShardingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_ShardedDimProto_descriptor;
      }

      @java.lang.Override
      public Onnx.ShardedDimProto getDefaultInstanceForType() {
        return Onnx.ShardedDimProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.ShardedDimProto build() {
        Onnx.ShardedDimProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.ShardedDimProto buildPartial() {
        Onnx.ShardedDimProto result = new Onnx.ShardedDimProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.ShardedDimProto result) {
        if (simpleShardingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            simpleSharding_ = java.util.Collections.unmodifiableList(simpleSharding_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.simpleSharding_ = simpleSharding_;
        } else {
          result.simpleSharding_ = simpleShardingBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.ShardedDimProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.axis_ = axis_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.ShardedDimProto) {
          return mergeFrom((Onnx.ShardedDimProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.ShardedDimProto other) {
        if (other == Onnx.ShardedDimProto.getDefaultInstance()) return this;
        if (other.hasAxis()) {
          setAxis(other.getAxis());
        }
        if (simpleShardingBuilder_ == null) {
          if (!other.simpleSharding_.isEmpty()) {
            if (simpleSharding_.isEmpty()) {
              simpleSharding_ = other.simpleSharding_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureSimpleShardingIsMutable();
              simpleSharding_.addAll(other.simpleSharding_);
            }
            onChanged();
          }
        } else {
          if (!other.simpleSharding_.isEmpty()) {
            if (simpleShardingBuilder_.isEmpty()) {
              simpleShardingBuilder_.dispose();
              simpleShardingBuilder_ = null;
              simpleSharding_ = other.simpleSharding_;
              bitField0_ = (bitField0_ & ~0x00000002);
              simpleShardingBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetSimpleShardingFieldBuilder() : null;
            } else {
              simpleShardingBuilder_.addAllMessages(other.simpleSharding_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                axis_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                Onnx.SimpleShardedDimProto m =
                    input.readMessage(
                        Onnx.SimpleShardedDimProto.parser(),
                        extensionRegistry);
                if (simpleShardingBuilder_ == null) {
                  ensureSimpleShardingIsMutable();
                  simpleSharding_.add(m);
                } else {
                  simpleShardingBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long axis_ ;
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * The axis this sharding corresponds to. Must be in the range of
       * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
       * counting from the back.
       * </pre>
       *
       * <code>optional int64 axis = 1;</code>
       * @return Whether the axis field is set.
       */
      @java.lang.Override
      public boolean hasAxis() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * The axis this sharding corresponds to. Must be in the range of
       * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
       * counting from the back.
       * </pre>
       *
       * <code>optional int64 axis = 1;</code>
       * @return The axis.
       */
      @java.lang.Override
      public long getAxis() {
        return axis_;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * The axis this sharding corresponds to. Must be in the range of
       * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
       * counting from the back.
       * </pre>
       *
       * <code>optional int64 axis = 1;</code>
       * @param value The axis to set.
       * @return This builder for chaining.
       */
      public Builder setAxis(long value) {

        axis_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * The axis this sharding corresponds to. Must be in the range of
       * [-r, r - 1], where r is the rank of the tensor. Negative axis values means
       * counting from the back.
       * </pre>
       *
       * <code>optional int64 axis = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAxis() {
        bitField0_ = (bitField0_ & ~0x00000001);
        axis_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.SimpleShardedDimProto> simpleSharding_ =
        java.util.Collections.emptyList();
      private void ensureSimpleShardingIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          simpleSharding_ = new java.util.ArrayList<Onnx.SimpleShardedDimProto>(simpleSharding_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SimpleShardedDimProto, Onnx.SimpleShardedDimProto.Builder, Onnx.SimpleShardedDimProtoOrBuilder> simpleShardingBuilder_;

      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public java.util.List<Onnx.SimpleShardedDimProto> getSimpleShardingList() {
        if (simpleShardingBuilder_ == null) {
          return java.util.Collections.unmodifiableList(simpleSharding_);
        } else {
          return simpleShardingBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public int getSimpleShardingCount() {
        if (simpleShardingBuilder_ == null) {
          return simpleSharding_.size();
        } else {
          return simpleShardingBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Onnx.SimpleShardedDimProto getSimpleSharding(int index) {
        if (simpleShardingBuilder_ == null) {
          return simpleSharding_.get(index);
        } else {
          return simpleShardingBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder setSimpleSharding(
          int index, Onnx.SimpleShardedDimProto value) {
        if (simpleShardingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSimpleShardingIsMutable();
          simpleSharding_.set(index, value);
          onChanged();
        } else {
          simpleShardingBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder setSimpleSharding(
          int index, Onnx.SimpleShardedDimProto.Builder builderForValue) {
        if (simpleShardingBuilder_ == null) {
          ensureSimpleShardingIsMutable();
          simpleSharding_.set(index, builderForValue.build());
          onChanged();
        } else {
          simpleShardingBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder addSimpleSharding(Onnx.SimpleShardedDimProto value) {
        if (simpleShardingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSimpleShardingIsMutable();
          simpleSharding_.add(value);
          onChanged();
        } else {
          simpleShardingBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder addSimpleSharding(
          int index, Onnx.SimpleShardedDimProto value) {
        if (simpleShardingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSimpleShardingIsMutable();
          simpleSharding_.add(index, value);
          onChanged();
        } else {
          simpleShardingBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder addSimpleSharding(
          Onnx.SimpleShardedDimProto.Builder builderForValue) {
        if (simpleShardingBuilder_ == null) {
          ensureSimpleShardingIsMutable();
          simpleSharding_.add(builderForValue.build());
          onChanged();
        } else {
          simpleShardingBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder addSimpleSharding(
          int index, Onnx.SimpleShardedDimProto.Builder builderForValue) {
        if (simpleShardingBuilder_ == null) {
          ensureSimpleShardingIsMutable();
          simpleSharding_.add(index, builderForValue.build());
          onChanged();
        } else {
          simpleShardingBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder addAllSimpleSharding(
          java.lang.Iterable<? extends Onnx.SimpleShardedDimProto> values) {
        if (simpleShardingBuilder_ == null) {
          ensureSimpleShardingIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, simpleSharding_);
          onChanged();
        } else {
          simpleShardingBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder clearSimpleSharding() {
        if (simpleShardingBuilder_ == null) {
          simpleSharding_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          simpleShardingBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Builder removeSimpleSharding(int index) {
        if (simpleShardingBuilder_ == null) {
          ensureSimpleShardingIsMutable();
          simpleSharding_.remove(index);
          onChanged();
        } else {
          simpleShardingBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Onnx.SimpleShardedDimProto.Builder getSimpleShardingBuilder(
          int index) {
        return internalGetSimpleShardingFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Onnx.SimpleShardedDimProtoOrBuilder getSimpleShardingOrBuilder(
          int index) {
        if (simpleShardingBuilder_ == null) {
          return simpleSharding_.get(index);  } else {
          return simpleShardingBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public java.util.List<? extends Onnx.SimpleShardedDimProtoOrBuilder> 
           getSimpleShardingOrBuilderList() {
        if (simpleShardingBuilder_ != null) {
          return simpleShardingBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(simpleSharding_);
        }
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Onnx.SimpleShardedDimProto.Builder addSimpleShardingBuilder() {
        return internalGetSimpleShardingFieldBuilder().addBuilder(
            Onnx.SimpleShardedDimProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public Onnx.SimpleShardedDimProto.Builder addSimpleShardingBuilder(
          int index) {
        return internalGetSimpleShardingFieldBuilder().addBuilder(
            index, Onnx.SimpleShardedDimProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Describes how the tensor on the provided axis is sharded.
       * The common-case is described by a single instance of SimpleShardedDimProto.
       * Multiple instances can be used to handle cases where a sharded
       * tensor is reshaped, fusing multiple axes into one.
       * </pre>
       *
       * <code>repeated .SimpleShardedDimProto simple_sharding = 2;</code>
       */
      public java.util.List<Onnx.SimpleShardedDimProto.Builder> 
           getSimpleShardingBuilderList() {
        return internalGetSimpleShardingFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SimpleShardedDimProto, Onnx.SimpleShardedDimProto.Builder, Onnx.SimpleShardedDimProtoOrBuilder> 
          internalGetSimpleShardingFieldBuilder() {
        if (simpleShardingBuilder_ == null) {
          simpleShardingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.SimpleShardedDimProto, Onnx.SimpleShardedDimProto.Builder, Onnx.SimpleShardedDimProtoOrBuilder>(
                  simpleSharding_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          simpleSharding_ = null;
        }
        return simpleShardingBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:ShardedDimProto)
    }

    // @@protoc_insertion_point(class_scope:ShardedDimProto)
    private static final Onnx.ShardedDimProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.ShardedDimProto();
    }

    public static Onnx.ShardedDimProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ShardedDimProto>
        PARSER = new com.google.protobuf.AbstractParser<ShardedDimProto>() {
      @java.lang.Override
      public ShardedDimProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ShardedDimProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ShardedDimProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.ShardedDimProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SimpleShardedDimProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:SimpleShardedDimProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>int64 dim_value = 1;</code>
     * @return Whether the dimValue field is set.
     */
    boolean hasDimValue();
    /**
     * <code>int64 dim_value = 1;</code>
     * @return The dimValue.
     */
    long getDimValue();

    /**
     * <code>string dim_param = 2;</code>
     * @return Whether the dimParam field is set.
     */
    boolean hasDimParam();
    /**
     * <code>string dim_param = 2;</code>
     * @return The dimParam.
     */
    java.lang.String getDimParam();
    /**
     * <code>string dim_param = 2;</code>
     * @return The bytes for dimParam.
     */
    com.google.protobuf.ByteString
        getDimParamBytes();

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of shards to split dim into.
     * </pre>
     *
     * <code>optional int64 num_shards = 3;</code>
     * @return Whether the numShards field is set.
     */
    boolean hasNumShards();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of shards to split dim into.
     * </pre>
     *
     * <code>optional int64 num_shards = 3;</code>
     * @return The numShards.
     */
    long getNumShards();

    Onnx.SimpleShardedDimProto.DimCase getDimCase();
  }
  /**
   * <pre>
   * SimpleShardedDimProto: Indicates that N blocks are divided into M shards.
   * N is allowed to be symbolic where M is required to be a constant.
   * </pre>
   *
   * Protobuf type {@code SimpleShardedDimProto}
   */
  public static final class SimpleShardedDimProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:SimpleShardedDimProto)
      SimpleShardedDimProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        SimpleShardedDimProto.class.getName());
    }
    // Use SimpleShardedDimProto.newBuilder() to construct.
    private SimpleShardedDimProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SimpleShardedDimProto() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.SimpleShardedDimProto.class, Onnx.SimpleShardedDimProto.Builder.class);
    }

    private int bitField0_;
    private int dimCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object dim_;
    public enum DimCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      DIM_VALUE(1),
      DIM_PARAM(2),
      DIM_NOT_SET(0);
      private final int value;
      private DimCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DimCase valueOf(int value) {
        return forNumber(value);
      }

      public static DimCase forNumber(int value) {
        switch (value) {
          case 1: return DIM_VALUE;
          case 2: return DIM_PARAM;
          case 0: return DIM_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public DimCase
    getDimCase() {
      return DimCase.forNumber(
          dimCase_);
    }

    public static final int DIM_VALUE_FIELD_NUMBER = 1;
    /**
     * <code>int64 dim_value = 1;</code>
     * @return Whether the dimValue field is set.
     */
    @java.lang.Override
    public boolean hasDimValue() {
      return dimCase_ == 1;
    }
    /**
     * <code>int64 dim_value = 1;</code>
     * @return The dimValue.
     */
    @java.lang.Override
    public long getDimValue() {
      if (dimCase_ == 1) {
        return (java.lang.Long) dim_;
      }
      return 0L;
    }

    public static final int DIM_PARAM_FIELD_NUMBER = 2;
    /**
     * <code>string dim_param = 2;</code>
     * @return Whether the dimParam field is set.
     */
    public boolean hasDimParam() {
      return dimCase_ == 2;
    }
    /**
     * <code>string dim_param = 2;</code>
     * @return The dimParam.
     */
    public java.lang.String getDimParam() {
      java.lang.Object ref = "";
      if (dimCase_ == 2) {
        ref = dim_;
      }
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8() && (dimCase_ == 2)) {
          dim_ = s;
        }
        return s;
      }
    }
    /**
     * <code>string dim_param = 2;</code>
     * @return The bytes for dimParam.
     */
    public com.google.protobuf.ByteString
        getDimParamBytes() {
      java.lang.Object ref = "";
      if (dimCase_ == 2) {
        ref = dim_;
      }
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        if (dimCase_ == 2) {
          dim_ = b;
        }
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NUM_SHARDS_FIELD_NUMBER = 3;
    private long numShards_ = 0L;
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of shards to split dim into.
     * </pre>
     *
     * <code>optional int64 num_shards = 3;</code>
     * @return Whether the numShards field is set.
     */
    @java.lang.Override
    public boolean hasNumShards() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of shards to split dim into.
     * </pre>
     *
     * <code>optional int64 num_shards = 3;</code>
     * @return The numShards.
     */
    @java.lang.Override
    public long getNumShards() {
      return numShards_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (dimCase_ == 1) {
        output.writeInt64(
            1, (long)((java.lang.Long) dim_));
      }
      if (dimCase_ == 2) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, dim_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(3, numShards_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (dimCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(
              1, (long)((java.lang.Long) dim_));
      }
      if (dimCase_ == 2) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, dim_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(3, numShards_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.SimpleShardedDimProto)) {
        return super.equals(obj);
      }
      Onnx.SimpleShardedDimProto other = (Onnx.SimpleShardedDimProto) obj;

      if (hasNumShards() != other.hasNumShards()) return false;
      if (hasNumShards()) {
        if (getNumShards()
            != other.getNumShards()) return false;
      }
      if (!getDimCase().equals(other.getDimCase())) return false;
      switch (dimCase_) {
        case 1:
          if (getDimValue()
              != other.getDimValue()) return false;
          break;
        case 2:
          if (!getDimParam()
              .equals(other.getDimParam())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNumShards()) {
        hash = (37 * hash) + NUM_SHARDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getNumShards());
      }
      switch (dimCase_) {
        case 1:
          hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getDimValue());
          break;
        case 2:
          hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
          hash = (53 * hash) + getDimParam().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.SimpleShardedDimProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.SimpleShardedDimProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.SimpleShardedDimProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.SimpleShardedDimProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.SimpleShardedDimProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * SimpleShardedDimProto: Indicates that N blocks are divided into M shards.
     * N is allowed to be symbolic where M is required to be a constant.
     * </pre>
     *
     * Protobuf type {@code SimpleShardedDimProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:SimpleShardedDimProto)
        Onnx.SimpleShardedDimProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.SimpleShardedDimProto.class, Onnx.SimpleShardedDimProto.Builder.class);
      }

      // Construct using Onnx.SimpleShardedDimProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        numShards_ = 0L;
        dimCase_ = 0;
        dim_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_SimpleShardedDimProto_descriptor;
      }

      @java.lang.Override
      public Onnx.SimpleShardedDimProto getDefaultInstanceForType() {
        return Onnx.SimpleShardedDimProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.SimpleShardedDimProto build() {
        Onnx.SimpleShardedDimProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.SimpleShardedDimProto buildPartial() {
        Onnx.SimpleShardedDimProto result = new Onnx.SimpleShardedDimProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.SimpleShardedDimProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.numShards_ = numShards_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartialOneofs(Onnx.SimpleShardedDimProto result) {
        result.dimCase_ = dimCase_;
        result.dim_ = this.dim_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.SimpleShardedDimProto) {
          return mergeFrom((Onnx.SimpleShardedDimProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.SimpleShardedDimProto other) {
        if (other == Onnx.SimpleShardedDimProto.getDefaultInstance()) return this;
        if (other.hasNumShards()) {
          setNumShards(other.getNumShards());
        }
        switch (other.getDimCase()) {
          case DIM_VALUE: {
            setDimValue(other.getDimValue());
            break;
          }
          case DIM_PARAM: {
            dimCase_ = 2;
            dim_ = other.dim_;
            onChanged();
            break;
          }
          case DIM_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                dim_ = input.readInt64();
                dimCase_ = 1;
                break;
              } // case 8
              case 18: {
                com.google.protobuf.ByteString bs = input.readBytes();
                dimCase_ = 2;
                dim_ = bs;
                break;
              } // case 18
              case 24: {
                numShards_ = input.readInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int dimCase_ = 0;
      private java.lang.Object dim_;
      public DimCase
          getDimCase() {
        return DimCase.forNumber(
            dimCase_);
      }

      public Builder clearDim() {
        dimCase_ = 0;
        dim_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      /**
       * <code>int64 dim_value = 1;</code>
       * @return Whether the dimValue field is set.
       */
      public boolean hasDimValue() {
        return dimCase_ == 1;
      }
      /**
       * <code>int64 dim_value = 1;</code>
       * @return The dimValue.
       */
      public long getDimValue() {
        if (dimCase_ == 1) {
          return (java.lang.Long) dim_;
        }
        return 0L;
      }
      /**
       * <code>int64 dim_value = 1;</code>
       * @param value The dimValue to set.
       * @return This builder for chaining.
       */
      public Builder setDimValue(long value) {

        dimCase_ = 1;
        dim_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>int64 dim_value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDimValue() {
        if (dimCase_ == 1) {
          dimCase_ = 0;
          dim_ = null;
          onChanged();
        }
        return this;
      }

      /**
       * <code>string dim_param = 2;</code>
       * @return Whether the dimParam field is set.
       */
      @java.lang.Override
      public boolean hasDimParam() {
        return dimCase_ == 2;
      }
      /**
       * <code>string dim_param = 2;</code>
       * @return The dimParam.
       */
      @java.lang.Override
      public java.lang.String getDimParam() {
        java.lang.Object ref = "";
        if (dimCase_ == 2) {
          ref = dim_;
        }
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (dimCase_ == 2) {
            if (bs.isValidUtf8()) {
              dim_ = s;
            }
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string dim_param = 2;</code>
       * @return The bytes for dimParam.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDimParamBytes() {
        java.lang.Object ref = "";
        if (dimCase_ == 2) {
          ref = dim_;
        }
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (dimCase_ == 2) {
            dim_ = b;
          }
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string dim_param = 2;</code>
       * @param value The dimParam to set.
       * @return This builder for chaining.
       */
      public Builder setDimParam(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        dimCase_ = 2;
        dim_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string dim_param = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDimParam() {
        if (dimCase_ == 2) {
          dimCase_ = 0;
          dim_ = null;
          onChanged();
        }
        return this;
      }
      /**
       * <code>string dim_param = 2;</code>
       * @param value The bytes for dimParam to set.
       * @return This builder for chaining.
       */
      public Builder setDimParamBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        dimCase_ = 2;
        dim_ = value;
        onChanged();
        return this;
      }

      private long numShards_ ;
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of shards to split dim into.
       * </pre>
       *
       * <code>optional int64 num_shards = 3;</code>
       * @return Whether the numShards field is set.
       */
      @java.lang.Override
      public boolean hasNumShards() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of shards to split dim into.
       * </pre>
       *
       * <code>optional int64 num_shards = 3;</code>
       * @return The numShards.
       */
      @java.lang.Override
      public long getNumShards() {
        return numShards_;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of shards to split dim into.
       * </pre>
       *
       * <code>optional int64 num_shards = 3;</code>
       * @param value The numShards to set.
       * @return This builder for chaining.
       */
      public Builder setNumShards(long value) {

        numShards_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of shards to split dim into.
       * </pre>
       *
       * <code>optional int64 num_shards = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumShards() {
        bitField0_ = (bitField0_ & ~0x00000004);
        numShards_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:SimpleShardedDimProto)
    }

    // @@protoc_insertion_point(class_scope:SimpleShardedDimProto)
    private static final Onnx.SimpleShardedDimProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.SimpleShardedDimProto();
    }

    public static Onnx.SimpleShardedDimProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SimpleShardedDimProto>
        PARSER = new com.google.protobuf.AbstractParser<SimpleShardedDimProto>() {
      @java.lang.Override
      public SimpleShardedDimProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SimpleShardedDimProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SimpleShardedDimProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.SimpleShardedDimProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TrainingInfoProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TrainingInfoProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     * @return Whether the initialization field is set.
     */
    boolean hasInitialization();
    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     * @return The initialization.
     */
    Onnx.GraphProto getInitialization();
    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     */
    Onnx.GraphProtoOrBuilder getInitializationOrBuilder();

    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     * @return Whether the algorithm field is set.
     */
    boolean hasAlgorithm();
    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     * @return The algorithm.
     */
    Onnx.GraphProto getAlgorithm();
    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     */
    Onnx.GraphProtoOrBuilder getAlgorithmOrBuilder();

    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getInitializationBindingList();
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    Onnx.StringStringEntryProto getInitializationBinding(int index);
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    int getInitializationBindingCount();
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getInitializationBindingOrBuilderList();
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
        int index);

    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getUpdateBindingList();
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    Onnx.StringStringEntryProto getUpdateBinding(int index);
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    int getUpdateBindingCount();
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getUpdateBindingOrBuilderList();
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Training information
   * TrainingInfoProto stores information for training a model.
   * In particular, this defines two functionalities: an initialization-step
   * and a training-algorithm-step. Initialization resets the model
   * back to its original state as if no training has been performed.
   * Training algorithm improves the model based on input data.
   *
   * The semantics of the initialization-step is that the initializers
   * in ModelProto.graph and in TrainingInfoProto.algorithm are first
   * initialized as specified by the initializers in the graph, and then
   * updated by the "initialization_binding" in every instance in
   * ModelProto.training_info.
   *
   * The field "algorithm" defines a computation graph which represents a
   * training algorithm's step. After the execution of a
   * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
   * may be immediately updated. If the targeted training algorithm contains
   * consecutive update steps (such as block coordinate descent methods),
   * the user needs to create a TrainingInfoProto for each step.
   * </pre>
   *
   * Protobuf type {@code TrainingInfoProto}
   */
  public static final class TrainingInfoProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:TrainingInfoProto)
      TrainingInfoProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        TrainingInfoProto.class.getName());
    }
    // Use TrainingInfoProto.newBuilder() to construct.
    private TrainingInfoProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TrainingInfoProto() {
      initializationBinding_ = java.util.Collections.emptyList();
      updateBinding_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_TrainingInfoProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.TrainingInfoProto.class, Onnx.TrainingInfoProto.Builder.class);
    }

    private int bitField0_;
    public static final int INITIALIZATION_FIELD_NUMBER = 1;
    private Onnx.GraphProto initialization_;
    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     * @return Whether the initialization field is set.
     */
    @java.lang.Override
    public boolean hasInitialization() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     * @return The initialization.
     */
    @java.lang.Override
    public Onnx.GraphProto getInitialization() {
      return initialization_ == null ? Onnx.GraphProto.getDefaultInstance() : initialization_;
    }
    /**
     * <pre>
     * This field describes a graph to compute the initial tensors
     * upon starting the training process. Initialization graph has no input
     * and can have multiple outputs. Usually, trainable tensors in neural
     * networks are randomly initialized. To achieve that, for each tensor,
     * the user can put a random number operator such as RandomNormal or
     * RandomUniform in TrainingInfoProto.initialization.node and assign its
     * random output to the specific tensor using "initialization_binding".
     * This graph can also set the initializers in "algorithm" in the same
     * TrainingInfoProto; a use case is resetting the number of training
     * iteration to zero.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Thus, no initializer would be changed by default.
     * </pre>
     *
     * <code>optional .GraphProto initialization = 1;</code>
     */
    @java.lang.Override
    public Onnx.GraphProtoOrBuilder getInitializationOrBuilder() {
      return initialization_ == null ? Onnx.GraphProto.getDefaultInstance() : initialization_;
    }

    public static final int ALGORITHM_FIELD_NUMBER = 2;
    private Onnx.GraphProto algorithm_;
    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     * @return Whether the algorithm field is set.
     */
    @java.lang.Override
    public boolean hasAlgorithm() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     * @return The algorithm.
     */
    @java.lang.Override
    public Onnx.GraphProto getAlgorithm() {
      return algorithm_ == null ? Onnx.GraphProto.getDefaultInstance() : algorithm_;
    }
    /**
     * <pre>
     * This field represents a training algorithm step. Given required inputs,
     * it computes outputs to update initializers in its own or inference graph's
     * initializer lists. In general, this field contains loss node, gradient node,
     * optimizer node, increment of iteration count.
     *
     * An execution of the training algorithm step is performed by executing the
     * graph obtained by combining the inference graph (namely "ModelProto.graph")
     * and the "algorithm" graph. That is, the actual
     * input/initializer/output/node/value_info/sparse_initializer list of
     * the training graph is the concatenation of
     * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
     * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
     * in that order. This combined graph must satisfy the normal ONNX conditions.
     * Now, let's provide a visualization of graph combination for clarity.
     * Let the inference graph (i.e., "ModelProto.graph") be
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
     * and the "algorithm" graph be
     * tensor_d -&gt; Add -&gt; tensor_e
     * The combination process results
     * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
     *
     * Notice that an input of a node in the "algorithm" graph may reference the
     * output of a node in the inference graph (but not the other way round). Also, inference
     * node cannot reference inputs of "algorithm". With these restrictions, inference graph
     * can always be run independently without training information.
     *
     * By default, this field is an empty graph and its evaluation does not
     * produce any output. Evaluating the default training step never
     * update any initializers.
     * </pre>
     *
     * <code>optional .GraphProto algorithm = 2;</code>
     */
    @java.lang.Override
    public Onnx.GraphProtoOrBuilder getAlgorithmOrBuilder() {
      return algorithm_ == null ? Onnx.GraphProto.getDefaultInstance() : algorithm_;
    }

    public static final int INITIALIZATION_BINDING_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> initializationBinding_;
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getInitializationBindingList() {
      return initializationBinding_;
    }
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getInitializationBindingOrBuilderList() {
      return initializationBinding_;
    }
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    @java.lang.Override
    public int getInitializationBindingCount() {
      return initializationBinding_.size();
    }
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getInitializationBinding(int index) {
      return initializationBinding_.get(index);
    }
    /**
     * <pre>
     * This field specifies the bindings from the outputs of "initialization" to
     * some initializers in "ModelProto.graph.initializer" and
     * the "algorithm.initializer" in the same TrainingInfoProto.
     * See "update_binding" below for details.
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "initialization".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
        int index) {
      return initializationBinding_.get(index);
    }

    public static final int UPDATE_BINDING_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> updateBinding_;
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getUpdateBindingList() {
      return updateBinding_;
    }
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getUpdateBindingOrBuilderList() {
      return updateBinding_;
    }
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    @java.lang.Override
    public int getUpdateBindingCount() {
      return updateBinding_.size();
    }
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getUpdateBinding(int index) {
      return updateBinding_.get(index);
    }
    /**
     * <pre>
     * Gradient-based training is usually an iterative procedure. In one gradient
     * descent iteration, we apply
     *
     * x = x - r * g
     *
     * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
     * gradient of "x" with respect to a chosen loss. To avoid adding assignments
     * into the training graph, we split the update equation into
     *
     * y = x - r * g
     * x = y
     *
     * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
     * tell that "y" should be assigned to "x", the field "update_binding" may
     * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
     * and "y" (value of StringStringEntryProto).
     * For a neural network with multiple trainable (mutable) tensors, there can
     * be multiple key-value pairs in "update_binding".
     *
     * The initializers appears as keys in "update_binding" are considered
     * mutable variables. This implies some behaviors
     * as described below.
     *
     * 1. We have only unique keys in all "update_binding"s so that two
     * variables may not have the same name. This ensures that one
     * variable is assigned up to once.
     * 2. The keys must appear in names of "ModelProto.graph.initializer" or
     * "TrainingInfoProto.algorithm.initializer".
     * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
     * 4. Mutable variables are initialized to the value specified by the
     * corresponding initializer, and then potentially updated by
     * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
     *
     * This field usually contains names of trainable tensors
     * (in ModelProto.graph), optimizer states such as momentums in advanced
     * stochastic gradient methods (in TrainingInfoProto.graph),
     * and number of training iterations (in TrainingInfoProto.graph).
     *
     * By default, this field is empty and no initializer would be changed
     * by the execution of "algorithm".
     * </pre>
     *
     * <code>repeated .StringStringEntryProto update_binding = 4;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
        int index) {
      return updateBinding_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getInitialization());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getAlgorithm());
      }
      for (int i = 0; i < initializationBinding_.size(); i++) {
        output.writeMessage(3, initializationBinding_.get(i));
      }
      for (int i = 0; i < updateBinding_.size(); i++) {
        output.writeMessage(4, updateBinding_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getInitialization());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getAlgorithm());
      }
      for (int i = 0; i < initializationBinding_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, initializationBinding_.get(i));
      }
      for (int i = 0; i < updateBinding_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, updateBinding_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.TrainingInfoProto)) {
        return super.equals(obj);
      }
      Onnx.TrainingInfoProto other = (Onnx.TrainingInfoProto) obj;

      if (hasInitialization() != other.hasInitialization()) return false;
      if (hasInitialization()) {
        if (!getInitialization()
            .equals(other.getInitialization())) return false;
      }
      if (hasAlgorithm() != other.hasAlgorithm()) return false;
      if (hasAlgorithm()) {
        if (!getAlgorithm()
            .equals(other.getAlgorithm())) return false;
      }
      if (!getInitializationBindingList()
          .equals(other.getInitializationBindingList())) return false;
      if (!getUpdateBindingList()
          .equals(other.getUpdateBindingList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasInitialization()) {
        hash = (37 * hash) + INITIALIZATION_FIELD_NUMBER;
        hash = (53 * hash) + getInitialization().hashCode();
      }
      if (hasAlgorithm()) {
        hash = (37 * hash) + ALGORITHM_FIELD_NUMBER;
        hash = (53 * hash) + getAlgorithm().hashCode();
      }
      if (getInitializationBindingCount() > 0) {
        hash = (37 * hash) + INITIALIZATION_BINDING_FIELD_NUMBER;
        hash = (53 * hash) + getInitializationBindingList().hashCode();
      }
      if (getUpdateBindingCount() > 0) {
        hash = (37 * hash) + UPDATE_BINDING_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateBindingList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.TrainingInfoProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TrainingInfoProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TrainingInfoProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.TrainingInfoProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.TrainingInfoProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TrainingInfoProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.TrainingInfoProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Training information
     * TrainingInfoProto stores information for training a model.
     * In particular, this defines two functionalities: an initialization-step
     * and a training-algorithm-step. Initialization resets the model
     * back to its original state as if no training has been performed.
     * Training algorithm improves the model based on input data.
     *
     * The semantics of the initialization-step is that the initializers
     * in ModelProto.graph and in TrainingInfoProto.algorithm are first
     * initialized as specified by the initializers in the graph, and then
     * updated by the "initialization_binding" in every instance in
     * ModelProto.training_info.
     *
     * The field "algorithm" defines a computation graph which represents a
     * training algorithm's step. After the execution of a
     * TrainingInfoProto.algorithm, the initializers specified by "update_binding"
     * may be immediately updated. If the targeted training algorithm contains
     * consecutive update steps (such as block coordinate descent methods),
     * the user needs to create a TrainingInfoProto for each step.
     * </pre>
     *
     * Protobuf type {@code TrainingInfoProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:TrainingInfoProto)
        Onnx.TrainingInfoProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TrainingInfoProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TrainingInfoProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TrainingInfoProto.class, Onnx.TrainingInfoProto.Builder.class);
      }

      // Construct using Onnx.TrainingInfoProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetInitializationFieldBuilder();
          internalGetAlgorithmFieldBuilder();
          internalGetInitializationBindingFieldBuilder();
          internalGetUpdateBindingFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        initialization_ = null;
        if (initializationBuilder_ != null) {
          initializationBuilder_.dispose();
          initializationBuilder_ = null;
        }
        algorithm_ = null;
        if (algorithmBuilder_ != null) {
          algorithmBuilder_.dispose();
          algorithmBuilder_ = null;
        }
        if (initializationBindingBuilder_ == null) {
          initializationBinding_ = java.util.Collections.emptyList();
        } else {
          initializationBinding_ = null;
          initializationBindingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (updateBindingBuilder_ == null) {
          updateBinding_ = java.util.Collections.emptyList();
        } else {
          updateBinding_ = null;
          updateBindingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_TrainingInfoProto_descriptor;
      }

      @java.lang.Override
      public Onnx.TrainingInfoProto getDefaultInstanceForType() {
        return Onnx.TrainingInfoProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.TrainingInfoProto build() {
        Onnx.TrainingInfoProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.TrainingInfoProto buildPartial() {
        Onnx.TrainingInfoProto result = new Onnx.TrainingInfoProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.TrainingInfoProto result) {
        if (initializationBindingBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            initializationBinding_ = java.util.Collections.unmodifiableList(initializationBinding_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.initializationBinding_ = initializationBinding_;
        } else {
          result.initializationBinding_ = initializationBindingBuilder_.build();
        }
        if (updateBindingBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            updateBinding_ = java.util.Collections.unmodifiableList(updateBinding_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.updateBinding_ = updateBinding_;
        } else {
          result.updateBinding_ = updateBindingBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.TrainingInfoProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.initialization_ = initializationBuilder_ == null
              ? initialization_
              : initializationBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.algorithm_ = algorithmBuilder_ == null
              ? algorithm_
              : algorithmBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.TrainingInfoProto) {
          return mergeFrom((Onnx.TrainingInfoProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.TrainingInfoProto other) {
        if (other == Onnx.TrainingInfoProto.getDefaultInstance()) return this;
        if (other.hasInitialization()) {
          mergeInitialization(other.getInitialization());
        }
        if (other.hasAlgorithm()) {
          mergeAlgorithm(other.getAlgorithm());
        }
        if (initializationBindingBuilder_ == null) {
          if (!other.initializationBinding_.isEmpty()) {
            if (initializationBinding_.isEmpty()) {
              initializationBinding_ = other.initializationBinding_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureInitializationBindingIsMutable();
              initializationBinding_.addAll(other.initializationBinding_);
            }
            onChanged();
          }
        } else {
          if (!other.initializationBinding_.isEmpty()) {
            if (initializationBindingBuilder_.isEmpty()) {
              initializationBindingBuilder_.dispose();
              initializationBindingBuilder_ = null;
              initializationBinding_ = other.initializationBinding_;
              bitField0_ = (bitField0_ & ~0x00000004);
              initializationBindingBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetInitializationBindingFieldBuilder() : null;
            } else {
              initializationBindingBuilder_.addAllMessages(other.initializationBinding_);
            }
          }
        }
        if (updateBindingBuilder_ == null) {
          if (!other.updateBinding_.isEmpty()) {
            if (updateBinding_.isEmpty()) {
              updateBinding_ = other.updateBinding_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureUpdateBindingIsMutable();
              updateBinding_.addAll(other.updateBinding_);
            }
            onChanged();
          }
        } else {
          if (!other.updateBinding_.isEmpty()) {
            if (updateBindingBuilder_.isEmpty()) {
              updateBindingBuilder_.dispose();
              updateBindingBuilder_ = null;
              updateBinding_ = other.updateBinding_;
              bitField0_ = (bitField0_ & ~0x00000008);
              updateBindingBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetUpdateBindingFieldBuilder() : null;
            } else {
              updateBindingBuilder_.addAllMessages(other.updateBinding_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    internalGetInitializationFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    internalGetAlgorithmFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (initializationBindingBuilder_ == null) {
                  ensureInitializationBindingIsMutable();
                  initializationBinding_.add(m);
                } else {
                  initializationBindingBuilder_.addMessage(m);
                }
                break;
              } // case 26
              case 34: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (updateBindingBuilder_ == null) {
                  ensureUpdateBindingIsMutable();
                  updateBinding_.add(m);
                } else {
                  updateBindingBuilder_.addMessage(m);
                }
                break;
              } // case 34
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private Onnx.GraphProto initialization_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> initializationBuilder_;
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       * @return Whether the initialization field is set.
       */
      public boolean hasInitialization() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       * @return The initialization.
       */
      public Onnx.GraphProto getInitialization() {
        if (initializationBuilder_ == null) {
          return initialization_ == null ? Onnx.GraphProto.getDefaultInstance() : initialization_;
        } else {
          return initializationBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Builder setInitialization(Onnx.GraphProto value) {
        if (initializationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          initialization_ = value;
        } else {
          initializationBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Builder setInitialization(
          Onnx.GraphProto.Builder builderForValue) {
        if (initializationBuilder_ == null) {
          initialization_ = builderForValue.build();
        } else {
          initializationBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Builder mergeInitialization(Onnx.GraphProto value) {
        if (initializationBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            initialization_ != null &&
            initialization_ != Onnx.GraphProto.getDefaultInstance()) {
            getInitializationBuilder().mergeFrom(value);
          } else {
            initialization_ = value;
          }
        } else {
          initializationBuilder_.mergeFrom(value);
        }
        if (initialization_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Builder clearInitialization() {
        bitField0_ = (bitField0_ & ~0x00000001);
        initialization_ = null;
        if (initializationBuilder_ != null) {
          initializationBuilder_.dispose();
          initializationBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Onnx.GraphProto.Builder getInitializationBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return internalGetInitializationFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      public Onnx.GraphProtoOrBuilder getInitializationOrBuilder() {
        if (initializationBuilder_ != null) {
          return initializationBuilder_.getMessageOrBuilder();
        } else {
          return initialization_ == null ?
              Onnx.GraphProto.getDefaultInstance() : initialization_;
        }
      }
      /**
       * <pre>
       * This field describes a graph to compute the initial tensors
       * upon starting the training process. Initialization graph has no input
       * and can have multiple outputs. Usually, trainable tensors in neural
       * networks are randomly initialized. To achieve that, for each tensor,
       * the user can put a random number operator such as RandomNormal or
       * RandomUniform in TrainingInfoProto.initialization.node and assign its
       * random output to the specific tensor using "initialization_binding".
       * This graph can also set the initializers in "algorithm" in the same
       * TrainingInfoProto; a use case is resetting the number of training
       * iteration to zero.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Thus, no initializer would be changed by default.
       * </pre>
       *
       * <code>optional .GraphProto initialization = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> 
          internalGetInitializationFieldBuilder() {
        if (initializationBuilder_ == null) {
          initializationBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder>(
                  getInitialization(),
                  getParentForChildren(),
                  isClean());
          initialization_ = null;
        }
        return initializationBuilder_;
      }

      private Onnx.GraphProto algorithm_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> algorithmBuilder_;
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       * @return Whether the algorithm field is set.
       */
      public boolean hasAlgorithm() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       * @return The algorithm.
       */
      public Onnx.GraphProto getAlgorithm() {
        if (algorithmBuilder_ == null) {
          return algorithm_ == null ? Onnx.GraphProto.getDefaultInstance() : algorithm_;
        } else {
          return algorithmBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Builder setAlgorithm(Onnx.GraphProto value) {
        if (algorithmBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          algorithm_ = value;
        } else {
          algorithmBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Builder setAlgorithm(
          Onnx.GraphProto.Builder builderForValue) {
        if (algorithmBuilder_ == null) {
          algorithm_ = builderForValue.build();
        } else {
          algorithmBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Builder mergeAlgorithm(Onnx.GraphProto value) {
        if (algorithmBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            algorithm_ != null &&
            algorithm_ != Onnx.GraphProto.getDefaultInstance()) {
            getAlgorithmBuilder().mergeFrom(value);
          } else {
            algorithm_ = value;
          }
        } else {
          algorithmBuilder_.mergeFrom(value);
        }
        if (algorithm_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Builder clearAlgorithm() {
        bitField0_ = (bitField0_ & ~0x00000002);
        algorithm_ = null;
        if (algorithmBuilder_ != null) {
          algorithmBuilder_.dispose();
          algorithmBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Onnx.GraphProto.Builder getAlgorithmBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return internalGetAlgorithmFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      public Onnx.GraphProtoOrBuilder getAlgorithmOrBuilder() {
        if (algorithmBuilder_ != null) {
          return algorithmBuilder_.getMessageOrBuilder();
        } else {
          return algorithm_ == null ?
              Onnx.GraphProto.getDefaultInstance() : algorithm_;
        }
      }
      /**
       * <pre>
       * This field represents a training algorithm step. Given required inputs,
       * it computes outputs to update initializers in its own or inference graph's
       * initializer lists. In general, this field contains loss node, gradient node,
       * optimizer node, increment of iteration count.
       *
       * An execution of the training algorithm step is performed by executing the
       * graph obtained by combining the inference graph (namely "ModelProto.graph")
       * and the "algorithm" graph. That is, the actual
       * input/initializer/output/node/value_info/sparse_initializer list of
       * the training graph is the concatenation of
       * "ModelProto.graph.input/initializer/output/node/value_info/sparse_initializer"
       * and "algorithm.input/initializer/output/node/value_info/sparse_initializer"
       * in that order. This combined graph must satisfy the normal ONNX conditions.
       * Now, let's provide a visualization of graph combination for clarity.
       * Let the inference graph (i.e., "ModelProto.graph") be
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d
       * and the "algorithm" graph be
       * tensor_d -&gt; Add -&gt; tensor_e
       * The combination process results
       * tensor_a, tensor_b -&gt; MatMul -&gt; tensor_c -&gt; Sigmoid -&gt; tensor_d -&gt; Add -&gt; tensor_e
       *
       * Notice that an input of a node in the "algorithm" graph may reference the
       * output of a node in the inference graph (but not the other way round). Also, inference
       * node cannot reference inputs of "algorithm". With these restrictions, inference graph
       * can always be run independently without training information.
       *
       * By default, this field is an empty graph and its evaluation does not
       * produce any output. Evaluating the default training step never
       * update any initializers.
       * </pre>
       *
       * <code>optional .GraphProto algorithm = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> 
          internalGetAlgorithmFieldBuilder() {
        if (algorithmBuilder_ == null) {
          algorithmBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder>(
                  getAlgorithm(),
                  getParentForChildren(),
                  isClean());
          algorithm_ = null;
        }
        return algorithmBuilder_;
      }

      private java.util.List<Onnx.StringStringEntryProto> initializationBinding_ =
        java.util.Collections.emptyList();
      private void ensureInitializationBindingIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          initializationBinding_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(initializationBinding_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> initializationBindingBuilder_;

      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getInitializationBindingList() {
        if (initializationBindingBuilder_ == null) {
          return java.util.Collections.unmodifiableList(initializationBinding_);
        } else {
          return initializationBindingBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public int getInitializationBindingCount() {
        if (initializationBindingBuilder_ == null) {
          return initializationBinding_.size();
        } else {
          return initializationBindingBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Onnx.StringStringEntryProto getInitializationBinding(int index) {
        if (initializationBindingBuilder_ == null) {
          return initializationBinding_.get(index);
        } else {
          return initializationBindingBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder setInitializationBinding(
          int index, Onnx.StringStringEntryProto value) {
        if (initializationBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializationBindingIsMutable();
          initializationBinding_.set(index, value);
          onChanged();
        } else {
          initializationBindingBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder setInitializationBinding(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (initializationBindingBuilder_ == null) {
          ensureInitializationBindingIsMutable();
          initializationBinding_.set(index, builderForValue.build());
          onChanged();
        } else {
          initializationBindingBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder addInitializationBinding(Onnx.StringStringEntryProto value) {
        if (initializationBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializationBindingIsMutable();
          initializationBinding_.add(value);
          onChanged();
        } else {
          initializationBindingBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder addInitializationBinding(
          int index, Onnx.StringStringEntryProto value) {
        if (initializationBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializationBindingIsMutable();
          initializationBinding_.add(index, value);
          onChanged();
        } else {
          initializationBindingBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder addInitializationBinding(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (initializationBindingBuilder_ == null) {
          ensureInitializationBindingIsMutable();
          initializationBinding_.add(builderForValue.build());
          onChanged();
        } else {
          initializationBindingBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder addInitializationBinding(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (initializationBindingBuilder_ == null) {
          ensureInitializationBindingIsMutable();
          initializationBinding_.add(index, builderForValue.build());
          onChanged();
        } else {
          initializationBindingBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder addAllInitializationBinding(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (initializationBindingBuilder_ == null) {
          ensureInitializationBindingIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, initializationBinding_);
          onChanged();
        } else {
          initializationBindingBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder clearInitializationBinding() {
        if (initializationBindingBuilder_ == null) {
          initializationBinding_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          initializationBindingBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Builder removeInitializationBinding(int index) {
        if (initializationBindingBuilder_ == null) {
          ensureInitializationBindingIsMutable();
          initializationBinding_.remove(index);
          onChanged();
        } else {
          initializationBindingBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Onnx.StringStringEntryProto.Builder getInitializationBindingBuilder(
          int index) {
        return internalGetInitializationBindingFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getInitializationBindingOrBuilder(
          int index) {
        if (initializationBindingBuilder_ == null) {
          return initializationBinding_.get(index);  } else {
          return initializationBindingBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getInitializationBindingOrBuilderList() {
        if (initializationBindingBuilder_ != null) {
          return initializationBindingBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(initializationBinding_);
        }
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Onnx.StringStringEntryProto.Builder addInitializationBindingBuilder() {
        return internalGetInitializationBindingFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public Onnx.StringStringEntryProto.Builder addInitializationBindingBuilder(
          int index) {
        return internalGetInitializationBindingFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * This field specifies the bindings from the outputs of "initialization" to
       * some initializers in "ModelProto.graph.initializer" and
       * the "algorithm.initializer" in the same TrainingInfoProto.
       * See "update_binding" below for details.
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "initialization".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto initialization_binding = 3;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getInitializationBindingBuilderList() {
        return internalGetInitializationBindingFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetInitializationBindingFieldBuilder() {
        if (initializationBindingBuilder_ == null) {
          initializationBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  initializationBinding_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          initializationBinding_ = null;
        }
        return initializationBindingBuilder_;
      }

      private java.util.List<Onnx.StringStringEntryProto> updateBinding_ =
        java.util.Collections.emptyList();
      private void ensureUpdateBindingIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          updateBinding_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(updateBinding_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> updateBindingBuilder_;

      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getUpdateBindingList() {
        if (updateBindingBuilder_ == null) {
          return java.util.Collections.unmodifiableList(updateBinding_);
        } else {
          return updateBindingBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public int getUpdateBindingCount() {
        if (updateBindingBuilder_ == null) {
          return updateBinding_.size();
        } else {
          return updateBindingBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Onnx.StringStringEntryProto getUpdateBinding(int index) {
        if (updateBindingBuilder_ == null) {
          return updateBinding_.get(index);
        } else {
          return updateBindingBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder setUpdateBinding(
          int index, Onnx.StringStringEntryProto value) {
        if (updateBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUpdateBindingIsMutable();
          updateBinding_.set(index, value);
          onChanged();
        } else {
          updateBindingBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder setUpdateBinding(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (updateBindingBuilder_ == null) {
          ensureUpdateBindingIsMutable();
          updateBinding_.set(index, builderForValue.build());
          onChanged();
        } else {
          updateBindingBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder addUpdateBinding(Onnx.StringStringEntryProto value) {
        if (updateBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUpdateBindingIsMutable();
          updateBinding_.add(value);
          onChanged();
        } else {
          updateBindingBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder addUpdateBinding(
          int index, Onnx.StringStringEntryProto value) {
        if (updateBindingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUpdateBindingIsMutable();
          updateBinding_.add(index, value);
          onChanged();
        } else {
          updateBindingBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder addUpdateBinding(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (updateBindingBuilder_ == null) {
          ensureUpdateBindingIsMutable();
          updateBinding_.add(builderForValue.build());
          onChanged();
        } else {
          updateBindingBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder addUpdateBinding(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (updateBindingBuilder_ == null) {
          ensureUpdateBindingIsMutable();
          updateBinding_.add(index, builderForValue.build());
          onChanged();
        } else {
          updateBindingBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder addAllUpdateBinding(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (updateBindingBuilder_ == null) {
          ensureUpdateBindingIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, updateBinding_);
          onChanged();
        } else {
          updateBindingBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder clearUpdateBinding() {
        if (updateBindingBuilder_ == null) {
          updateBinding_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          updateBindingBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Builder removeUpdateBinding(int index) {
        if (updateBindingBuilder_ == null) {
          ensureUpdateBindingIsMutable();
          updateBinding_.remove(index);
          onChanged();
        } else {
          updateBindingBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder getUpdateBindingBuilder(
          int index) {
        return internalGetUpdateBindingFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getUpdateBindingOrBuilder(
          int index) {
        if (updateBindingBuilder_ == null) {
          return updateBinding_.get(index);  } else {
          return updateBindingBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getUpdateBindingOrBuilderList() {
        if (updateBindingBuilder_ != null) {
          return updateBindingBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(updateBinding_);
        }
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder addUpdateBindingBuilder() {
        return internalGetUpdateBindingFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public Onnx.StringStringEntryProto.Builder addUpdateBindingBuilder(
          int index) {
        return internalGetUpdateBindingFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Gradient-based training is usually an iterative procedure. In one gradient
       * descent iteration, we apply
       *
       * x = x - r * g
       *
       * where "x" is the optimized tensor, "r" stands for learning rate, and "g" is
       * gradient of "x" with respect to a chosen loss. To avoid adding assignments
       * into the training graph, we split the update equation into
       *
       * y = x - r * g
       * x = y
       *
       * The user needs to save "y = x - r * g" into TrainingInfoProto.algorithm. To
       * tell that "y" should be assigned to "x", the field "update_binding" may
       * contain a key-value pair of strings, "x" (key of StringStringEntryProto)
       * and "y" (value of StringStringEntryProto).
       * For a neural network with multiple trainable (mutable) tensors, there can
       * be multiple key-value pairs in "update_binding".
       *
       * The initializers appears as keys in "update_binding" are considered
       * mutable variables. This implies some behaviors
       * as described below.
       *
       * 1. We have only unique keys in all "update_binding"s so that two
       * variables may not have the same name. This ensures that one
       * variable is assigned up to once.
       * 2. The keys must appear in names of "ModelProto.graph.initializer" or
       * "TrainingInfoProto.algorithm.initializer".
       * 3. The values must be output names of "algorithm" or "ModelProto.graph.output".
       * 4. Mutable variables are initialized to the value specified by the
       * corresponding initializer, and then potentially updated by
       * "initializer_binding"s and "update_binding"s in "TrainingInfoProto"s.
       *
       * This field usually contains names of trainable tensors
       * (in ModelProto.graph), optimizer states such as momentums in advanced
       * stochastic gradient methods (in TrainingInfoProto.graph),
       * and number of training iterations (in TrainingInfoProto.graph).
       *
       * By default, this field is empty and no initializer would be changed
       * by the execution of "algorithm".
       * </pre>
       *
       * <code>repeated .StringStringEntryProto update_binding = 4;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getUpdateBindingBuilderList() {
        return internalGetUpdateBindingFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetUpdateBindingFieldBuilder() {
        if (updateBindingBuilder_ == null) {
          updateBindingBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  updateBinding_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          updateBinding_ = null;
        }
        return updateBindingBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:TrainingInfoProto)
    }

    // @@protoc_insertion_point(class_scope:TrainingInfoProto)
    private static final Onnx.TrainingInfoProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.TrainingInfoProto();
    }

    public static Onnx.TrainingInfoProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TrainingInfoProto>
        PARSER = new com.google.protobuf.AbstractParser<TrainingInfoProto>() {
      @java.lang.Override
      public TrainingInfoProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TrainingInfoProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TrainingInfoProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.TrainingInfoProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ModelProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:ModelProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     * </pre>
     *
     * <code>optional int64 ir_version = 1;</code>
     * @return Whether the irVersion field is set.
     */
    boolean hasIrVersion();
    /**
     * <pre>
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     * </pre>
     *
     * <code>optional int64 ir_version = 1;</code>
     * @return The irVersion.
     */
    long getIrVersion();

    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    java.util.List<Onnx.OperatorSetIdProto> 
        getOpsetImportList();
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    Onnx.OperatorSetIdProto getOpsetImport(int index);
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    int getOpsetImportCount();
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
        getOpsetImportOrBuilderList();
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
        int index);

    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return Whether the producerName field is set.
     */
    boolean hasProducerName();
    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return The producerName.
     */
    java.lang.String getProducerName();
    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return The bytes for producerName.
     */
    com.google.protobuf.ByteString
        getProducerNameBytes();

    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return Whether the producerVersion field is set.
     */
    boolean hasProducerVersion();
    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return The producerVersion.
     */
    java.lang.String getProducerVersion();
    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return The bytes for producerVersion.
     */
    com.google.protobuf.ByteString
        getProducerVersionBytes();

    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return Whether the domain field is set.
     */
    boolean hasDomain();
    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return The domain.
     */
    java.lang.String getDomain();
    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return The bytes for domain.
     */
    com.google.protobuf.ByteString
        getDomainBytes();

    /**
     * <pre>
     * The version of the graph encoded. See Version enum below.
     * </pre>
     *
     * <code>optional int64 model_version = 5;</code>
     * @return Whether the modelVersion field is set.
     */
    boolean hasModelVersion();
    /**
     * <pre>
     * The version of the graph encoded. See Version enum below.
     * </pre>
     *
     * <code>optional int64 model_version = 5;</code>
     * @return The modelVersion.
     */
    long getModelVersion();

    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     * @return Whether the graph field is set.
     */
    boolean hasGraph();
    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     * @return The graph.
     */
    Onnx.GraphProto getGraph();
    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     */
    Onnx.GraphProtoOrBuilder getGraphOrBuilder();

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);

    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    java.util.List<Onnx.TrainingInfoProto> 
        getTrainingInfoList();
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    Onnx.TrainingInfoProto getTrainingInfo(int index);
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    int getTrainingInfoCount();
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    java.util.List<? extends Onnx.TrainingInfoProtoOrBuilder> 
        getTrainingInfoOrBuilderList();
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    Onnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
        int index);

    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    java.util.List<Onnx.FunctionProto> 
        getFunctionsList();
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    Onnx.FunctionProto getFunctions(int index);
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    int getFunctionsCount();
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    java.util.List<? extends Onnx.FunctionProtoOrBuilder> 
        getFunctionsOrBuilderList();
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    Onnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
        int index);

    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    java.util.List<Onnx.DeviceConfigurationProto> 
        getConfigurationList();
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    Onnx.DeviceConfigurationProto getConfiguration(int index);
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    int getConfigurationCount();
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    java.util.List<? extends Onnx.DeviceConfigurationProtoOrBuilder> 
        getConfigurationOrBuilderList();
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    Onnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Models
   *
   * ModelProto is a top-level file/container format for bundling a ML model and
   * associating its computation graph with metadata.
   *
   * The semantics of the model are described by the associated GraphProto's.
   * </pre>
   *
   * Protobuf type {@code ModelProto}
   */
  public static final class ModelProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:ModelProto)
      ModelProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        ModelProto.class.getName());
    }
    // Use ModelProto.newBuilder() to construct.
    private ModelProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ModelProto() {
      opsetImport_ = java.util.Collections.emptyList();
      producerName_ = "";
      producerVersion_ = "";
      domain_ = "";
      docString_ = "";
      metadataProps_ = java.util.Collections.emptyList();
      trainingInfo_ = java.util.Collections.emptyList();
      functions_ = java.util.Collections.emptyList();
      configuration_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_ModelProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_ModelProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.ModelProto.class, Onnx.ModelProto.Builder.class);
    }

    private int bitField0_;
    public static final int IR_VERSION_FIELD_NUMBER = 1;
    private long irVersion_ = 0L;
    /**
     * <pre>
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     * </pre>
     *
     * <code>optional int64 ir_version = 1;</code>
     * @return Whether the irVersion field is set.
     */
    @java.lang.Override
    public boolean hasIrVersion() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The version of the IR this model targets. See Version enum above.
     * This field MUST be present.
     * </pre>
     *
     * <code>optional int64 ir_version = 1;</code>
     * @return The irVersion.
     */
    @java.lang.Override
    public long getIrVersion() {
      return irVersion_;
    }

    public static final int OPSET_IMPORT_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.OperatorSetIdProto> opsetImport_;
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.OperatorSetIdProto> getOpsetImportList() {
      return opsetImport_;
    }
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
        getOpsetImportOrBuilderList() {
      return opsetImport_;
    }
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    @java.lang.Override
    public int getOpsetImportCount() {
      return opsetImport_.size();
    }
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    @java.lang.Override
    public Onnx.OperatorSetIdProto getOpsetImport(int index) {
      return opsetImport_.get(index);
    }
    /**
     * <pre>
     * The OperatorSets this model relies on.
     * All ModelProtos MUST have at least one entry that
     * specifies which version of the ONNX OperatorSet is
     * being imported.
     *
     * All nodes in the ModelProto's graph will bind against the operator
     * with the same-domain/same-op_type operator with the HIGHEST version
     * in the referenced operator sets.
     * </pre>
     *
     * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
     */
    @java.lang.Override
    public Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
        int index) {
      return opsetImport_.get(index);
    }

    public static final int PRODUCER_NAME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object producerName_ = "";
    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return Whether the producerName field is set.
     */
    @java.lang.Override
    public boolean hasProducerName() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return The producerName.
     */
    @java.lang.Override
    public java.lang.String getProducerName() {
      java.lang.Object ref = producerName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          producerName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_name = 2;</code>
     * @return The bytes for producerName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getProducerNameBytes() {
      java.lang.Object ref = producerName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        producerName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PRODUCER_VERSION_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object producerVersion_ = "";
    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return Whether the producerVersion field is set.
     */
    @java.lang.Override
    public boolean hasProducerVersion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return The producerVersion.
     */
    @java.lang.Override
    public java.lang.String getProducerVersion() {
      java.lang.Object ref = producerVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          producerVersion_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The version of the framework or tool used to generate this model.
     * This field SHOULD be present to indicate which implementation/tool/framework
     * emitted the model.
     * </pre>
     *
     * <code>optional string producer_version = 3;</code>
     * @return The bytes for producerVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getProducerVersionBytes() {
      java.lang.Object ref = producerVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        producerVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DOMAIN_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object domain_ = "";
    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return Whether the domain field is set.
     */
    @java.lang.Override
    public boolean hasDomain() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return The domain.
     */
    @java.lang.Override
    public java.lang.String getDomain() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          domain_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Domain name of the model.
     * We use reverse domain names as name space indicators. For example:
     * `com.facebook.fair` or `com.microsoft.cognitiveservices`
     *
     * Together with `model_version` and GraphProto.name, this forms the unique identity of
     * the graph.
     * </pre>
     *
     * <code>optional string domain = 4;</code>
     * @return The bytes for domain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDomainBytes() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        domain_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MODEL_VERSION_FIELD_NUMBER = 5;
    private long modelVersion_ = 0L;
    /**
     * <pre>
     * The version of the graph encoded. See Version enum below.
     * </pre>
     *
     * <code>optional int64 model_version = 5;</code>
     * @return Whether the modelVersion field is set.
     */
    @java.lang.Override
    public boolean hasModelVersion() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The version of the graph encoded. See Version enum below.
     * </pre>
     *
     * <code>optional int64 model_version = 5;</code>
     * @return The modelVersion.
     */
    @java.lang.Override
    public long getModelVersion() {
      return modelVersion_;
    }

    public static final int DOC_STRING_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this model. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 6;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int GRAPH_FIELD_NUMBER = 7;
    private Onnx.GraphProto graph_;
    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     * @return Whether the graph field is set.
     */
    @java.lang.Override
    public boolean hasGraph() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     * @return The graph.
     */
    @java.lang.Override
    public Onnx.GraphProto getGraph() {
      return graph_ == null ? Onnx.GraphProto.getDefaultInstance() : graph_;
    }
    /**
     * <pre>
     * The parameterized graph that is evaluated to execute the model.
     * </pre>
     *
     * <code>optional .GraphProto graph = 7;</code>
     */
    @java.lang.Override
    public Onnx.GraphProtoOrBuilder getGraphOrBuilder() {
      return graph_ == null ? Onnx.GraphProto.getDefaultInstance() : graph_;
    }

    public static final int METADATA_PROPS_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    public static final int TRAINING_INFO_FIELD_NUMBER = 20;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TrainingInfoProto> trainingInfo_;
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TrainingInfoProto> getTrainingInfoList() {
      return trainingInfo_;
    }
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TrainingInfoProtoOrBuilder> 
        getTrainingInfoOrBuilderList() {
      return trainingInfo_;
    }
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    @java.lang.Override
    public int getTrainingInfoCount() {
      return trainingInfo_.size();
    }
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    @java.lang.Override
    public Onnx.TrainingInfoProto getTrainingInfo(int index) {
      return trainingInfo_.get(index);
    }
    /**
     * <pre>
     * Training-specific information. Sequentially executing all stored
     * `TrainingInfoProto.algorithm`s and assigning their outputs following
     * the corresponding `TrainingInfoProto.update_binding`s is one training
     * iteration. Similarly, to initialize the model
     * (as if training hasn't happened), the user should sequentially execute
     * all stored `TrainingInfoProto.initialization`s and assigns their outputs
     * using `TrainingInfoProto.initialization_binding`s.
     *
     * If this field is empty, the training behavior of the model is undefined.
     * </pre>
     *
     * <code>repeated .TrainingInfoProto training_info = 20;</code>
     */
    @java.lang.Override
    public Onnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
        int index) {
      return trainingInfo_.get(index);
    }

    public static final int FUNCTIONS_FIELD_NUMBER = 25;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.FunctionProto> functions_;
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.FunctionProto> getFunctionsList() {
      return functions_;
    }
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.FunctionProtoOrBuilder> 
        getFunctionsOrBuilderList() {
      return functions_;
    }
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    @java.lang.Override
    public int getFunctionsCount() {
      return functions_.size();
    }
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    @java.lang.Override
    public Onnx.FunctionProto getFunctions(int index) {
      return functions_.get(index);
    }
    /**
     * <pre>
     * A list of function protos local to the model.
     *
     * The (domain, name, overload) tuple must be unique across the function protos in this list.
     * In case of any conflicts the behavior (whether the model local functions are given higher priority,
     * or standard operator sets are given higher priority or this is treated as error) is defined by
     * the runtimes.
     *
     * The operator sets imported by FunctionProto should be compatible with the ones
     * imported by ModelProto and other model local FunctionProtos.
     * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
     * or by 2 FunctionProtos then versions for the operator set may be different but,
     * the operator schema returned for op_type, domain, version combination
     * for both the versions should be same for every node in the function body.
     *
     * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
     * is not allowed.
     * </pre>
     *
     * <code>repeated .FunctionProto functions = 25;</code>
     */
    @java.lang.Override
    public Onnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
        int index) {
      return functions_.get(index);
    }

    public static final int CONFIGURATION_FIELD_NUMBER = 26;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.DeviceConfigurationProto> configuration_;
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.DeviceConfigurationProto> getConfigurationList() {
      return configuration_;
    }
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.DeviceConfigurationProtoOrBuilder> 
        getConfigurationOrBuilderList() {
      return configuration_;
    }
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    @java.lang.Override
    public int getConfigurationCount() {
      return configuration_.size();
    }
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    @java.lang.Override
    public Onnx.DeviceConfigurationProto getConfiguration(int index) {
      return configuration_.get(index);
    }
    /**
     * <pre>
     * Describes different target configurations for a multi-device use case.
     * A model MAY describe multiple multi-device configurations for execution.
     * </pre>
     *
     * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
     */
    @java.lang.Override
    public Onnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
        int index) {
      return configuration_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt64(1, irVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, producerName_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, producerVersion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, domain_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt64(5, modelVersion_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, docString_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getGraph());
      }
      for (int i = 0; i < opsetImport_.size(); i++) {
        output.writeMessage(8, opsetImport_.get(i));
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(14, metadataProps_.get(i));
      }
      for (int i = 0; i < trainingInfo_.size(); i++) {
        output.writeMessage(20, trainingInfo_.get(i));
      }
      for (int i = 0; i < functions_.size(); i++) {
        output.writeMessage(25, functions_.get(i));
      }
      for (int i = 0; i < configuration_.size(); i++) {
        output.writeMessage(26, configuration_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, irVersion_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, producerName_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(3, producerVersion_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(4, domain_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, modelVersion_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, docString_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getGraph());
      }
      for (int i = 0; i < opsetImport_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, opsetImport_.get(i));
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, metadataProps_.get(i));
      }
      for (int i = 0; i < trainingInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(20, trainingInfo_.get(i));
      }
      for (int i = 0; i < functions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, functions_.get(i));
      }
      for (int i = 0; i < configuration_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(26, configuration_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.ModelProto)) {
        return super.equals(obj);
      }
      Onnx.ModelProto other = (Onnx.ModelProto) obj;

      if (hasIrVersion() != other.hasIrVersion()) return false;
      if (hasIrVersion()) {
        if (getIrVersion()
            != other.getIrVersion()) return false;
      }
      if (!getOpsetImportList()
          .equals(other.getOpsetImportList())) return false;
      if (hasProducerName() != other.hasProducerName()) return false;
      if (hasProducerName()) {
        if (!getProducerName()
            .equals(other.getProducerName())) return false;
      }
      if (hasProducerVersion() != other.hasProducerVersion()) return false;
      if (hasProducerVersion()) {
        if (!getProducerVersion()
            .equals(other.getProducerVersion())) return false;
      }
      if (hasDomain() != other.hasDomain()) return false;
      if (hasDomain()) {
        if (!getDomain()
            .equals(other.getDomain())) return false;
      }
      if (hasModelVersion() != other.hasModelVersion()) return false;
      if (hasModelVersion()) {
        if (getModelVersion()
            != other.getModelVersion()) return false;
      }
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (hasGraph() != other.hasGraph()) return false;
      if (hasGraph()) {
        if (!getGraph()
            .equals(other.getGraph())) return false;
      }
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getTrainingInfoList()
          .equals(other.getTrainingInfoList())) return false;
      if (!getFunctionsList()
          .equals(other.getFunctionsList())) return false;
      if (!getConfigurationList()
          .equals(other.getConfigurationList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasIrVersion()) {
        hash = (37 * hash) + IR_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getIrVersion());
      }
      if (getOpsetImportCount() > 0) {
        hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;
        hash = (53 * hash) + getOpsetImportList().hashCode();
      }
      if (hasProducerName()) {
        hash = (37 * hash) + PRODUCER_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getProducerName().hashCode();
      }
      if (hasProducerVersion()) {
        hash = (37 * hash) + PRODUCER_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getProducerVersion().hashCode();
      }
      if (hasDomain()) {
        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
        hash = (53 * hash) + getDomain().hashCode();
      }
      if (hasModelVersion()) {
        hash = (37 * hash) + MODEL_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getModelVersion());
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (hasGraph()) {
        hash = (37 * hash) + GRAPH_FIELD_NUMBER;
        hash = (53 * hash) + getGraph().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      if (getTrainingInfoCount() > 0) {
        hash = (37 * hash) + TRAINING_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getTrainingInfoList().hashCode();
      }
      if (getFunctionsCount() > 0) {
        hash = (37 * hash) + FUNCTIONS_FIELD_NUMBER;
        hash = (53 * hash) + getFunctionsList().hashCode();
      }
      if (getConfigurationCount() > 0) {
        hash = (37 * hash) + CONFIGURATION_FIELD_NUMBER;
        hash = (53 * hash) + getConfigurationList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.ModelProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ModelProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ModelProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ModelProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ModelProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.ModelProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.ModelProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ModelProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.ModelProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.ModelProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.ModelProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.ModelProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.ModelProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Models
     *
     * ModelProto is a top-level file/container format for bundling a ML model and
     * associating its computation graph with metadata.
     *
     * The semantics of the model are described by the associated GraphProto's.
     * </pre>
     *
     * Protobuf type {@code ModelProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:ModelProto)
        Onnx.ModelProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_ModelProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_ModelProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.ModelProto.class, Onnx.ModelProto.Builder.class);
      }

      // Construct using Onnx.ModelProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetOpsetImportFieldBuilder();
          internalGetGraphFieldBuilder();
          internalGetMetadataPropsFieldBuilder();
          internalGetTrainingInfoFieldBuilder();
          internalGetFunctionsFieldBuilder();
          internalGetConfigurationFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        irVersion_ = 0L;
        if (opsetImportBuilder_ == null) {
          opsetImport_ = java.util.Collections.emptyList();
        } else {
          opsetImport_ = null;
          opsetImportBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        producerName_ = "";
        producerVersion_ = "";
        domain_ = "";
        modelVersion_ = 0L;
        docString_ = "";
        graph_ = null;
        if (graphBuilder_ != null) {
          graphBuilder_.dispose();
          graphBuilder_ = null;
        }
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (trainingInfoBuilder_ == null) {
          trainingInfo_ = java.util.Collections.emptyList();
        } else {
          trainingInfo_ = null;
          trainingInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (functionsBuilder_ == null) {
          functions_ = java.util.Collections.emptyList();
        } else {
          functions_ = null;
          functionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        if (configurationBuilder_ == null) {
          configuration_ = java.util.Collections.emptyList();
        } else {
          configuration_ = null;
          configurationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_ModelProto_descriptor;
      }

      @java.lang.Override
      public Onnx.ModelProto getDefaultInstanceForType() {
        return Onnx.ModelProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.ModelProto build() {
        Onnx.ModelProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.ModelProto buildPartial() {
        Onnx.ModelProto result = new Onnx.ModelProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.ModelProto result) {
        if (opsetImportBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.opsetImport_ = opsetImport_;
        } else {
          result.opsetImport_ = opsetImportBuilder_.build();
        }
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
        if (trainingInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            trainingInfo_ = java.util.Collections.unmodifiableList(trainingInfo_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.trainingInfo_ = trainingInfo_;
        } else {
          result.trainingInfo_ = trainingInfoBuilder_.build();
        }
        if (functionsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            functions_ = java.util.Collections.unmodifiableList(functions_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.functions_ = functions_;
        } else {
          result.functions_ = functionsBuilder_.build();
        }
        if (configurationBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0)) {
            configuration_ = java.util.Collections.unmodifiableList(configuration_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.configuration_ = configuration_;
        } else {
          result.configuration_ = configurationBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.ModelProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.irVersion_ = irVersion_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.producerName_ = producerName_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.producerVersion_ = producerVersion_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.domain_ = domain_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.modelVersion_ = modelVersion_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.graph_ = graphBuilder_ == null
              ? graph_
              : graphBuilder_.build();
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.ModelProto) {
          return mergeFrom((Onnx.ModelProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.ModelProto other) {
        if (other == Onnx.ModelProto.getDefaultInstance()) return this;
        if (other.hasIrVersion()) {
          setIrVersion(other.getIrVersion());
        }
        if (opsetImportBuilder_ == null) {
          if (!other.opsetImport_.isEmpty()) {
            if (opsetImport_.isEmpty()) {
              opsetImport_ = other.opsetImport_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureOpsetImportIsMutable();
              opsetImport_.addAll(other.opsetImport_);
            }
            onChanged();
          }
        } else {
          if (!other.opsetImport_.isEmpty()) {
            if (opsetImportBuilder_.isEmpty()) {
              opsetImportBuilder_.dispose();
              opsetImportBuilder_ = null;
              opsetImport_ = other.opsetImport_;
              bitField0_ = (bitField0_ & ~0x00000002);
              opsetImportBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetOpsetImportFieldBuilder() : null;
            } else {
              opsetImportBuilder_.addAllMessages(other.opsetImport_);
            }
          }
        }
        if (other.hasProducerName()) {
          producerName_ = other.producerName_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasProducerVersion()) {
          producerVersion_ = other.producerVersion_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasDomain()) {
          domain_ = other.domain_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (other.hasModelVersion()) {
          setModelVersion(other.getModelVersion());
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (other.hasGraph()) {
          mergeGraph(other.getGraph());
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000100);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        if (trainingInfoBuilder_ == null) {
          if (!other.trainingInfo_.isEmpty()) {
            if (trainingInfo_.isEmpty()) {
              trainingInfo_ = other.trainingInfo_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureTrainingInfoIsMutable();
              trainingInfo_.addAll(other.trainingInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.trainingInfo_.isEmpty()) {
            if (trainingInfoBuilder_.isEmpty()) {
              trainingInfoBuilder_.dispose();
              trainingInfoBuilder_ = null;
              trainingInfo_ = other.trainingInfo_;
              bitField0_ = (bitField0_ & ~0x00000200);
              trainingInfoBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetTrainingInfoFieldBuilder() : null;
            } else {
              trainingInfoBuilder_.addAllMessages(other.trainingInfo_);
            }
          }
        }
        if (functionsBuilder_ == null) {
          if (!other.functions_.isEmpty()) {
            if (functions_.isEmpty()) {
              functions_ = other.functions_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureFunctionsIsMutable();
              functions_.addAll(other.functions_);
            }
            onChanged();
          }
        } else {
          if (!other.functions_.isEmpty()) {
            if (functionsBuilder_.isEmpty()) {
              functionsBuilder_.dispose();
              functionsBuilder_ = null;
              functions_ = other.functions_;
              bitField0_ = (bitField0_ & ~0x00000400);
              functionsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetFunctionsFieldBuilder() : null;
            } else {
              functionsBuilder_.addAllMessages(other.functions_);
            }
          }
        }
        if (configurationBuilder_ == null) {
          if (!other.configuration_.isEmpty()) {
            if (configuration_.isEmpty()) {
              configuration_ = other.configuration_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureConfigurationIsMutable();
              configuration_.addAll(other.configuration_);
            }
            onChanged();
          }
        } else {
          if (!other.configuration_.isEmpty()) {
            if (configurationBuilder_.isEmpty()) {
              configurationBuilder_.dispose();
              configurationBuilder_ = null;
              configuration_ = other.configuration_;
              bitField0_ = (bitField0_ & ~0x00000800);
              configurationBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetConfigurationFieldBuilder() : null;
            } else {
              configurationBuilder_.addAllMessages(other.configuration_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                irVersion_ = input.readInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                producerName_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 18
              case 26: {
                producerVersion_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 26
              case 34: {
                domain_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 34
              case 40: {
                modelVersion_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 50: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    internalGetGraphFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 58
              case 66: {
                Onnx.OperatorSetIdProto m =
                    input.readMessage(
                        Onnx.OperatorSetIdProto.parser(),
                        extensionRegistry);
                if (opsetImportBuilder_ == null) {
                  ensureOpsetImportIsMutable();
                  opsetImport_.add(m);
                } else {
                  opsetImportBuilder_.addMessage(m);
                }
                break;
              } // case 66
              case 114: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 114
              case 162: {
                Onnx.TrainingInfoProto m =
                    input.readMessage(
                        Onnx.TrainingInfoProto.parser(),
                        extensionRegistry);
                if (trainingInfoBuilder_ == null) {
                  ensureTrainingInfoIsMutable();
                  trainingInfo_.add(m);
                } else {
                  trainingInfoBuilder_.addMessage(m);
                }
                break;
              } // case 162
              case 202: {
                Onnx.FunctionProto m =
                    input.readMessage(
                        Onnx.FunctionProto.parser(),
                        extensionRegistry);
                if (functionsBuilder_ == null) {
                  ensureFunctionsIsMutable();
                  functions_.add(m);
                } else {
                  functionsBuilder_.addMessage(m);
                }
                break;
              } // case 202
              case 210: {
                Onnx.DeviceConfigurationProto m =
                    input.readMessage(
                        Onnx.DeviceConfigurationProto.parser(),
                        extensionRegistry);
                if (configurationBuilder_ == null) {
                  ensureConfigurationIsMutable();
                  configuration_.add(m);
                } else {
                  configurationBuilder_.addMessage(m);
                }
                break;
              } // case 210
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long irVersion_ ;
      /**
       * <pre>
       * The version of the IR this model targets. See Version enum above.
       * This field MUST be present.
       * </pre>
       *
       * <code>optional int64 ir_version = 1;</code>
       * @return Whether the irVersion field is set.
       */
      @java.lang.Override
      public boolean hasIrVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The version of the IR this model targets. See Version enum above.
       * This field MUST be present.
       * </pre>
       *
       * <code>optional int64 ir_version = 1;</code>
       * @return The irVersion.
       */
      @java.lang.Override
      public long getIrVersion() {
        return irVersion_;
      }
      /**
       * <pre>
       * The version of the IR this model targets. See Version enum above.
       * This field MUST be present.
       * </pre>
       *
       * <code>optional int64 ir_version = 1;</code>
       * @param value The irVersion to set.
       * @return This builder for chaining.
       */
      public Builder setIrVersion(long value) {

        irVersion_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the IR this model targets. See Version enum above.
       * This field MUST be present.
       * </pre>
       *
       * <code>optional int64 ir_version = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearIrVersion() {
        bitField0_ = (bitField0_ & ~0x00000001);
        irVersion_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.OperatorSetIdProto> opsetImport_ =
        java.util.Collections.emptyList();
      private void ensureOpsetImportIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          opsetImport_ = new java.util.ArrayList<Onnx.OperatorSetIdProto>(opsetImport_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;

      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public java.util.List<Onnx.OperatorSetIdProto> getOpsetImportList() {
        if (opsetImportBuilder_ == null) {
          return java.util.Collections.unmodifiableList(opsetImport_);
        } else {
          return opsetImportBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public int getOpsetImportCount() {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.size();
        } else {
          return opsetImportBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Onnx.OperatorSetIdProto getOpsetImport(int index) {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.get(index);
        } else {
          return opsetImportBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder setOpsetImport(
          int index, Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.set(index, value);
          onChanged();
        } else {
          opsetImportBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder setOpsetImport(
          int index, Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.set(index, builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder addOpsetImport(Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.add(value);
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder addOpsetImport(
          int index, Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.add(index, value);
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder addOpsetImport(
          Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.add(builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder addOpsetImport(
          int index, Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.add(index, builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder addAllOpsetImport(
          java.lang.Iterable<? extends Onnx.OperatorSetIdProto> values) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, opsetImport_);
          onChanged();
        } else {
          opsetImportBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder clearOpsetImport() {
        if (opsetImportBuilder_ == null) {
          opsetImport_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          opsetImportBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Builder removeOpsetImport(int index) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.remove(index);
          onChanged();
        } else {
          opsetImportBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Onnx.OperatorSetIdProto.Builder getOpsetImportBuilder(
          int index) {
        return internalGetOpsetImportFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
          int index) {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.get(index);  } else {
          return opsetImportBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
           getOpsetImportOrBuilderList() {
        if (opsetImportBuilder_ != null) {
          return opsetImportBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(opsetImport_);
        }
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Onnx.OperatorSetIdProto.Builder addOpsetImportBuilder() {
        return internalGetOpsetImportFieldBuilder().addBuilder(
            Onnx.OperatorSetIdProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public Onnx.OperatorSetIdProto.Builder addOpsetImportBuilder(
          int index) {
        return internalGetOpsetImportFieldBuilder().addBuilder(
            index, Onnx.OperatorSetIdProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The OperatorSets this model relies on.
       * All ModelProtos MUST have at least one entry that
       * specifies which version of the ONNX OperatorSet is
       * being imported.
       *
       * All nodes in the ModelProto's graph will bind against the operator
       * with the same-domain/same-op_type operator with the HIGHEST version
       * in the referenced operator sets.
       * </pre>
       *
       * <code>repeated .OperatorSetIdProto opset_import = 8;</code>
       */
      public java.util.List<Onnx.OperatorSetIdProto.Builder> 
           getOpsetImportBuilderList() {
        return internalGetOpsetImportFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder> 
          internalGetOpsetImportFieldBuilder() {
        if (opsetImportBuilder_ == null) {
          opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder>(
                  opsetImport_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          opsetImport_ = null;
        }
        return opsetImportBuilder_;
      }

      private java.lang.Object producerName_ = "";
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @return Whether the producerName field is set.
       */
      public boolean hasProducerName() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @return The producerName.
       */
      public java.lang.String getProducerName() {
        java.lang.Object ref = producerName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            producerName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @return The bytes for producerName.
       */
      public com.google.protobuf.ByteString
          getProducerNameBytes() {
        java.lang.Object ref = producerName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          producerName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @param value The producerName to set.
       * @return This builder for chaining.
       */
      public Builder setProducerName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        producerName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearProducerName() {
        producerName_ = getDefaultInstance().getProducerName();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_name = 2;</code>
       * @param value The bytes for producerName to set.
       * @return This builder for chaining.
       */
      public Builder setProducerNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        producerName_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object producerVersion_ = "";
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @return Whether the producerVersion field is set.
       */
      public boolean hasProducerVersion() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @return The producerVersion.
       */
      public java.lang.String getProducerVersion() {
        java.lang.Object ref = producerVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            producerVersion_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @return The bytes for producerVersion.
       */
      public com.google.protobuf.ByteString
          getProducerVersionBytes() {
        java.lang.Object ref = producerVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          producerVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @param value The producerVersion to set.
       * @return This builder for chaining.
       */
      public Builder setProducerVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        producerVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearProducerVersion() {
        producerVersion_ = getDefaultInstance().getProducerVersion();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the framework or tool used to generate this model.
       * This field SHOULD be present to indicate which implementation/tool/framework
       * emitted the model.
       * </pre>
       *
       * <code>optional string producer_version = 3;</code>
       * @param value The bytes for producerVersion to set.
       * @return This builder for chaining.
       */
      public Builder setProducerVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        producerVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.lang.Object domain_ = "";
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @return Whether the domain field is set.
       */
      public boolean hasDomain() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @return The domain.
       */
      public java.lang.String getDomain() {
        java.lang.Object ref = domain_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            domain_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @return The bytes for domain.
       */
      public com.google.protobuf.ByteString
          getDomainBytes() {
        java.lang.Object ref = domain_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          domain_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @param value The domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomain(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDomain() {
        domain_ = getDefaultInstance().getDomain();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Domain name of the model.
       * We use reverse domain names as name space indicators. For example:
       * `com.facebook.fair` or `com.microsoft.cognitiveservices`
       *
       * Together with `model_version` and GraphProto.name, this forms the unique identity of
       * the graph.
       * </pre>
       *
       * <code>optional string domain = 4;</code>
       * @param value The bytes for domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomainBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private long modelVersion_ ;
      /**
       * <pre>
       * The version of the graph encoded. See Version enum below.
       * </pre>
       *
       * <code>optional int64 model_version = 5;</code>
       * @return Whether the modelVersion field is set.
       */
      @java.lang.Override
      public boolean hasModelVersion() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The version of the graph encoded. See Version enum below.
       * </pre>
       *
       * <code>optional int64 model_version = 5;</code>
       * @return The modelVersion.
       */
      @java.lang.Override
      public long getModelVersion() {
        return modelVersion_;
      }
      /**
       * <pre>
       * The version of the graph encoded. See Version enum below.
       * </pre>
       *
       * <code>optional int64 model_version = 5;</code>
       * @param value The modelVersion to set.
       * @return This builder for chaining.
       */
      public Builder setModelVersion(long value) {

        modelVersion_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the graph encoded. See Version enum below.
       * </pre>
       *
       * <code>optional int64 model_version = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearModelVersion() {
        bitField0_ = (bitField0_ & ~0x00000020);
        modelVersion_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this model. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 6;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private Onnx.GraphProto graph_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> graphBuilder_;
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       * @return Whether the graph field is set.
       */
      public boolean hasGraph() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       * @return The graph.
       */
      public Onnx.GraphProto getGraph() {
        if (graphBuilder_ == null) {
          return graph_ == null ? Onnx.GraphProto.getDefaultInstance() : graph_;
        } else {
          return graphBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Builder setGraph(Onnx.GraphProto value) {
        if (graphBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          graph_ = value;
        } else {
          graphBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Builder setGraph(
          Onnx.GraphProto.Builder builderForValue) {
        if (graphBuilder_ == null) {
          graph_ = builderForValue.build();
        } else {
          graphBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Builder mergeGraph(Onnx.GraphProto value) {
        if (graphBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            graph_ != null &&
            graph_ != Onnx.GraphProto.getDefaultInstance()) {
            getGraphBuilder().mergeFrom(value);
          } else {
            graph_ = value;
          }
        } else {
          graphBuilder_.mergeFrom(value);
        }
        if (graph_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Builder clearGraph() {
        bitField0_ = (bitField0_ & ~0x00000080);
        graph_ = null;
        if (graphBuilder_ != null) {
          graphBuilder_.dispose();
          graphBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Onnx.GraphProto.Builder getGraphBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return internalGetGraphFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      public Onnx.GraphProtoOrBuilder getGraphOrBuilder() {
        if (graphBuilder_ != null) {
          return graphBuilder_.getMessageOrBuilder();
        } else {
          return graph_ == null ?
              Onnx.GraphProto.getDefaultInstance() : graph_;
        }
      }
      /**
       * <pre>
       * The parameterized graph that is evaluated to execute the model.
       * </pre>
       *
       * <code>optional .GraphProto graph = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder> 
          internalGetGraphFieldBuilder() {
        if (graphBuilder_ == null) {
          graphBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.GraphProto, Onnx.GraphProto.Builder, Onnx.GraphProtoOrBuilder>(
                  getGraph(),
                  getParentForChildren(),
                  isClean());
          graph_ = null;
        }
        return graphBuilder_;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      private java.util.List<Onnx.TrainingInfoProto> trainingInfo_ =
        java.util.Collections.emptyList();
      private void ensureTrainingInfoIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          trainingInfo_ = new java.util.ArrayList<Onnx.TrainingInfoProto>(trainingInfo_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TrainingInfoProto, Onnx.TrainingInfoProto.Builder, Onnx.TrainingInfoProtoOrBuilder> trainingInfoBuilder_;

      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public java.util.List<Onnx.TrainingInfoProto> getTrainingInfoList() {
        if (trainingInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(trainingInfo_);
        } else {
          return trainingInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public int getTrainingInfoCount() {
        if (trainingInfoBuilder_ == null) {
          return trainingInfo_.size();
        } else {
          return trainingInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Onnx.TrainingInfoProto getTrainingInfo(int index) {
        if (trainingInfoBuilder_ == null) {
          return trainingInfo_.get(index);
        } else {
          return trainingInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder setTrainingInfo(
          int index, Onnx.TrainingInfoProto value) {
        if (trainingInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTrainingInfoIsMutable();
          trainingInfo_.set(index, value);
          onChanged();
        } else {
          trainingInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder setTrainingInfo(
          int index, Onnx.TrainingInfoProto.Builder builderForValue) {
        if (trainingInfoBuilder_ == null) {
          ensureTrainingInfoIsMutable();
          trainingInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          trainingInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder addTrainingInfo(Onnx.TrainingInfoProto value) {
        if (trainingInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTrainingInfoIsMutable();
          trainingInfo_.add(value);
          onChanged();
        } else {
          trainingInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder addTrainingInfo(
          int index, Onnx.TrainingInfoProto value) {
        if (trainingInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTrainingInfoIsMutable();
          trainingInfo_.add(index, value);
          onChanged();
        } else {
          trainingInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder addTrainingInfo(
          Onnx.TrainingInfoProto.Builder builderForValue) {
        if (trainingInfoBuilder_ == null) {
          ensureTrainingInfoIsMutable();
          trainingInfo_.add(builderForValue.build());
          onChanged();
        } else {
          trainingInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder addTrainingInfo(
          int index, Onnx.TrainingInfoProto.Builder builderForValue) {
        if (trainingInfoBuilder_ == null) {
          ensureTrainingInfoIsMutable();
          trainingInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          trainingInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder addAllTrainingInfo(
          java.lang.Iterable<? extends Onnx.TrainingInfoProto> values) {
        if (trainingInfoBuilder_ == null) {
          ensureTrainingInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, trainingInfo_);
          onChanged();
        } else {
          trainingInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder clearTrainingInfo() {
        if (trainingInfoBuilder_ == null) {
          trainingInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          trainingInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Builder removeTrainingInfo(int index) {
        if (trainingInfoBuilder_ == null) {
          ensureTrainingInfoIsMutable();
          trainingInfo_.remove(index);
          onChanged();
        } else {
          trainingInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Onnx.TrainingInfoProto.Builder getTrainingInfoBuilder(
          int index) {
        return internalGetTrainingInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Onnx.TrainingInfoProtoOrBuilder getTrainingInfoOrBuilder(
          int index) {
        if (trainingInfoBuilder_ == null) {
          return trainingInfo_.get(index);  } else {
          return trainingInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public java.util.List<? extends Onnx.TrainingInfoProtoOrBuilder> 
           getTrainingInfoOrBuilderList() {
        if (trainingInfoBuilder_ != null) {
          return trainingInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(trainingInfo_);
        }
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Onnx.TrainingInfoProto.Builder addTrainingInfoBuilder() {
        return internalGetTrainingInfoFieldBuilder().addBuilder(
            Onnx.TrainingInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public Onnx.TrainingInfoProto.Builder addTrainingInfoBuilder(
          int index) {
        return internalGetTrainingInfoFieldBuilder().addBuilder(
            index, Onnx.TrainingInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Training-specific information. Sequentially executing all stored
       * `TrainingInfoProto.algorithm`s and assigning their outputs following
       * the corresponding `TrainingInfoProto.update_binding`s is one training
       * iteration. Similarly, to initialize the model
       * (as if training hasn't happened), the user should sequentially execute
       * all stored `TrainingInfoProto.initialization`s and assigns their outputs
       * using `TrainingInfoProto.initialization_binding`s.
       *
       * If this field is empty, the training behavior of the model is undefined.
       * </pre>
       *
       * <code>repeated .TrainingInfoProto training_info = 20;</code>
       */
      public java.util.List<Onnx.TrainingInfoProto.Builder> 
           getTrainingInfoBuilderList() {
        return internalGetTrainingInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TrainingInfoProto, Onnx.TrainingInfoProto.Builder, Onnx.TrainingInfoProtoOrBuilder> 
          internalGetTrainingInfoFieldBuilder() {
        if (trainingInfoBuilder_ == null) {
          trainingInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TrainingInfoProto, Onnx.TrainingInfoProto.Builder, Onnx.TrainingInfoProtoOrBuilder>(
                  trainingInfo_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          trainingInfo_ = null;
        }
        return trainingInfoBuilder_;
      }

      private java.util.List<Onnx.FunctionProto> functions_ =
        java.util.Collections.emptyList();
      private void ensureFunctionsIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          functions_ = new java.util.ArrayList<Onnx.FunctionProto>(functions_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.FunctionProto, Onnx.FunctionProto.Builder, Onnx.FunctionProtoOrBuilder> functionsBuilder_;

      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public java.util.List<Onnx.FunctionProto> getFunctionsList() {
        if (functionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(functions_);
        } else {
          return functionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public int getFunctionsCount() {
        if (functionsBuilder_ == null) {
          return functions_.size();
        } else {
          return functionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Onnx.FunctionProto getFunctions(int index) {
        if (functionsBuilder_ == null) {
          return functions_.get(index);
        } else {
          return functionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder setFunctions(
          int index, Onnx.FunctionProto value) {
        if (functionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFunctionsIsMutable();
          functions_.set(index, value);
          onChanged();
        } else {
          functionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder setFunctions(
          int index, Onnx.FunctionProto.Builder builderForValue) {
        if (functionsBuilder_ == null) {
          ensureFunctionsIsMutable();
          functions_.set(index, builderForValue.build());
          onChanged();
        } else {
          functionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder addFunctions(Onnx.FunctionProto value) {
        if (functionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFunctionsIsMutable();
          functions_.add(value);
          onChanged();
        } else {
          functionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder addFunctions(
          int index, Onnx.FunctionProto value) {
        if (functionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureFunctionsIsMutable();
          functions_.add(index, value);
          onChanged();
        } else {
          functionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder addFunctions(
          Onnx.FunctionProto.Builder builderForValue) {
        if (functionsBuilder_ == null) {
          ensureFunctionsIsMutable();
          functions_.add(builderForValue.build());
          onChanged();
        } else {
          functionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder addFunctions(
          int index, Onnx.FunctionProto.Builder builderForValue) {
        if (functionsBuilder_ == null) {
          ensureFunctionsIsMutable();
          functions_.add(index, builderForValue.build());
          onChanged();
        } else {
          functionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder addAllFunctions(
          java.lang.Iterable<? extends Onnx.FunctionProto> values) {
        if (functionsBuilder_ == null) {
          ensureFunctionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, functions_);
          onChanged();
        } else {
          functionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder clearFunctions() {
        if (functionsBuilder_ == null) {
          functions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          functionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Builder removeFunctions(int index) {
        if (functionsBuilder_ == null) {
          ensureFunctionsIsMutable();
          functions_.remove(index);
          onChanged();
        } else {
          functionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Onnx.FunctionProto.Builder getFunctionsBuilder(
          int index) {
        return internalGetFunctionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Onnx.FunctionProtoOrBuilder getFunctionsOrBuilder(
          int index) {
        if (functionsBuilder_ == null) {
          return functions_.get(index);  } else {
          return functionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public java.util.List<? extends Onnx.FunctionProtoOrBuilder> 
           getFunctionsOrBuilderList() {
        if (functionsBuilder_ != null) {
          return functionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(functions_);
        }
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Onnx.FunctionProto.Builder addFunctionsBuilder() {
        return internalGetFunctionsFieldBuilder().addBuilder(
            Onnx.FunctionProto.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public Onnx.FunctionProto.Builder addFunctionsBuilder(
          int index) {
        return internalGetFunctionsFieldBuilder().addBuilder(
            index, Onnx.FunctionProto.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of function protos local to the model.
       *
       * The (domain, name, overload) tuple must be unique across the function protos in this list.
       * In case of any conflicts the behavior (whether the model local functions are given higher priority,
       * or standard operator sets are given higher priority or this is treated as error) is defined by
       * the runtimes.
       *
       * The operator sets imported by FunctionProto should be compatible with the ones
       * imported by ModelProto and other model local FunctionProtos.
       * Example, if same operator set say 'A' is imported by a FunctionProto and ModelProto
       * or by 2 FunctionProtos then versions for the operator set may be different but,
       * the operator schema returned for op_type, domain, version combination
       * for both the versions should be same for every node in the function body.
       *
       * One FunctionProto can reference other FunctionProto in the model, however, recursive reference
       * is not allowed.
       * </pre>
       *
       * <code>repeated .FunctionProto functions = 25;</code>
       */
      public java.util.List<Onnx.FunctionProto.Builder> 
           getFunctionsBuilderList() {
        return internalGetFunctionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.FunctionProto, Onnx.FunctionProto.Builder, Onnx.FunctionProtoOrBuilder> 
          internalGetFunctionsFieldBuilder() {
        if (functionsBuilder_ == null) {
          functionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.FunctionProto, Onnx.FunctionProto.Builder, Onnx.FunctionProtoOrBuilder>(
                  functions_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          functions_ = null;
        }
        return functionsBuilder_;
      }

      private java.util.List<Onnx.DeviceConfigurationProto> configuration_ =
        java.util.Collections.emptyList();
      private void ensureConfigurationIsMutable() {
        if (!((bitField0_ & 0x00000800) != 0)) {
          configuration_ = new java.util.ArrayList<Onnx.DeviceConfigurationProto>(configuration_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.DeviceConfigurationProto, Onnx.DeviceConfigurationProto.Builder, Onnx.DeviceConfigurationProtoOrBuilder> configurationBuilder_;

      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public java.util.List<Onnx.DeviceConfigurationProto> getConfigurationList() {
        if (configurationBuilder_ == null) {
          return java.util.Collections.unmodifiableList(configuration_);
        } else {
          return configurationBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public int getConfigurationCount() {
        if (configurationBuilder_ == null) {
          return configuration_.size();
        } else {
          return configurationBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Onnx.DeviceConfigurationProto getConfiguration(int index) {
        if (configurationBuilder_ == null) {
          return configuration_.get(index);
        } else {
          return configurationBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder setConfiguration(
          int index, Onnx.DeviceConfigurationProto value) {
        if (configurationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConfigurationIsMutable();
          configuration_.set(index, value);
          onChanged();
        } else {
          configurationBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder setConfiguration(
          int index, Onnx.DeviceConfigurationProto.Builder builderForValue) {
        if (configurationBuilder_ == null) {
          ensureConfigurationIsMutable();
          configuration_.set(index, builderForValue.build());
          onChanged();
        } else {
          configurationBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder addConfiguration(Onnx.DeviceConfigurationProto value) {
        if (configurationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConfigurationIsMutable();
          configuration_.add(value);
          onChanged();
        } else {
          configurationBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder addConfiguration(
          int index, Onnx.DeviceConfigurationProto value) {
        if (configurationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureConfigurationIsMutable();
          configuration_.add(index, value);
          onChanged();
        } else {
          configurationBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder addConfiguration(
          Onnx.DeviceConfigurationProto.Builder builderForValue) {
        if (configurationBuilder_ == null) {
          ensureConfigurationIsMutable();
          configuration_.add(builderForValue.build());
          onChanged();
        } else {
          configurationBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder addConfiguration(
          int index, Onnx.DeviceConfigurationProto.Builder builderForValue) {
        if (configurationBuilder_ == null) {
          ensureConfigurationIsMutable();
          configuration_.add(index, builderForValue.build());
          onChanged();
        } else {
          configurationBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder addAllConfiguration(
          java.lang.Iterable<? extends Onnx.DeviceConfigurationProto> values) {
        if (configurationBuilder_ == null) {
          ensureConfigurationIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, configuration_);
          onChanged();
        } else {
          configurationBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder clearConfiguration() {
        if (configurationBuilder_ == null) {
          configuration_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          configurationBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Builder removeConfiguration(int index) {
        if (configurationBuilder_ == null) {
          ensureConfigurationIsMutable();
          configuration_.remove(index);
          onChanged();
        } else {
          configurationBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Onnx.DeviceConfigurationProto.Builder getConfigurationBuilder(
          int index) {
        return internalGetConfigurationFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Onnx.DeviceConfigurationProtoOrBuilder getConfigurationOrBuilder(
          int index) {
        if (configurationBuilder_ == null) {
          return configuration_.get(index);  } else {
          return configurationBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public java.util.List<? extends Onnx.DeviceConfigurationProtoOrBuilder> 
           getConfigurationOrBuilderList() {
        if (configurationBuilder_ != null) {
          return configurationBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(configuration_);
        }
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Onnx.DeviceConfigurationProto.Builder addConfigurationBuilder() {
        return internalGetConfigurationFieldBuilder().addBuilder(
            Onnx.DeviceConfigurationProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public Onnx.DeviceConfigurationProto.Builder addConfigurationBuilder(
          int index) {
        return internalGetConfigurationFieldBuilder().addBuilder(
            index, Onnx.DeviceConfigurationProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Describes different target configurations for a multi-device use case.
       * A model MAY describe multiple multi-device configurations for execution.
       * </pre>
       *
       * <code>repeated .DeviceConfigurationProto configuration = 26;</code>
       */
      public java.util.List<Onnx.DeviceConfigurationProto.Builder> 
           getConfigurationBuilderList() {
        return internalGetConfigurationFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.DeviceConfigurationProto, Onnx.DeviceConfigurationProto.Builder, Onnx.DeviceConfigurationProtoOrBuilder> 
          internalGetConfigurationFieldBuilder() {
        if (configurationBuilder_ == null) {
          configurationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.DeviceConfigurationProto, Onnx.DeviceConfigurationProto.Builder, Onnx.DeviceConfigurationProtoOrBuilder>(
                  configuration_,
                  ((bitField0_ & 0x00000800) != 0),
                  getParentForChildren(),
                  isClean());
          configuration_ = null;
        }
        return configurationBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:ModelProto)
    }

    // @@protoc_insertion_point(class_scope:ModelProto)
    private static final Onnx.ModelProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.ModelProto();
    }

    public static Onnx.ModelProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ModelProto>
        PARSER = new com.google.protobuf.AbstractParser<ModelProto>() {
      @java.lang.Override
      public ModelProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ModelProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ModelProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.ModelProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeviceConfigurationProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:DeviceConfigurationProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of devices inside this configuration.
     * </pre>
     *
     * <code>optional int32 num_devices = 2;</code>
     * @return Whether the numDevices field is set.
     */
    boolean hasNumDevices();
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of devices inside this configuration.
     * </pre>
     *
     * <code>optional int32 num_devices = 2;</code>
     * @return The numDevices.
     */
    int getNumDevices();

    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @return A list containing the device.
     */
    java.util.List<java.lang.String>
        getDeviceList();
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @return The count of device.
     */
    int getDeviceCount();
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @param index The index of the element to return.
     * @return The device at the given index.
     */
    java.lang.String getDevice(int index);
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the device at the given index.
     */
    com.google.protobuf.ByteString
        getDeviceBytes(int index);
  }
  /**
   * <pre>
   * DeviceConfigurationProto describes a multi-device configuration for a model.
   * </pre>
   *
   * Protobuf type {@code DeviceConfigurationProto}
   */
  public static final class DeviceConfigurationProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:DeviceConfigurationProto)
      DeviceConfigurationProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        DeviceConfigurationProto.class.getName());
    }
    // Use DeviceConfigurationProto.newBuilder() to construct.
    private DeviceConfigurationProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DeviceConfigurationProto() {
      name_ = "";
      device_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.DeviceConfigurationProto.class, Onnx.DeviceConfigurationProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Name of the configuration.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NUM_DEVICES_FIELD_NUMBER = 2;
    private int numDevices_ = 0;
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of devices inside this configuration.
     * </pre>
     *
     * <code>optional int32 num_devices = 2;</code>
     * @return Whether the numDevices field is set.
     */
    @java.lang.Override
    public boolean hasNumDevices() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * This field MUST be present for this version of the IR.
     * Number of devices inside this configuration.
     * </pre>
     *
     * <code>optional int32 num_devices = 2;</code>
     * @return The numDevices.
     */
    @java.lang.Override
    public int getNumDevices() {
      return numDevices_;
    }

    public static final int DEVICE_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList device_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @return A list containing the device.
     */
    public com.google.protobuf.ProtocolStringList
        getDeviceList() {
      return device_;
    }
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @return The count of device.
     */
    public int getDeviceCount() {
      return device_.size();
    }
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @param index The index of the element to return.
     * @return The device at the given index.
     */
    public java.lang.String getDevice(int index) {
      return device_.get(index);
    }
    /**
     * <pre>
     * Optional names of the devices. MUST be length of num_devices if provided.
     * </pre>
     *
     * <code>repeated string device = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the device at the given index.
     */
    public com.google.protobuf.ByteString
        getDeviceBytes(int index) {
      return device_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, numDevices_);
      }
      for (int i = 0; i < device_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, device_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, numDevices_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < device_.size(); i++) {
          dataSize += computeStringSizeNoTag(device_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getDeviceList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.DeviceConfigurationProto)) {
        return super.equals(obj);
      }
      Onnx.DeviceConfigurationProto other = (Onnx.DeviceConfigurationProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasNumDevices() != other.hasNumDevices()) return false;
      if (hasNumDevices()) {
        if (getNumDevices()
            != other.getNumDevices()) return false;
      }
      if (!getDeviceList()
          .equals(other.getDeviceList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasNumDevices()) {
        hash = (37 * hash) + NUM_DEVICES_FIELD_NUMBER;
        hash = (53 * hash) + getNumDevices();
      }
      if (getDeviceCount() > 0) {
        hash = (37 * hash) + DEVICE_FIELD_NUMBER;
        hash = (53 * hash) + getDeviceList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.DeviceConfigurationProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.DeviceConfigurationProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.DeviceConfigurationProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.DeviceConfigurationProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.DeviceConfigurationProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DeviceConfigurationProto describes a multi-device configuration for a model.
     * </pre>
     *
     * Protobuf type {@code DeviceConfigurationProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:DeviceConfigurationProto)
        Onnx.DeviceConfigurationProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.DeviceConfigurationProto.class, Onnx.DeviceConfigurationProto.Builder.class);
      }

      // Construct using Onnx.DeviceConfigurationProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        numDevices_ = 0;
        device_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_DeviceConfigurationProto_descriptor;
      }

      @java.lang.Override
      public Onnx.DeviceConfigurationProto getDefaultInstanceForType() {
        return Onnx.DeviceConfigurationProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.DeviceConfigurationProto build() {
        Onnx.DeviceConfigurationProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.DeviceConfigurationProto buildPartial() {
        Onnx.DeviceConfigurationProto result = new Onnx.DeviceConfigurationProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.DeviceConfigurationProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numDevices_ = numDevices_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          device_.makeImmutable();
          result.device_ = device_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.DeviceConfigurationProto) {
          return mergeFrom((Onnx.DeviceConfigurationProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.DeviceConfigurationProto other) {
        if (other == Onnx.DeviceConfigurationProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasNumDevices()) {
          setNumDevices(other.getNumDevices());
        }
        if (!other.device_.isEmpty()) {
          if (device_.isEmpty()) {
            device_ = other.device_;
            bitField0_ |= 0x00000004;
          } else {
            ensureDeviceIsMutable();
            device_.addAll(other.device_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                numDevices_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureDeviceIsMutable();
                device_.add(bs);
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Name of the configuration.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int numDevices_ ;
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of devices inside this configuration.
       * </pre>
       *
       * <code>optional int32 num_devices = 2;</code>
       * @return Whether the numDevices field is set.
       */
      @java.lang.Override
      public boolean hasNumDevices() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of devices inside this configuration.
       * </pre>
       *
       * <code>optional int32 num_devices = 2;</code>
       * @return The numDevices.
       */
      @java.lang.Override
      public int getNumDevices() {
        return numDevices_;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of devices inside this configuration.
       * </pre>
       *
       * <code>optional int32 num_devices = 2;</code>
       * @param value The numDevices to set.
       * @return This builder for chaining.
       */
      public Builder setNumDevices(int value) {

        numDevices_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * Number of devices inside this configuration.
       * </pre>
       *
       * <code>optional int32 num_devices = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumDevices() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numDevices_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList device_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureDeviceIsMutable() {
        if (!device_.isModifiable()) {
          device_ = new com.google.protobuf.LazyStringArrayList(device_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @return A list containing the device.
       */
      public com.google.protobuf.ProtocolStringList
          getDeviceList() {
        device_.makeImmutable();
        return device_;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @return The count of device.
       */
      public int getDeviceCount() {
        return device_.size();
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param index The index of the element to return.
       * @return The device at the given index.
       */
      public java.lang.String getDevice(int index) {
        return device_.get(index);
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the device at the given index.
       */
      public com.google.protobuf.ByteString
          getDeviceBytes(int index) {
        return device_.getByteString(index);
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param index The index to set the value at.
       * @param value The device to set.
       * @return This builder for chaining.
       */
      public Builder setDevice(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDeviceIsMutable();
        device_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param value The device to add.
       * @return This builder for chaining.
       */
      public Builder addDevice(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDeviceIsMutable();
        device_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param values The device to add.
       * @return This builder for chaining.
       */
      public Builder addAllDevice(
          java.lang.Iterable<java.lang.String> values) {
        ensureDeviceIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, device_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDevice() {
        device_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional names of the devices. MUST be length of num_devices if provided.
       * </pre>
       *
       * <code>repeated string device = 3;</code>
       * @param value The bytes of the device to add.
       * @return This builder for chaining.
       */
      public Builder addDeviceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureDeviceIsMutable();
        device_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:DeviceConfigurationProto)
    }

    // @@protoc_insertion_point(class_scope:DeviceConfigurationProto)
    private static final Onnx.DeviceConfigurationProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.DeviceConfigurationProto();
    }

    public static Onnx.DeviceConfigurationProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeviceConfigurationProto>
        PARSER = new com.google.protobuf.AbstractParser<DeviceConfigurationProto>() {
      @java.lang.Override
      public DeviceConfigurationProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeviceConfigurationProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeviceConfigurationProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.DeviceConfigurationProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface StringStringEntryProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:StringStringEntryProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    boolean hasKey();
    /**
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>optional string value = 2;</code>
     * @return Whether the value field is set.
     */
    boolean hasValue();
    /**
     * <code>optional string value = 2;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <code>optional string value = 2;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();
  }
  /**
   * <pre>
   * StringStringEntryProto follows the pattern for cross-proto-version maps.
   * See https://developers.google.com/protocol-buffers/docs/proto3#maps
   * </pre>
   *
   * Protobuf type {@code StringStringEntryProto}
   */
  public static final class StringStringEntryProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:StringStringEntryProto)
      StringStringEntryProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        StringStringEntryProto.class.getName());
    }
    // Use StringStringEntryProto.newBuilder() to construct.
    private StringStringEntryProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private StringStringEntryProto() {
      key_ = "";
      value_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_StringStringEntryProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.StringStringEntryProto.class, Onnx.StringStringEntryProto.Builder.class);
    }

    private int bitField0_;
    public static final int KEY_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object key_ = "";
    /**
     * <code>optional string key = 1;</code>
     * @return Whether the key field is set.
     */
    @java.lang.Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          key_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object value_ = "";
    /**
     * <code>optional string value = 2;</code>
     * @return Whether the value field is set.
     */
    @java.lang.Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional string value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          value_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string value = 2;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, key_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.StringStringEntryProto)) {
        return super.equals(obj);
      }
      Onnx.StringStringEntryProto other = (Onnx.StringStringEntryProto) obj;

      if (hasKey() != other.hasKey()) return false;
      if (hasKey()) {
        if (!getKey()
            .equals(other.getKey())) return false;
      }
      if (hasValue() != other.hasValue()) return false;
      if (hasValue()) {
        if (!getValue()
            .equals(other.getValue())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasKey()) {
        hash = (37 * hash) + KEY_FIELD_NUMBER;
        hash = (53 * hash) + getKey().hashCode();
      }
      if (hasValue()) {
        hash = (37 * hash) + VALUE_FIELD_NUMBER;
        hash = (53 * hash) + getValue().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.StringStringEntryProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.StringStringEntryProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.StringStringEntryProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.StringStringEntryProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.StringStringEntryProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.StringStringEntryProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.StringStringEntryProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * StringStringEntryProto follows the pattern for cross-proto-version maps.
     * See https://developers.google.com/protocol-buffers/docs/proto3#maps
     * </pre>
     *
     * Protobuf type {@code StringStringEntryProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:StringStringEntryProto)
        Onnx.StringStringEntryProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_StringStringEntryProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_StringStringEntryProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.StringStringEntryProto.class, Onnx.StringStringEntryProto.Builder.class);
      }

      // Construct using Onnx.StringStringEntryProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        key_ = "";
        value_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_StringStringEntryProto_descriptor;
      }

      @java.lang.Override
      public Onnx.StringStringEntryProto getDefaultInstanceForType() {
        return Onnx.StringStringEntryProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.StringStringEntryProto build() {
        Onnx.StringStringEntryProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.StringStringEntryProto buildPartial() {
        Onnx.StringStringEntryProto result = new Onnx.StringStringEntryProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.StringStringEntryProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.key_ = key_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.value_ = value_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.StringStringEntryProto) {
          return mergeFrom((Onnx.StringStringEntryProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.StringStringEntryProto other) {
        if (other == Onnx.StringStringEntryProto.getDefaultInstance()) return this;
        if (other.hasKey()) {
          key_ = other.key_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasValue()) {
          value_ = other.value_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                key_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                value_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object key_ = "";
      /**
       * <code>optional string key = 1;</code>
       * @return Whether the key field is set.
       */
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string key = 1;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            key_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string key = 1;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        key_ = getDefaultInstance().getKey();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        key_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object value_ = "";
      /**
       * <code>optional string value = 2;</code>
       * @return Whether the value field is set.
       */
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional string value = 2;</code>
       * @return The value.
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            value_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string value = 2;</code>
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string value = 2;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional string value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        value_ = getDefaultInstance().getValue();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>optional string value = 2;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        value_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:StringStringEntryProto)
    }

    // @@protoc_insertion_point(class_scope:StringStringEntryProto)
    private static final Onnx.StringStringEntryProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.StringStringEntryProto();
    }

    public static Onnx.StringStringEntryProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<StringStringEntryProto>
        PARSER = new com.google.protobuf.AbstractParser<StringStringEntryProto>() {
      @java.lang.Override
      public StringStringEntryProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<StringStringEntryProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<StringStringEntryProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.StringStringEntryProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TensorAnnotationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TensorAnnotation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string tensor_name = 1;</code>
     * @return Whether the tensorName field is set.
     */
    boolean hasTensorName();
    /**
     * <code>optional string tensor_name = 1;</code>
     * @return The tensorName.
     */
    java.lang.String getTensorName();
    /**
     * <code>optional string tensor_name = 1;</code>
     * @return The bytes for tensorName.
     */
    com.google.protobuf.ByteString
        getTensorNameBytes();

    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getQuantParameterTensorNamesList();
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    Onnx.StringStringEntryProto getQuantParameterTensorNames(int index);
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    int getQuantParameterTensorNamesCount();
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getQuantParameterTensorNamesOrBuilderList();
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code TensorAnnotation}
   */
  public static final class TensorAnnotation extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:TensorAnnotation)
      TensorAnnotationOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        TensorAnnotation.class.getName());
    }
    // Use TensorAnnotation.newBuilder() to construct.
    private TensorAnnotation(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TensorAnnotation() {
      tensorName_ = "";
      quantParameterTensorNames_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_TensorAnnotation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_TensorAnnotation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.TensorAnnotation.class, Onnx.TensorAnnotation.Builder.class);
    }

    private int bitField0_;
    public static final int TENSOR_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object tensorName_ = "";
    /**
     * <code>optional string tensor_name = 1;</code>
     * @return Whether the tensorName field is set.
     */
    @java.lang.Override
    public boolean hasTensorName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string tensor_name = 1;</code>
     * @return The tensorName.
     */
    @java.lang.Override
    public java.lang.String getTensorName() {
      java.lang.Object ref = tensorName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          tensorName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string tensor_name = 1;</code>
     * @return The bytes for tensorName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTensorNameBytes() {
      java.lang.Object ref = tensorName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        tensorName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> quantParameterTensorNames_;
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getQuantParameterTensorNamesList() {
      return quantParameterTensorNames_;
    }
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getQuantParameterTensorNamesOrBuilderList() {
      return quantParameterTensorNames_;
    }
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    @java.lang.Override
    public int getQuantParameterTensorNamesCount() {
      return quantParameterTensorNames_.size();
    }
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getQuantParameterTensorNames(int index) {
      return quantParameterTensorNames_.get(index);
    }
    /**
     * <pre>
     * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
     * The keys used in the mapping below must be pre-defined in ONNX spec.
     * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
     * quantization parameter keys.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
        int index) {
      return quantParameterTensorNames_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, tensorName_);
      }
      for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
        output.writeMessage(2, quantParameterTensorNames_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, tensorName_);
      }
      for (int i = 0; i < quantParameterTensorNames_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, quantParameterTensorNames_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.TensorAnnotation)) {
        return super.equals(obj);
      }
      Onnx.TensorAnnotation other = (Onnx.TensorAnnotation) obj;

      if (hasTensorName() != other.hasTensorName()) return false;
      if (hasTensorName()) {
        if (!getTensorName()
            .equals(other.getTensorName())) return false;
      }
      if (!getQuantParameterTensorNamesList()
          .equals(other.getQuantParameterTensorNamesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTensorName()) {
        hash = (37 * hash) + TENSOR_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getTensorName().hashCode();
      }
      if (getQuantParameterTensorNamesCount() > 0) {
        hash = (37 * hash) + QUANT_PARAMETER_TENSOR_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + getQuantParameterTensorNamesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.TensorAnnotation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorAnnotation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorAnnotation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorAnnotation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorAnnotation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorAnnotation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorAnnotation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorAnnotation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.TensorAnnotation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.TensorAnnotation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.TensorAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorAnnotation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.TensorAnnotation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code TensorAnnotation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:TensorAnnotation)
        Onnx.TensorAnnotationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TensorAnnotation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TensorAnnotation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TensorAnnotation.class, Onnx.TensorAnnotation.Builder.class);
      }

      // Construct using Onnx.TensorAnnotation.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        tensorName_ = "";
        if (quantParameterTensorNamesBuilder_ == null) {
          quantParameterTensorNames_ = java.util.Collections.emptyList();
        } else {
          quantParameterTensorNames_ = null;
          quantParameterTensorNamesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_TensorAnnotation_descriptor;
      }

      @java.lang.Override
      public Onnx.TensorAnnotation getDefaultInstanceForType() {
        return Onnx.TensorAnnotation.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.TensorAnnotation build() {
        Onnx.TensorAnnotation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.TensorAnnotation buildPartial() {
        Onnx.TensorAnnotation result = new Onnx.TensorAnnotation(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.TensorAnnotation result) {
        if (quantParameterTensorNamesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            quantParameterTensorNames_ = java.util.Collections.unmodifiableList(quantParameterTensorNames_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.quantParameterTensorNames_ = quantParameterTensorNames_;
        } else {
          result.quantParameterTensorNames_ = quantParameterTensorNamesBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.TensorAnnotation result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.tensorName_ = tensorName_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.TensorAnnotation) {
          return mergeFrom((Onnx.TensorAnnotation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.TensorAnnotation other) {
        if (other == Onnx.TensorAnnotation.getDefaultInstance()) return this;
        if (other.hasTensorName()) {
          tensorName_ = other.tensorName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (quantParameterTensorNamesBuilder_ == null) {
          if (!other.quantParameterTensorNames_.isEmpty()) {
            if (quantParameterTensorNames_.isEmpty()) {
              quantParameterTensorNames_ = other.quantParameterTensorNames_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureQuantParameterTensorNamesIsMutable();
              quantParameterTensorNames_.addAll(other.quantParameterTensorNames_);
            }
            onChanged();
          }
        } else {
          if (!other.quantParameterTensorNames_.isEmpty()) {
            if (quantParameterTensorNamesBuilder_.isEmpty()) {
              quantParameterTensorNamesBuilder_.dispose();
              quantParameterTensorNamesBuilder_ = null;
              quantParameterTensorNames_ = other.quantParameterTensorNames_;
              bitField0_ = (bitField0_ & ~0x00000002);
              quantParameterTensorNamesBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetQuantParameterTensorNamesFieldBuilder() : null;
            } else {
              quantParameterTensorNamesBuilder_.addAllMessages(other.quantParameterTensorNames_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                tensorName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (quantParameterTensorNamesBuilder_ == null) {
                  ensureQuantParameterTensorNamesIsMutable();
                  quantParameterTensorNames_.add(m);
                } else {
                  quantParameterTensorNamesBuilder_.addMessage(m);
                }
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object tensorName_ = "";
      /**
       * <code>optional string tensor_name = 1;</code>
       * @return Whether the tensorName field is set.
       */
      public boolean hasTensorName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string tensor_name = 1;</code>
       * @return The tensorName.
       */
      public java.lang.String getTensorName() {
        java.lang.Object ref = tensorName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            tensorName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string tensor_name = 1;</code>
       * @return The bytes for tensorName.
       */
      public com.google.protobuf.ByteString
          getTensorNameBytes() {
        java.lang.Object ref = tensorName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          tensorName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string tensor_name = 1;</code>
       * @param value The tensorName to set.
       * @return This builder for chaining.
       */
      public Builder setTensorName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        tensorName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string tensor_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTensorName() {
        tensorName_ = getDefaultInstance().getTensorName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string tensor_name = 1;</code>
       * @param value The bytes for tensorName to set.
       * @return This builder for chaining.
       */
      public Builder setTensorNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        tensorName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.StringStringEntryProto> quantParameterTensorNames_ =
        java.util.Collections.emptyList();
      private void ensureQuantParameterTensorNamesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          quantParameterTensorNames_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(quantParameterTensorNames_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> quantParameterTensorNamesBuilder_;

      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getQuantParameterTensorNamesList() {
        if (quantParameterTensorNamesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
        } else {
          return quantParameterTensorNamesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public int getQuantParameterTensorNamesCount() {
        if (quantParameterTensorNamesBuilder_ == null) {
          return quantParameterTensorNames_.size();
        } else {
          return quantParameterTensorNamesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Onnx.StringStringEntryProto getQuantParameterTensorNames(int index) {
        if (quantParameterTensorNamesBuilder_ == null) {
          return quantParameterTensorNames_.get(index);
        } else {
          return quantParameterTensorNamesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder setQuantParameterTensorNames(
          int index, Onnx.StringStringEntryProto value) {
        if (quantParameterTensorNamesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.set(index, value);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder setQuantParameterTensorNames(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (quantParameterTensorNamesBuilder_ == null) {
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.set(index, builderForValue.build());
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder addQuantParameterTensorNames(Onnx.StringStringEntryProto value) {
        if (quantParameterTensorNamesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.add(value);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder addQuantParameterTensorNames(
          int index, Onnx.StringStringEntryProto value) {
        if (quantParameterTensorNamesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.add(index, value);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder addQuantParameterTensorNames(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (quantParameterTensorNamesBuilder_ == null) {
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.add(builderForValue.build());
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder addQuantParameterTensorNames(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (quantParameterTensorNamesBuilder_ == null) {
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.add(index, builderForValue.build());
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder addAllQuantParameterTensorNames(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (quantParameterTensorNamesBuilder_ == null) {
          ensureQuantParameterTensorNamesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, quantParameterTensorNames_);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder clearQuantParameterTensorNames() {
        if (quantParameterTensorNamesBuilder_ == null) {
          quantParameterTensorNames_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Builder removeQuantParameterTensorNames(int index) {
        if (quantParameterTensorNamesBuilder_ == null) {
          ensureQuantParameterTensorNamesIsMutable();
          quantParameterTensorNames_.remove(index);
          onChanged();
        } else {
          quantParameterTensorNamesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Onnx.StringStringEntryProto.Builder getQuantParameterTensorNamesBuilder(
          int index) {
        return internalGetQuantParameterTensorNamesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getQuantParameterTensorNamesOrBuilder(
          int index) {
        if (quantParameterTensorNamesBuilder_ == null) {
          return quantParameterTensorNames_.get(index);  } else {
          return quantParameterTensorNamesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getQuantParameterTensorNamesOrBuilderList() {
        if (quantParameterTensorNamesBuilder_ != null) {
          return quantParameterTensorNamesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(quantParameterTensorNames_);
        }
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Onnx.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder() {
        return internalGetQuantParameterTensorNamesFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public Onnx.StringStringEntryProto.Builder addQuantParameterTensorNamesBuilder(
          int index) {
        return internalGetQuantParameterTensorNamesFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * &lt;key, value&gt; pairs to annotate tensor specified by &lt;tensor_name&gt; above.
       * The keys used in the mapping below must be pre-defined in ONNX spec.
       * For example, for 8-bit linear quantization case, 'SCALE_TENSOR', 'ZERO_POINT_TENSOR' will be pre-defined as
       * quantization parameter keys.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto quant_parameter_tensor_names = 2;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getQuantParameterTensorNamesBuilderList() {
        return internalGetQuantParameterTensorNamesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetQuantParameterTensorNamesFieldBuilder() {
        if (quantParameterTensorNamesBuilder_ == null) {
          quantParameterTensorNamesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  quantParameterTensorNames_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          quantParameterTensorNames_ = null;
        }
        return quantParameterTensorNamesBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:TensorAnnotation)
    }

    // @@protoc_insertion_point(class_scope:TensorAnnotation)
    private static final Onnx.TensorAnnotation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.TensorAnnotation();
    }

    public static Onnx.TensorAnnotation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TensorAnnotation>
        PARSER = new com.google.protobuf.AbstractParser<TensorAnnotation>() {
      @java.lang.Override
      public TensorAnnotation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TensorAnnotation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TensorAnnotation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.TensorAnnotation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GraphProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:GraphProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    java.util.List<Onnx.NodeProto> 
        getNodeList();
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    Onnx.NodeProto getNode(int index);
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    int getNodeCount();
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    java.util.List<? extends Onnx.NodeProtoOrBuilder> 
        getNodeOrBuilderList();
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    Onnx.NodeProtoOrBuilder getNodeOrBuilder(
        int index);

    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    java.util.List<Onnx.TensorProto> 
        getInitializerList();
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    Onnx.TensorProto getInitializer(int index);
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    int getInitializerCount();
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    java.util.List<? extends Onnx.TensorProtoOrBuilder> 
        getInitializerOrBuilderList();
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    Onnx.TensorProtoOrBuilder getInitializerOrBuilder(
        int index);

    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    java.util.List<Onnx.SparseTensorProto> 
        getSparseInitializerList();
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    Onnx.SparseTensorProto getSparseInitializer(int index);
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    int getSparseInitializerCount();
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
        getSparseInitializerOrBuilderList();
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    Onnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
        int index);

    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    java.util.List<Onnx.ValueInfoProto> 
        getInputList();
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    Onnx.ValueInfoProto getInput(int index);
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    int getInputCount();
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getInputOrBuilderList();
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    Onnx.ValueInfoProtoOrBuilder getInputOrBuilder(
        int index);

    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    java.util.List<Onnx.ValueInfoProto> 
        getOutputList();
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    Onnx.ValueInfoProto getOutput(int index);
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    int getOutputCount();
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getOutputOrBuilderList();
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    Onnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
        int index);

    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    java.util.List<Onnx.ValueInfoProto> 
        getValueInfoList();
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    Onnx.ValueInfoProto getValueInfo(int index);
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    int getValueInfoCount();
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getValueInfoOrBuilderList();
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
        int index);

    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    java.util.List<Onnx.TensorAnnotation> 
        getQuantizationAnnotationList();
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    Onnx.TensorAnnotation getQuantizationAnnotation(int index);
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    int getQuantizationAnnotationCount();
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    java.util.List<? extends Onnx.TensorAnnotationOrBuilder> 
        getQuantizationAnnotationOrBuilderList();
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    Onnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
        int index);

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Graphs
   *
   * A graph defines the computational logic of a model and is comprised of a parameterized
   * list of nodes that form a directed acyclic graph based on their inputs and outputs.
   * This is the equivalent of the "network" or "graph" in many deep learning
   * frameworks.
   * </pre>
   *
   * Protobuf type {@code GraphProto}
   */
  public static final class GraphProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:GraphProto)
      GraphProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        GraphProto.class.getName());
    }
    // Use GraphProto.newBuilder() to construct.
    private GraphProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private GraphProto() {
      node_ = java.util.Collections.emptyList();
      name_ = "";
      initializer_ = java.util.Collections.emptyList();
      sparseInitializer_ = java.util.Collections.emptyList();
      docString_ = "";
      input_ = java.util.Collections.emptyList();
      output_ = java.util.Collections.emptyList();
      valueInfo_ = java.util.Collections.emptyList();
      quantizationAnnotation_ = java.util.Collections.emptyList();
      metadataProps_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_GraphProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_GraphProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.GraphProto.class, Onnx.GraphProto.Builder.class);
    }

    private int bitField0_;
    public static final int NODE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.NodeProto> node_;
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.NodeProto> getNodeList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.NodeProtoOrBuilder> 
        getNodeOrBuilderList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    @java.lang.Override
    public int getNodeCount() {
      return node_.size();
    }
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    @java.lang.Override
    public Onnx.NodeProto getNode(int index) {
      return node_.get(index);
    }
    /**
     * <pre>
     * The nodes in the graph, sorted topologically.
     * </pre>
     *
     * <code>repeated .NodeProto node = 1;</code>
     */
    @java.lang.Override
    public Onnx.NodeProtoOrBuilder getNodeOrBuilder(
        int index) {
      return node_.get(index);
    }

    public static final int NAME_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the graph.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INITIALIZER_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TensorProto> initializer_;
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TensorProto> getInitializerList() {
      return initializer_;
    }
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TensorProtoOrBuilder> 
        getInitializerOrBuilderList() {
      return initializer_;
    }
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    @java.lang.Override
    public int getInitializerCount() {
      return initializer_.size();
    }
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    @java.lang.Override
    public Onnx.TensorProto getInitializer(int index) {
      return initializer_.get(index);
    }
    /**
     * <pre>
     * A list of named tensor values, used to specify constant inputs of the graph.
     * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
     * The name MUST be unique across both initializer and sparse_initializer,
     * but the name MAY also appear in the input list.
     * </pre>
     *
     * <code>repeated .TensorProto initializer = 5;</code>
     */
    @java.lang.Override
    public Onnx.TensorProtoOrBuilder getInitializerOrBuilder(
        int index) {
      return initializer_.get(index);
    }

    public static final int SPARSE_INITIALIZER_FIELD_NUMBER = 15;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.SparseTensorProto> sparseInitializer_;
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.SparseTensorProto> getSparseInitializerList() {
      return sparseInitializer_;
    }
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
        getSparseInitializerOrBuilderList() {
      return sparseInitializer_;
    }
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    @java.lang.Override
    public int getSparseInitializerCount() {
      return sparseInitializer_.size();
    }
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    @java.lang.Override
    public Onnx.SparseTensorProto getSparseInitializer(int index) {
      return sparseInitializer_.get(index);
    }
    /**
     * <pre>
     * Initializers (see above) stored in sparse format.
     * </pre>
     *
     * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
     */
    @java.lang.Override
    public Onnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
        int index) {
      return sparseInitializer_.get(index);
    }

    public static final int DOC_STRING_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this graph. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 10;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INPUT_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ValueInfoProto> input_;
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ValueInfoProto> getInputList() {
      return input_;
    }
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getInputOrBuilderList() {
      return input_;
    }
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    @java.lang.Override
    public int getInputCount() {
      return input_.size();
    }
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProto getInput(int index) {
      return input_.get(index);
    }
    /**
     * <pre>
     * The inputs and outputs of the graph.
     * </pre>
     *
     * <code>repeated .ValueInfoProto input = 11;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProtoOrBuilder getInputOrBuilder(
        int index) {
      return input_.get(index);
    }

    public static final int OUTPUT_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ValueInfoProto> output_;
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ValueInfoProto> getOutputList() {
      return output_;
    }
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getOutputOrBuilderList() {
      return output_;
    }
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    @java.lang.Override
    public int getOutputCount() {
      return output_.size();
    }
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProto getOutput(int index) {
      return output_.get(index);
    }
    /**
     * <code>repeated .ValueInfoProto output = 12;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
        int index) {
      return output_.get(index);
    }

    public static final int VALUE_INFO_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ValueInfoProto> valueInfo_;
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ValueInfoProto> getValueInfoList() {
      return valueInfo_;
    }
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getValueInfoOrBuilderList() {
      return valueInfo_;
    }
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    @java.lang.Override
    public int getValueInfoCount() {
      return valueInfo_.size();
    }
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProto getValueInfo(int index) {
      return valueInfo_.get(index);
    }
    /**
     * <pre>
     * Information for the values in the graph. The ValueInfoProto.name's
     * must be distinct. It is optional for a value to appear in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 13;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
        int index) {
      return valueInfo_.get(index);
    }

    public static final int QUANTIZATION_ANNOTATION_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TensorAnnotation> quantizationAnnotation_;
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TensorAnnotation> getQuantizationAnnotationList() {
      return quantizationAnnotation_;
    }
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TensorAnnotationOrBuilder> 
        getQuantizationAnnotationOrBuilderList() {
      return quantizationAnnotation_;
    }
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    @java.lang.Override
    public int getQuantizationAnnotationCount() {
      return quantizationAnnotation_.size();
    }
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    @java.lang.Override
    public Onnx.TensorAnnotation getQuantizationAnnotation(int index) {
      return quantizationAnnotation_.get(index);
    }
    /**
     * <pre>
     * This field carries information to indicate the mapping among a tensor and its
     * quantization parameter tensors. For example:
     * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
     * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
     * </pre>
     *
     * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
     */
    @java.lang.Override
    public Onnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
        int index) {
      return quantizationAnnotation_.get(index);
    }

    public static final int METADATA_PROPS_FIELD_NUMBER = 16;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < node_.size(); i++) {
        output.writeMessage(1, node_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, name_);
      }
      for (int i = 0; i < initializer_.size(); i++) {
        output.writeMessage(5, initializer_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 10, docString_);
      }
      for (int i = 0; i < input_.size(); i++) {
        output.writeMessage(11, input_.get(i));
      }
      for (int i = 0; i < output_.size(); i++) {
        output.writeMessage(12, output_.get(i));
      }
      for (int i = 0; i < valueInfo_.size(); i++) {
        output.writeMessage(13, valueInfo_.get(i));
      }
      for (int i = 0; i < quantizationAnnotation_.size(); i++) {
        output.writeMessage(14, quantizationAnnotation_.get(i));
      }
      for (int i = 0; i < sparseInitializer_.size(); i++) {
        output.writeMessage(15, sparseInitializer_.get(i));
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(16, metadataProps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < node_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, node_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, name_);
      }
      for (int i = 0; i < initializer_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, initializer_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, docString_);
      }
      for (int i = 0; i < input_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, input_.get(i));
      }
      for (int i = 0; i < output_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, output_.get(i));
      }
      for (int i = 0; i < valueInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, valueInfo_.get(i));
      }
      for (int i = 0; i < quantizationAnnotation_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, quantizationAnnotation_.get(i));
      }
      for (int i = 0; i < sparseInitializer_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, sparseInitializer_.get(i));
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, metadataProps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.GraphProto)) {
        return super.equals(obj);
      }
      Onnx.GraphProto other = (Onnx.GraphProto) obj;

      if (!getNodeList()
          .equals(other.getNodeList())) return false;
      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (!getInitializerList()
          .equals(other.getInitializerList())) return false;
      if (!getSparseInitializerList()
          .equals(other.getSparseInitializerList())) return false;
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (!getInputList()
          .equals(other.getInputList())) return false;
      if (!getOutputList()
          .equals(other.getOutputList())) return false;
      if (!getValueInfoList()
          .equals(other.getValueInfoList())) return false;
      if (!getQuantizationAnnotationList()
          .equals(other.getQuantizationAnnotationList())) return false;
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getNodeCount() > 0) {
        hash = (37 * hash) + NODE_FIELD_NUMBER;
        hash = (53 * hash) + getNodeList().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (getInitializerCount() > 0) {
        hash = (37 * hash) + INITIALIZER_FIELD_NUMBER;
        hash = (53 * hash) + getInitializerList().hashCode();
      }
      if (getSparseInitializerCount() > 0) {
        hash = (37 * hash) + SPARSE_INITIALIZER_FIELD_NUMBER;
        hash = (53 * hash) + getSparseInitializerList().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (getInputCount() > 0) {
        hash = (37 * hash) + INPUT_FIELD_NUMBER;
        hash = (53 * hash) + getInputList().hashCode();
      }
      if (getOutputCount() > 0) {
        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getOutputList().hashCode();
      }
      if (getValueInfoCount() > 0) {
        hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getValueInfoList().hashCode();
      }
      if (getQuantizationAnnotationCount() > 0) {
        hash = (37 * hash) + QUANTIZATION_ANNOTATION_FIELD_NUMBER;
        hash = (53 * hash) + getQuantizationAnnotationList().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.GraphProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.GraphProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.GraphProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.GraphProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.GraphProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.GraphProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.GraphProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.GraphProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.GraphProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.GraphProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.GraphProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.GraphProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.GraphProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Graphs
     *
     * A graph defines the computational logic of a model and is comprised of a parameterized
     * list of nodes that form a directed acyclic graph based on their inputs and outputs.
     * This is the equivalent of the "network" or "graph" in many deep learning
     * frameworks.
     * </pre>
     *
     * Protobuf type {@code GraphProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:GraphProto)
        Onnx.GraphProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_GraphProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_GraphProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.GraphProto.class, Onnx.GraphProto.Builder.class);
      }

      // Construct using Onnx.GraphProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
        } else {
          node_ = null;
          nodeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = "";
        if (initializerBuilder_ == null) {
          initializer_ = java.util.Collections.emptyList();
        } else {
          initializer_ = null;
          initializerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (sparseInitializerBuilder_ == null) {
          sparseInitializer_ = java.util.Collections.emptyList();
        } else {
          sparseInitializer_ = null;
          sparseInitializerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        docString_ = "";
        if (inputBuilder_ == null) {
          input_ = java.util.Collections.emptyList();
        } else {
          input_ = null;
          inputBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (outputBuilder_ == null) {
          output_ = java.util.Collections.emptyList();
        } else {
          output_ = null;
          outputBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        if (valueInfoBuilder_ == null) {
          valueInfo_ = java.util.Collections.emptyList();
        } else {
          valueInfo_ = null;
          valueInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        if (quantizationAnnotationBuilder_ == null) {
          quantizationAnnotation_ = java.util.Collections.emptyList();
        } else {
          quantizationAnnotation_ = null;
          quantizationAnnotationBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_GraphProto_descriptor;
      }

      @java.lang.Override
      public Onnx.GraphProto getDefaultInstanceForType() {
        return Onnx.GraphProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.GraphProto build() {
        Onnx.GraphProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.GraphProto buildPartial() {
        Onnx.GraphProto result = new Onnx.GraphProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.GraphProto result) {
        if (nodeBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            node_ = java.util.Collections.unmodifiableList(node_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.node_ = node_;
        } else {
          result.node_ = nodeBuilder_.build();
        }
        if (initializerBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            initializer_ = java.util.Collections.unmodifiableList(initializer_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.initializer_ = initializer_;
        } else {
          result.initializer_ = initializerBuilder_.build();
        }
        if (sparseInitializerBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            sparseInitializer_ = java.util.Collections.unmodifiableList(sparseInitializer_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.sparseInitializer_ = sparseInitializer_;
        } else {
          result.sparseInitializer_ = sparseInitializerBuilder_.build();
        }
        if (inputBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            input_ = java.util.Collections.unmodifiableList(input_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.input_ = input_;
        } else {
          result.input_ = inputBuilder_.build();
        }
        if (outputBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            output_ = java.util.Collections.unmodifiableList(output_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.output_ = output_;
        } else {
          result.output_ = outputBuilder_.build();
        }
        if (valueInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.valueInfo_ = valueInfo_;
        } else {
          result.valueInfo_ = valueInfoBuilder_.build();
        }
        if (quantizationAnnotationBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            quantizationAnnotation_ = java.util.Collections.unmodifiableList(quantizationAnnotation_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.quantizationAnnotation_ = quantizationAnnotation_;
        } else {
          result.quantizationAnnotation_ = quantizationAnnotationBuilder_.build();
        }
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.GraphProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.GraphProto) {
          return mergeFrom((Onnx.GraphProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.GraphProto other) {
        if (other == Onnx.GraphProto.getDefaultInstance()) return this;
        if (nodeBuilder_ == null) {
          if (!other.node_.isEmpty()) {
            if (node_.isEmpty()) {
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureNodeIsMutable();
              node_.addAll(other.node_);
            }
            onChanged();
          }
        } else {
          if (!other.node_.isEmpty()) {
            if (nodeBuilder_.isEmpty()) {
              nodeBuilder_.dispose();
              nodeBuilder_ = null;
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000001);
              nodeBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetNodeFieldBuilder() : null;
            } else {
              nodeBuilder_.addAllMessages(other.node_);
            }
          }
        }
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (initializerBuilder_ == null) {
          if (!other.initializer_.isEmpty()) {
            if (initializer_.isEmpty()) {
              initializer_ = other.initializer_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureInitializerIsMutable();
              initializer_.addAll(other.initializer_);
            }
            onChanged();
          }
        } else {
          if (!other.initializer_.isEmpty()) {
            if (initializerBuilder_.isEmpty()) {
              initializerBuilder_.dispose();
              initializerBuilder_ = null;
              initializer_ = other.initializer_;
              bitField0_ = (bitField0_ & ~0x00000004);
              initializerBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetInitializerFieldBuilder() : null;
            } else {
              initializerBuilder_.addAllMessages(other.initializer_);
            }
          }
        }
        if (sparseInitializerBuilder_ == null) {
          if (!other.sparseInitializer_.isEmpty()) {
            if (sparseInitializer_.isEmpty()) {
              sparseInitializer_ = other.sparseInitializer_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureSparseInitializerIsMutable();
              sparseInitializer_.addAll(other.sparseInitializer_);
            }
            onChanged();
          }
        } else {
          if (!other.sparseInitializer_.isEmpty()) {
            if (sparseInitializerBuilder_.isEmpty()) {
              sparseInitializerBuilder_.dispose();
              sparseInitializerBuilder_ = null;
              sparseInitializer_ = other.sparseInitializer_;
              bitField0_ = (bitField0_ & ~0x00000008);
              sparseInitializerBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetSparseInitializerFieldBuilder() : null;
            } else {
              sparseInitializerBuilder_.addAllMessages(other.sparseInitializer_);
            }
          }
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (inputBuilder_ == null) {
          if (!other.input_.isEmpty()) {
            if (input_.isEmpty()) {
              input_ = other.input_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureInputIsMutable();
              input_.addAll(other.input_);
            }
            onChanged();
          }
        } else {
          if (!other.input_.isEmpty()) {
            if (inputBuilder_.isEmpty()) {
              inputBuilder_.dispose();
              inputBuilder_ = null;
              input_ = other.input_;
              bitField0_ = (bitField0_ & ~0x00000020);
              inputBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetInputFieldBuilder() : null;
            } else {
              inputBuilder_.addAllMessages(other.input_);
            }
          }
        }
        if (outputBuilder_ == null) {
          if (!other.output_.isEmpty()) {
            if (output_.isEmpty()) {
              output_ = other.output_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureOutputIsMutable();
              output_.addAll(other.output_);
            }
            onChanged();
          }
        } else {
          if (!other.output_.isEmpty()) {
            if (outputBuilder_.isEmpty()) {
              outputBuilder_.dispose();
              outputBuilder_ = null;
              output_ = other.output_;
              bitField0_ = (bitField0_ & ~0x00000040);
              outputBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetOutputFieldBuilder() : null;
            } else {
              outputBuilder_.addAllMessages(other.output_);
            }
          }
        }
        if (valueInfoBuilder_ == null) {
          if (!other.valueInfo_.isEmpty()) {
            if (valueInfo_.isEmpty()) {
              valueInfo_ = other.valueInfo_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureValueInfoIsMutable();
              valueInfo_.addAll(other.valueInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.valueInfo_.isEmpty()) {
            if (valueInfoBuilder_.isEmpty()) {
              valueInfoBuilder_.dispose();
              valueInfoBuilder_ = null;
              valueInfo_ = other.valueInfo_;
              bitField0_ = (bitField0_ & ~0x00000080);
              valueInfoBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetValueInfoFieldBuilder() : null;
            } else {
              valueInfoBuilder_.addAllMessages(other.valueInfo_);
            }
          }
        }
        if (quantizationAnnotationBuilder_ == null) {
          if (!other.quantizationAnnotation_.isEmpty()) {
            if (quantizationAnnotation_.isEmpty()) {
              quantizationAnnotation_ = other.quantizationAnnotation_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureQuantizationAnnotationIsMutable();
              quantizationAnnotation_.addAll(other.quantizationAnnotation_);
            }
            onChanged();
          }
        } else {
          if (!other.quantizationAnnotation_.isEmpty()) {
            if (quantizationAnnotationBuilder_.isEmpty()) {
              quantizationAnnotationBuilder_.dispose();
              quantizationAnnotationBuilder_ = null;
              quantizationAnnotation_ = other.quantizationAnnotation_;
              bitField0_ = (bitField0_ & ~0x00000100);
              quantizationAnnotationBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetQuantizationAnnotationFieldBuilder() : null;
            } else {
              quantizationAnnotationBuilder_.addAllMessages(other.quantizationAnnotation_);
            }
          }
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000200);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                Onnx.NodeProto m =
                    input.readMessage(
                        Onnx.NodeProto.parser(),
                        extensionRegistry);
                if (nodeBuilder_ == null) {
                  ensureNodeIsMutable();
                  node_.add(m);
                } else {
                  nodeBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 18: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 42: {
                Onnx.TensorProto m =
                    input.readMessage(
                        Onnx.TensorProto.parser(),
                        extensionRegistry);
                if (initializerBuilder_ == null) {
                  ensureInitializerIsMutable();
                  initializer_.add(m);
                } else {
                  initializerBuilder_.addMessage(m);
                }
                break;
              } // case 42
              case 82: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 82
              case 90: {
                Onnx.ValueInfoProto m =
                    input.readMessage(
                        Onnx.ValueInfoProto.parser(),
                        extensionRegistry);
                if (inputBuilder_ == null) {
                  ensureInputIsMutable();
                  input_.add(m);
                } else {
                  inputBuilder_.addMessage(m);
                }
                break;
              } // case 90
              case 98: {
                Onnx.ValueInfoProto m =
                    input.readMessage(
                        Onnx.ValueInfoProto.parser(),
                        extensionRegistry);
                if (outputBuilder_ == null) {
                  ensureOutputIsMutable();
                  output_.add(m);
                } else {
                  outputBuilder_.addMessage(m);
                }
                break;
              } // case 98
              case 106: {
                Onnx.ValueInfoProto m =
                    input.readMessage(
                        Onnx.ValueInfoProto.parser(),
                        extensionRegistry);
                if (valueInfoBuilder_ == null) {
                  ensureValueInfoIsMutable();
                  valueInfo_.add(m);
                } else {
                  valueInfoBuilder_.addMessage(m);
                }
                break;
              } // case 106
              case 114: {
                Onnx.TensorAnnotation m =
                    input.readMessage(
                        Onnx.TensorAnnotation.parser(),
                        extensionRegistry);
                if (quantizationAnnotationBuilder_ == null) {
                  ensureQuantizationAnnotationIsMutable();
                  quantizationAnnotation_.add(m);
                } else {
                  quantizationAnnotationBuilder_.addMessage(m);
                }
                break;
              } // case 114
              case 122: {
                Onnx.SparseTensorProto m =
                    input.readMessage(
                        Onnx.SparseTensorProto.parser(),
                        extensionRegistry);
                if (sparseInitializerBuilder_ == null) {
                  ensureSparseInitializerIsMutable();
                  sparseInitializer_.add(m);
                } else {
                  sparseInitializerBuilder_.addMessage(m);
                }
                break;
              } // case 122
              case 130: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 130
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<Onnx.NodeProto> node_ =
        java.util.Collections.emptyList();
      private void ensureNodeIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          node_ = new java.util.ArrayList<Onnx.NodeProto>(node_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder> nodeBuilder_;

      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public java.util.List<Onnx.NodeProto> getNodeList() {
        if (nodeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(node_);
        } else {
          return nodeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public int getNodeCount() {
        if (nodeBuilder_ == null) {
          return node_.size();
        } else {
          return nodeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Onnx.NodeProto getNode(int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);
        } else {
          return nodeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder setNode(
          int index, Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.set(index, value);
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder setNode(
          int index, Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.set(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder addNode(Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder addNode(
          int index, Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(index, value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder addNode(
          Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder addNode(
          int index, Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder addAllNode(
          java.lang.Iterable<? extends Onnx.NodeProto> values) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, node_);
          onChanged();
        } else {
          nodeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder clearNode() {
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          nodeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Builder removeNode(int index) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.remove(index);
          onChanged();
        } else {
          nodeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Onnx.NodeProto.Builder getNodeBuilder(
          int index) {
        return internalGetNodeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Onnx.NodeProtoOrBuilder getNodeOrBuilder(
          int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);  } else {
          return nodeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public java.util.List<? extends Onnx.NodeProtoOrBuilder> 
           getNodeOrBuilderList() {
        if (nodeBuilder_ != null) {
          return nodeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(node_);
        }
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Onnx.NodeProto.Builder addNodeBuilder() {
        return internalGetNodeFieldBuilder().addBuilder(
            Onnx.NodeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public Onnx.NodeProto.Builder addNodeBuilder(
          int index) {
        return internalGetNodeFieldBuilder().addBuilder(
            index, Onnx.NodeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes in the graph, sorted topologically.
       * </pre>
       *
       * <code>repeated .NodeProto node = 1;</code>
       */
      public java.util.List<Onnx.NodeProto.Builder> 
           getNodeBuilderList() {
        return internalGetNodeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder> 
          internalGetNodeFieldBuilder() {
        if (nodeBuilder_ == null) {
          nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder>(
                  node_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          node_ = null;
        }
        return nodeBuilder_;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the graph.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.TensorProto> initializer_ =
        java.util.Collections.emptyList();
      private void ensureInitializerIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          initializer_ = new java.util.ArrayList<Onnx.TensorProto>(initializer_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> initializerBuilder_;

      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public java.util.List<Onnx.TensorProto> getInitializerList() {
        if (initializerBuilder_ == null) {
          return java.util.Collections.unmodifiableList(initializer_);
        } else {
          return initializerBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public int getInitializerCount() {
        if (initializerBuilder_ == null) {
          return initializer_.size();
        } else {
          return initializerBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Onnx.TensorProto getInitializer(int index) {
        if (initializerBuilder_ == null) {
          return initializer_.get(index);
        } else {
          return initializerBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder setInitializer(
          int index, Onnx.TensorProto value) {
        if (initializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializerIsMutable();
          initializer_.set(index, value);
          onChanged();
        } else {
          initializerBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder setInitializer(
          int index, Onnx.TensorProto.Builder builderForValue) {
        if (initializerBuilder_ == null) {
          ensureInitializerIsMutable();
          initializer_.set(index, builderForValue.build());
          onChanged();
        } else {
          initializerBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder addInitializer(Onnx.TensorProto value) {
        if (initializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializerIsMutable();
          initializer_.add(value);
          onChanged();
        } else {
          initializerBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder addInitializer(
          int index, Onnx.TensorProto value) {
        if (initializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInitializerIsMutable();
          initializer_.add(index, value);
          onChanged();
        } else {
          initializerBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder addInitializer(
          Onnx.TensorProto.Builder builderForValue) {
        if (initializerBuilder_ == null) {
          ensureInitializerIsMutable();
          initializer_.add(builderForValue.build());
          onChanged();
        } else {
          initializerBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder addInitializer(
          int index, Onnx.TensorProto.Builder builderForValue) {
        if (initializerBuilder_ == null) {
          ensureInitializerIsMutable();
          initializer_.add(index, builderForValue.build());
          onChanged();
        } else {
          initializerBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder addAllInitializer(
          java.lang.Iterable<? extends Onnx.TensorProto> values) {
        if (initializerBuilder_ == null) {
          ensureInitializerIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, initializer_);
          onChanged();
        } else {
          initializerBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder clearInitializer() {
        if (initializerBuilder_ == null) {
          initializer_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          initializerBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Builder removeInitializer(int index) {
        if (initializerBuilder_ == null) {
          ensureInitializerIsMutable();
          initializer_.remove(index);
          onChanged();
        } else {
          initializerBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Onnx.TensorProto.Builder getInitializerBuilder(
          int index) {
        return internalGetInitializerFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Onnx.TensorProtoOrBuilder getInitializerOrBuilder(
          int index) {
        if (initializerBuilder_ == null) {
          return initializer_.get(index);  } else {
          return initializerBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public java.util.List<? extends Onnx.TensorProtoOrBuilder> 
           getInitializerOrBuilderList() {
        if (initializerBuilder_ != null) {
          return initializerBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(initializer_);
        }
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Onnx.TensorProto.Builder addInitializerBuilder() {
        return internalGetInitializerFieldBuilder().addBuilder(
            Onnx.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public Onnx.TensorProto.Builder addInitializerBuilder(
          int index) {
        return internalGetInitializerFieldBuilder().addBuilder(
            index, Onnx.TensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of named tensor values, used to specify constant inputs of the graph.
       * Each initializer (both TensorProto as well SparseTensorProto) MUST have a name.
       * The name MUST be unique across both initializer and sparse_initializer,
       * but the name MAY also appear in the input list.
       * </pre>
       *
       * <code>repeated .TensorProto initializer = 5;</code>
       */
      public java.util.List<Onnx.TensorProto.Builder> 
           getInitializerBuilderList() {
        return internalGetInitializerFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> 
          internalGetInitializerFieldBuilder() {
        if (initializerBuilder_ == null) {
          initializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder>(
                  initializer_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          initializer_ = null;
        }
        return initializerBuilder_;
      }

      private java.util.List<Onnx.SparseTensorProto> sparseInitializer_ =
        java.util.Collections.emptyList();
      private void ensureSparseInitializerIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          sparseInitializer_ = new java.util.ArrayList<Onnx.SparseTensorProto>(sparseInitializer_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> sparseInitializerBuilder_;

      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public java.util.List<Onnx.SparseTensorProto> getSparseInitializerList() {
        if (sparseInitializerBuilder_ == null) {
          return java.util.Collections.unmodifiableList(sparseInitializer_);
        } else {
          return sparseInitializerBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public int getSparseInitializerCount() {
        if (sparseInitializerBuilder_ == null) {
          return sparseInitializer_.size();
        } else {
          return sparseInitializerBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Onnx.SparseTensorProto getSparseInitializer(int index) {
        if (sparseInitializerBuilder_ == null) {
          return sparseInitializer_.get(index);
        } else {
          return sparseInitializerBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder setSparseInitializer(
          int index, Onnx.SparseTensorProto value) {
        if (sparseInitializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseInitializerIsMutable();
          sparseInitializer_.set(index, value);
          onChanged();
        } else {
          sparseInitializerBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder setSparseInitializer(
          int index, Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseInitializerBuilder_ == null) {
          ensureSparseInitializerIsMutable();
          sparseInitializer_.set(index, builderForValue.build());
          onChanged();
        } else {
          sparseInitializerBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder addSparseInitializer(Onnx.SparseTensorProto value) {
        if (sparseInitializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseInitializerIsMutable();
          sparseInitializer_.add(value);
          onChanged();
        } else {
          sparseInitializerBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder addSparseInitializer(
          int index, Onnx.SparseTensorProto value) {
        if (sparseInitializerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSparseInitializerIsMutable();
          sparseInitializer_.add(index, value);
          onChanged();
        } else {
          sparseInitializerBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder addSparseInitializer(
          Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseInitializerBuilder_ == null) {
          ensureSparseInitializerIsMutable();
          sparseInitializer_.add(builderForValue.build());
          onChanged();
        } else {
          sparseInitializerBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder addSparseInitializer(
          int index, Onnx.SparseTensorProto.Builder builderForValue) {
        if (sparseInitializerBuilder_ == null) {
          ensureSparseInitializerIsMutable();
          sparseInitializer_.add(index, builderForValue.build());
          onChanged();
        } else {
          sparseInitializerBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder addAllSparseInitializer(
          java.lang.Iterable<? extends Onnx.SparseTensorProto> values) {
        if (sparseInitializerBuilder_ == null) {
          ensureSparseInitializerIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, sparseInitializer_);
          onChanged();
        } else {
          sparseInitializerBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder clearSparseInitializer() {
        if (sparseInitializerBuilder_ == null) {
          sparseInitializer_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          sparseInitializerBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Builder removeSparseInitializer(int index) {
        if (sparseInitializerBuilder_ == null) {
          ensureSparseInitializerIsMutable();
          sparseInitializer_.remove(index);
          onChanged();
        } else {
          sparseInitializerBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Onnx.SparseTensorProto.Builder getSparseInitializerBuilder(
          int index) {
        return internalGetSparseInitializerFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Onnx.SparseTensorProtoOrBuilder getSparseInitializerOrBuilder(
          int index) {
        if (sparseInitializerBuilder_ == null) {
          return sparseInitializer_.get(index);  } else {
          return sparseInitializerBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public java.util.List<? extends Onnx.SparseTensorProtoOrBuilder> 
           getSparseInitializerOrBuilderList() {
        if (sparseInitializerBuilder_ != null) {
          return sparseInitializerBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(sparseInitializer_);
        }
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Onnx.SparseTensorProto.Builder addSparseInitializerBuilder() {
        return internalGetSparseInitializerFieldBuilder().addBuilder(
            Onnx.SparseTensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public Onnx.SparseTensorProto.Builder addSparseInitializerBuilder(
          int index) {
        return internalGetSparseInitializerFieldBuilder().addBuilder(
            index, Onnx.SparseTensorProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Initializers (see above) stored in sparse format.
       * </pre>
       *
       * <code>repeated .SparseTensorProto sparse_initializer = 15;</code>
       */
      public java.util.List<Onnx.SparseTensorProto.Builder> 
           getSparseInitializerBuilderList() {
        return internalGetSparseInitializerFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder> 
          internalGetSparseInitializerFieldBuilder() {
        if (sparseInitializerBuilder_ == null) {
          sparseInitializerBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.SparseTensorProto, Onnx.SparseTensorProto.Builder, Onnx.SparseTensorProtoOrBuilder>(
                  sparseInitializer_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          sparseInitializer_ = null;
        }
        return sparseInitializerBuilder_;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this graph. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 10;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.ValueInfoProto> input_ =
        java.util.Collections.emptyList();
      private void ensureInputIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          input_ = new java.util.ArrayList<Onnx.ValueInfoProto>(input_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> inputBuilder_;

      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public java.util.List<Onnx.ValueInfoProto> getInputList() {
        if (inputBuilder_ == null) {
          return java.util.Collections.unmodifiableList(input_);
        } else {
          return inputBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public int getInputCount() {
        if (inputBuilder_ == null) {
          return input_.size();
        } else {
          return inputBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Onnx.ValueInfoProto getInput(int index) {
        if (inputBuilder_ == null) {
          return input_.get(index);
        } else {
          return inputBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder setInput(
          int index, Onnx.ValueInfoProto value) {
        if (inputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputIsMutable();
          input_.set(index, value);
          onChanged();
        } else {
          inputBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder setInput(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (inputBuilder_ == null) {
          ensureInputIsMutable();
          input_.set(index, builderForValue.build());
          onChanged();
        } else {
          inputBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder addInput(Onnx.ValueInfoProto value) {
        if (inputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputIsMutable();
          input_.add(value);
          onChanged();
        } else {
          inputBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder addInput(
          int index, Onnx.ValueInfoProto value) {
        if (inputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureInputIsMutable();
          input_.add(index, value);
          onChanged();
        } else {
          inputBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder addInput(
          Onnx.ValueInfoProto.Builder builderForValue) {
        if (inputBuilder_ == null) {
          ensureInputIsMutable();
          input_.add(builderForValue.build());
          onChanged();
        } else {
          inputBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder addInput(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (inputBuilder_ == null) {
          ensureInputIsMutable();
          input_.add(index, builderForValue.build());
          onChanged();
        } else {
          inputBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder addAllInput(
          java.lang.Iterable<? extends Onnx.ValueInfoProto> values) {
        if (inputBuilder_ == null) {
          ensureInputIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, input_);
          onChanged();
        } else {
          inputBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder clearInput() {
        if (inputBuilder_ == null) {
          input_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          inputBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Builder removeInput(int index) {
        if (inputBuilder_ == null) {
          ensureInputIsMutable();
          input_.remove(index);
          onChanged();
        } else {
          inputBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Onnx.ValueInfoProto.Builder getInputBuilder(
          int index) {
        return internalGetInputFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Onnx.ValueInfoProtoOrBuilder getInputOrBuilder(
          int index) {
        if (inputBuilder_ == null) {
          return input_.get(index);  } else {
          return inputBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
           getInputOrBuilderList() {
        if (inputBuilder_ != null) {
          return inputBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(input_);
        }
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Onnx.ValueInfoProto.Builder addInputBuilder() {
        return internalGetInputFieldBuilder().addBuilder(
            Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public Onnx.ValueInfoProto.Builder addInputBuilder(
          int index) {
        return internalGetInputFieldBuilder().addBuilder(
            index, Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The inputs and outputs of the graph.
       * </pre>
       *
       * <code>repeated .ValueInfoProto input = 11;</code>
       */
      public java.util.List<Onnx.ValueInfoProto.Builder> 
           getInputBuilderList() {
        return internalGetInputFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> 
          internalGetInputFieldBuilder() {
        if (inputBuilder_ == null) {
          inputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder>(
                  input_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          input_ = null;
        }
        return inputBuilder_;
      }

      private java.util.List<Onnx.ValueInfoProto> output_ =
        java.util.Collections.emptyList();
      private void ensureOutputIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          output_ = new java.util.ArrayList<Onnx.ValueInfoProto>(output_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> outputBuilder_;

      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public java.util.List<Onnx.ValueInfoProto> getOutputList() {
        if (outputBuilder_ == null) {
          return java.util.Collections.unmodifiableList(output_);
        } else {
          return outputBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public int getOutputCount() {
        if (outputBuilder_ == null) {
          return output_.size();
        } else {
          return outputBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Onnx.ValueInfoProto getOutput(int index) {
        if (outputBuilder_ == null) {
          return output_.get(index);
        } else {
          return outputBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder setOutput(
          int index, Onnx.ValueInfoProto value) {
        if (outputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputIsMutable();
          output_.set(index, value);
          onChanged();
        } else {
          outputBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder setOutput(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (outputBuilder_ == null) {
          ensureOutputIsMutable();
          output_.set(index, builderForValue.build());
          onChanged();
        } else {
          outputBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder addOutput(Onnx.ValueInfoProto value) {
        if (outputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputIsMutable();
          output_.add(value);
          onChanged();
        } else {
          outputBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder addOutput(
          int index, Onnx.ValueInfoProto value) {
        if (outputBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOutputIsMutable();
          output_.add(index, value);
          onChanged();
        } else {
          outputBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder addOutput(
          Onnx.ValueInfoProto.Builder builderForValue) {
        if (outputBuilder_ == null) {
          ensureOutputIsMutable();
          output_.add(builderForValue.build());
          onChanged();
        } else {
          outputBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder addOutput(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (outputBuilder_ == null) {
          ensureOutputIsMutable();
          output_.add(index, builderForValue.build());
          onChanged();
        } else {
          outputBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder addAllOutput(
          java.lang.Iterable<? extends Onnx.ValueInfoProto> values) {
        if (outputBuilder_ == null) {
          ensureOutputIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, output_);
          onChanged();
        } else {
          outputBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder clearOutput() {
        if (outputBuilder_ == null) {
          output_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          outputBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Builder removeOutput(int index) {
        if (outputBuilder_ == null) {
          ensureOutputIsMutable();
          output_.remove(index);
          onChanged();
        } else {
          outputBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder getOutputBuilder(
          int index) {
        return internalGetOutputFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Onnx.ValueInfoProtoOrBuilder getOutputOrBuilder(
          int index) {
        if (outputBuilder_ == null) {
          return output_.get(index);  } else {
          return outputBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
           getOutputOrBuilderList() {
        if (outputBuilder_ != null) {
          return outputBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(output_);
        }
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder addOutputBuilder() {
        return internalGetOutputFieldBuilder().addBuilder(
            Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder addOutputBuilder(
          int index) {
        return internalGetOutputFieldBuilder().addBuilder(
            index, Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <code>repeated .ValueInfoProto output = 12;</code>
       */
      public java.util.List<Onnx.ValueInfoProto.Builder> 
           getOutputBuilderList() {
        return internalGetOutputFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> 
          internalGetOutputFieldBuilder() {
        if (outputBuilder_ == null) {
          outputBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder>(
                  output_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          output_ = null;
        }
        return outputBuilder_;
      }

      private java.util.List<Onnx.ValueInfoProto> valueInfo_ =
        java.util.Collections.emptyList();
      private void ensureValueInfoIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          valueInfo_ = new java.util.ArrayList<Onnx.ValueInfoProto>(valueInfo_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> valueInfoBuilder_;

      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public java.util.List<Onnx.ValueInfoProto> getValueInfoList() {
        if (valueInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(valueInfo_);
        } else {
          return valueInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public int getValueInfoCount() {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.size();
        } else {
          return valueInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Onnx.ValueInfoProto getValueInfo(int index) {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.get(index);
        } else {
          return valueInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder setValueInfo(
          int index, Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.set(index, value);
          onChanged();
        } else {
          valueInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder setValueInfo(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder addValueInfo(Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.add(value);
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder addValueInfo(
          int index, Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.add(index, value);
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder addValueInfo(
          Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.add(builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder addValueInfo(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder addAllValueInfo(
          java.lang.Iterable<? extends Onnx.ValueInfoProto> values) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, valueInfo_);
          onChanged();
        } else {
          valueInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder clearValueInfo() {
        if (valueInfoBuilder_ == null) {
          valueInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          valueInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Builder removeValueInfo(int index) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.remove(index);
          onChanged();
        } else {
          valueInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Onnx.ValueInfoProto.Builder getValueInfoBuilder(
          int index) {
        return internalGetValueInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
          int index) {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.get(index);  } else {
          return valueInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
           getValueInfoOrBuilderList() {
        if (valueInfoBuilder_ != null) {
          return valueInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(valueInfo_);
        }
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Onnx.ValueInfoProto.Builder addValueInfoBuilder() {
        return internalGetValueInfoFieldBuilder().addBuilder(
            Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public Onnx.ValueInfoProto.Builder addValueInfoBuilder(
          int index) {
        return internalGetValueInfoFieldBuilder().addBuilder(
            index, Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Information for the values in the graph. The ValueInfoProto.name's
       * must be distinct. It is optional for a value to appear in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 13;</code>
       */
      public java.util.List<Onnx.ValueInfoProto.Builder> 
           getValueInfoBuilderList() {
        return internalGetValueInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> 
          internalGetValueInfoFieldBuilder() {
        if (valueInfoBuilder_ == null) {
          valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder>(
                  valueInfo_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          valueInfo_ = null;
        }
        return valueInfoBuilder_;
      }

      private java.util.List<Onnx.TensorAnnotation> quantizationAnnotation_ =
        java.util.Collections.emptyList();
      private void ensureQuantizationAnnotationIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          quantizationAnnotation_ = new java.util.ArrayList<Onnx.TensorAnnotation>(quantizationAnnotation_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorAnnotation, Onnx.TensorAnnotation.Builder, Onnx.TensorAnnotationOrBuilder> quantizationAnnotationBuilder_;

      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public java.util.List<Onnx.TensorAnnotation> getQuantizationAnnotationList() {
        if (quantizationAnnotationBuilder_ == null) {
          return java.util.Collections.unmodifiableList(quantizationAnnotation_);
        } else {
          return quantizationAnnotationBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public int getQuantizationAnnotationCount() {
        if (quantizationAnnotationBuilder_ == null) {
          return quantizationAnnotation_.size();
        } else {
          return quantizationAnnotationBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Onnx.TensorAnnotation getQuantizationAnnotation(int index) {
        if (quantizationAnnotationBuilder_ == null) {
          return quantizationAnnotation_.get(index);
        } else {
          return quantizationAnnotationBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder setQuantizationAnnotation(
          int index, Onnx.TensorAnnotation value) {
        if (quantizationAnnotationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.set(index, value);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder setQuantizationAnnotation(
          int index, Onnx.TensorAnnotation.Builder builderForValue) {
        if (quantizationAnnotationBuilder_ == null) {
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.set(index, builderForValue.build());
          onChanged();
        } else {
          quantizationAnnotationBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder addQuantizationAnnotation(Onnx.TensorAnnotation value) {
        if (quantizationAnnotationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.add(value);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder addQuantizationAnnotation(
          int index, Onnx.TensorAnnotation value) {
        if (quantizationAnnotationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.add(index, value);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder addQuantizationAnnotation(
          Onnx.TensorAnnotation.Builder builderForValue) {
        if (quantizationAnnotationBuilder_ == null) {
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.add(builderForValue.build());
          onChanged();
        } else {
          quantizationAnnotationBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder addQuantizationAnnotation(
          int index, Onnx.TensorAnnotation.Builder builderForValue) {
        if (quantizationAnnotationBuilder_ == null) {
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.add(index, builderForValue.build());
          onChanged();
        } else {
          quantizationAnnotationBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder addAllQuantizationAnnotation(
          java.lang.Iterable<? extends Onnx.TensorAnnotation> values) {
        if (quantizationAnnotationBuilder_ == null) {
          ensureQuantizationAnnotationIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, quantizationAnnotation_);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder clearQuantizationAnnotation() {
        if (quantizationAnnotationBuilder_ == null) {
          quantizationAnnotation_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Builder removeQuantizationAnnotation(int index) {
        if (quantizationAnnotationBuilder_ == null) {
          ensureQuantizationAnnotationIsMutable();
          quantizationAnnotation_.remove(index);
          onChanged();
        } else {
          quantizationAnnotationBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Onnx.TensorAnnotation.Builder getQuantizationAnnotationBuilder(
          int index) {
        return internalGetQuantizationAnnotationFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Onnx.TensorAnnotationOrBuilder getQuantizationAnnotationOrBuilder(
          int index) {
        if (quantizationAnnotationBuilder_ == null) {
          return quantizationAnnotation_.get(index);  } else {
          return quantizationAnnotationBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public java.util.List<? extends Onnx.TensorAnnotationOrBuilder> 
           getQuantizationAnnotationOrBuilderList() {
        if (quantizationAnnotationBuilder_ != null) {
          return quantizationAnnotationBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(quantizationAnnotation_);
        }
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Onnx.TensorAnnotation.Builder addQuantizationAnnotationBuilder() {
        return internalGetQuantizationAnnotationFieldBuilder().addBuilder(
            Onnx.TensorAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public Onnx.TensorAnnotation.Builder addQuantizationAnnotationBuilder(
          int index) {
        return internalGetQuantizationAnnotationFieldBuilder().addBuilder(
            index, Onnx.TensorAnnotation.getDefaultInstance());
      }
      /**
       * <pre>
       * This field carries information to indicate the mapping among a tensor and its
       * quantization parameter tensors. For example:
       * For tensor 'a', it may have {'SCALE_TENSOR', 'a_scale'} and {'ZERO_POINT_TENSOR', 'a_zero_point'} annotated,
       * which means, tensor 'a_scale' and tensor 'a_zero_point' are scale and zero point of tensor 'a' in the model.
       * </pre>
       *
       * <code>repeated .TensorAnnotation quantization_annotation = 14;</code>
       */
      public java.util.List<Onnx.TensorAnnotation.Builder> 
           getQuantizationAnnotationBuilderList() {
        return internalGetQuantizationAnnotationFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorAnnotation, Onnx.TensorAnnotation.Builder, Onnx.TensorAnnotationOrBuilder> 
          internalGetQuantizationAnnotationFieldBuilder() {
        if (quantizationAnnotationBuilder_ == null) {
          quantizationAnnotationBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TensorAnnotation, Onnx.TensorAnnotation.Builder, Onnx.TensorAnnotationOrBuilder>(
                  quantizationAnnotation_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          quantizationAnnotation_ = null;
        }
        return quantizationAnnotationBuilder_;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:GraphProto)
    }

    // @@protoc_insertion_point(class_scope:GraphProto)
    private static final Onnx.GraphProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.GraphProto();
    }

    public static Onnx.GraphProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GraphProto>
        PARSER = new com.google.protobuf.AbstractParser<GraphProto>() {
      @java.lang.Override
      public GraphProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<GraphProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GraphProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.GraphProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TensorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TensorProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @return A list containing the dims.
     */
    java.util.List<java.lang.Long> getDimsList();
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @return The count of dims.
     */
    int getDimsCount();
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @param index The index of the element to return.
     * @return The dims at the given index.
     */
    long getDims(int index);

    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>optional int32 data_type = 2;</code>
     * @return Whether the dataType field is set.
     */
    boolean hasDataType();
    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>optional int32 data_type = 2;</code>
     * @return The dataType.
     */
    int getDataType();

    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     * @return Whether the segment field is set.
     */
    boolean hasSegment();
    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     * @return The segment.
     */
    Onnx.TensorProto.Segment getSegment();
    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     */
    Onnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder();

    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @return A list containing the floatData.
     */
    java.util.List<java.lang.Float> getFloatDataList();
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @return The count of floatData.
     */
    int getFloatDataCount();
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The floatData at the given index.
     */
    float getFloatData(int index);

    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @return A list containing the int32Data.
     */
    java.util.List<java.lang.Integer> getInt32DataList();
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @return The count of int32Data.
     */
    int getInt32DataCount();
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The int32Data at the given index.
     */
    int getInt32Data(int index);

    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @return A list containing the stringData.
     */
    java.util.List<com.google.protobuf.ByteString> getStringDataList();
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @return The count of stringData.
     */
    int getStringDataCount();
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @param index The index of the element to return.
     * @return The stringData at the given index.
     */
    com.google.protobuf.ByteString getStringData(int index);

    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @return A list containing the int64Data.
     */
    java.util.List<java.lang.Long> getInt64DataList();
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @return The count of int64Data.
     */
    int getInt64DataCount();
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The int64Data at the given index.
     */
    long getInt64Data(int index);

    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     *
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
     *
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>optional bytes raw_data = 9;</code>
     * @return Whether the rawData field is set.
     */
    boolean hasRawData();
    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     *
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
     *
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>optional bytes raw_data = 9;</code>
     * @return The rawData.
     */
    com.google.protobuf.ByteString getRawData();

    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getExternalDataList();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    Onnx.StringStringEntryProto getExternalData(int index);
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    int getExternalDataCount();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getExternalDataOrBuilderList();
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
        int index);

    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>optional .TensorProto.DataLocation data_location = 14;</code>
     * @return Whether the dataLocation field is set.
     */
    boolean hasDataLocation();
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>optional .TensorProto.DataLocation data_location = 14;</code>
     * @return The dataLocation.
     */
    Onnx.TensorProto.DataLocation getDataLocation();

    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @return A list containing the doubleData.
     */
    java.util.List<java.lang.Double> getDoubleDataList();
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @return The count of doubleData.
     */
    int getDoubleDataCount();
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The doubleData at the given index.
     */
    double getDoubleData(int index);

    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @return A list containing the uint64Data.
     */
    java.util.List<java.lang.Long> getUint64DataList();
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @return The count of uint64Data.
     */
    int getUint64DataCount();
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The uint64Data at the given index.
     */
    long getUint64Data(int index);

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Tensors
   *
   * A serialized tensor value.
   * </pre>
   *
   * Protobuf type {@code TensorProto}
   */
  public static final class TensorProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:TensorProto)
      TensorProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        TensorProto.class.getName());
    }
    // Use TensorProto.newBuilder() to construct.
    private TensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TensorProto() {
      dims_ = emptyLongList();
      floatData_ = emptyFloatList();
      int32Data_ = emptyIntList();
      stringData_ = emptyList(com.google.protobuf.ByteString.class);
      int64Data_ = emptyLongList();
      name_ = "";
      docString_ = "";
      rawData_ = com.google.protobuf.ByteString.EMPTY;
      externalData_ = java.util.Collections.emptyList();
      dataLocation_ = 0;
      doubleData_ = emptyDoubleList();
      uint64Data_ = emptyLongList();
      metadataProps_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_TensorProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_TensorProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.TensorProto.class, Onnx.TensorProto.Builder.class);
    }

    /**
     * Protobuf enum {@code TensorProto.DataType}
     */
    public enum DataType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNDEFINED = 0;</code>
       */
      UNDEFINED(0),
      /**
       * <pre>
       * Basic types.
       * </pre>
       *
       * <code>FLOAT = 1;</code>
       */
      FLOAT(1),
      /**
       * <pre>
       * uint8_t
       * </pre>
       *
       * <code>UINT8 = 2;</code>
       */
      UINT8(2),
      /**
       * <pre>
       * int8_t
       * </pre>
       *
       * <code>INT8 = 3;</code>
       */
      INT8(3),
      /**
       * <pre>
       * uint16_t
       * </pre>
       *
       * <code>UINT16 = 4;</code>
       */
      UINT16(4),
      /**
       * <pre>
       * int16_t
       * </pre>
       *
       * <code>INT16 = 5;</code>
       */
      INT16(5),
      /**
       * <pre>
       * int32_t
       * </pre>
       *
       * <code>INT32 = 6;</code>
       */
      INT32(6),
      /**
       * <pre>
       * int64_t
       * </pre>
       *
       * <code>INT64 = 7;</code>
       */
      INT64(7),
      /**
       * <pre>
       * string
       * </pre>
       *
       * <code>STRING = 8;</code>
       */
      STRING(8),
      /**
       * <pre>
       * bool
       * </pre>
       *
       * <code>BOOL = 9;</code>
       */
      BOOL(9),
      /**
       * <pre>
       * IEEE754 half-precision floating-point format (16 bits wide).
       * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
       * </pre>
       *
       * <code>FLOAT16 = 10;</code>
       */
      FLOAT16(10),
      /**
       * <code>DOUBLE = 11;</code>
       */
      DOUBLE(11),
      /**
       * <code>UINT32 = 12;</code>
       */
      UINT32(12),
      /**
       * <code>UINT64 = 13;</code>
       */
      UINT64(13),
      /**
       * <pre>
       * complex with float32 real and imaginary components
       * </pre>
       *
       * <code>COMPLEX64 = 14;</code>
       */
      COMPLEX64(14),
      /**
       * <pre>
       * complex with float64 real and imaginary components
       * </pre>
       *
       * <code>COMPLEX128 = 15;</code>
       */
      COMPLEX128(15),
      /**
       * <pre>
       * Non-IEEE floating-point format based on IEEE754 single-precision
       * floating-point number truncated to 16 bits.
       * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
       * </pre>
       *
       * <code>BFLOAT16 = 16;</code>
       */
      BFLOAT16(16),
      /**
       * <pre>
       * Non-IEEE floating-point format based on papers
       * FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
       * 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
       * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
       * The computation usually happens inside a block quantize / dequantize
       * fused by the runtime.
       * </pre>
       *
       * <code>FLOAT8E4M3FN = 17;</code>
       */
      FLOAT8E4M3FN(17),
      /**
       * <pre>
       * float 8, mostly used for coefficients, supports nan, not inf, no negative zero
       * </pre>
       *
       * <code>FLOAT8E4M3FNUZ = 18;</code>
       */
      FLOAT8E4M3FNUZ(18),
      /**
       * <pre>
       * follows IEEE 754, supports nan, inf, mostly used for gradients
       * </pre>
       *
       * <code>FLOAT8E5M2 = 19;</code>
       */
      FLOAT8E5M2(19),
      /**
       * <pre>
       * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
       * </pre>
       *
       * <code>FLOAT8E5M2FNUZ = 20;</code>
       */
      FLOAT8E5M2FNUZ(20),
      /**
       * <pre>
       * 4-bit integer data types
       * </pre>
       *
       * <code>UINT4 = 21;</code>
       */
      UINT4(21),
      /**
       * <pre>
       * Signed integer in range [-8, 7], using two's-complement representation
       * </pre>
       *
       * <code>INT4 = 22;</code>
       */
      INT4(22),
      /**
       * <pre>
       * 4-bit floating point data types
       * </pre>
       *
       * <code>FLOAT4E2M1 = 23;</code>
       */
      FLOAT4E2M1(23),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          DataType.class.getName());
      }
      /**
       * <code>UNDEFINED = 0;</code>
       */
      public static final int UNDEFINED_VALUE = 0;
      /**
       * <pre>
       * Basic types.
       * </pre>
       *
       * <code>FLOAT = 1;</code>
       */
      public static final int FLOAT_VALUE = 1;
      /**
       * <pre>
       * uint8_t
       * </pre>
       *
       * <code>UINT8 = 2;</code>
       */
      public static final int UINT8_VALUE = 2;
      /**
       * <pre>
       * int8_t
       * </pre>
       *
       * <code>INT8 = 3;</code>
       */
      public static final int INT8_VALUE = 3;
      /**
       * <pre>
       * uint16_t
       * </pre>
       *
       * <code>UINT16 = 4;</code>
       */
      public static final int UINT16_VALUE = 4;
      /**
       * <pre>
       * int16_t
       * </pre>
       *
       * <code>INT16 = 5;</code>
       */
      public static final int INT16_VALUE = 5;
      /**
       * <pre>
       * int32_t
       * </pre>
       *
       * <code>INT32 = 6;</code>
       */
      public static final int INT32_VALUE = 6;
      /**
       * <pre>
       * int64_t
       * </pre>
       *
       * <code>INT64 = 7;</code>
       */
      public static final int INT64_VALUE = 7;
      /**
       * <pre>
       * string
       * </pre>
       *
       * <code>STRING = 8;</code>
       */
      public static final int STRING_VALUE = 8;
      /**
       * <pre>
       * bool
       * </pre>
       *
       * <code>BOOL = 9;</code>
       */
      public static final int BOOL_VALUE = 9;
      /**
       * <pre>
       * IEEE754 half-precision floating-point format (16 bits wide).
       * This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
       * </pre>
       *
       * <code>FLOAT16 = 10;</code>
       */
      public static final int FLOAT16_VALUE = 10;
      /**
       * <code>DOUBLE = 11;</code>
       */
      public static final int DOUBLE_VALUE = 11;
      /**
       * <code>UINT32 = 12;</code>
       */
      public static final int UINT32_VALUE = 12;
      /**
       * <code>UINT64 = 13;</code>
       */
      public static final int UINT64_VALUE = 13;
      /**
       * <pre>
       * complex with float32 real and imaginary components
       * </pre>
       *
       * <code>COMPLEX64 = 14;</code>
       */
      public static final int COMPLEX64_VALUE = 14;
      /**
       * <pre>
       * complex with float64 real and imaginary components
       * </pre>
       *
       * <code>COMPLEX128 = 15;</code>
       */
      public static final int COMPLEX128_VALUE = 15;
      /**
       * <pre>
       * Non-IEEE floating-point format based on IEEE754 single-precision
       * floating-point number truncated to 16 bits.
       * This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
       * </pre>
       *
       * <code>BFLOAT16 = 16;</code>
       */
      public static final int BFLOAT16_VALUE = 16;
      /**
       * <pre>
       * Non-IEEE floating-point format based on papers
       * FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
       * 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
       * Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
       * The computation usually happens inside a block quantize / dequantize
       * fused by the runtime.
       * </pre>
       *
       * <code>FLOAT8E4M3FN = 17;</code>
       */
      public static final int FLOAT8E4M3FN_VALUE = 17;
      /**
       * <pre>
       * float 8, mostly used for coefficients, supports nan, not inf, no negative zero
       * </pre>
       *
       * <code>FLOAT8E4M3FNUZ = 18;</code>
       */
      public static final int FLOAT8E4M3FNUZ_VALUE = 18;
      /**
       * <pre>
       * follows IEEE 754, supports nan, inf, mostly used for gradients
       * </pre>
       *
       * <code>FLOAT8E5M2 = 19;</code>
       */
      public static final int FLOAT8E5M2_VALUE = 19;
      /**
       * <pre>
       * follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
       * </pre>
       *
       * <code>FLOAT8E5M2FNUZ = 20;</code>
       */
      public static final int FLOAT8E5M2FNUZ_VALUE = 20;
      /**
       * <pre>
       * 4-bit integer data types
       * </pre>
       *
       * <code>UINT4 = 21;</code>
       */
      public static final int UINT4_VALUE = 21;
      /**
       * <pre>
       * Signed integer in range [-8, 7], using two's-complement representation
       * </pre>
       *
       * <code>INT4 = 22;</code>
       */
      public static final int INT4_VALUE = 22;
      /**
       * <pre>
       * 4-bit floating point data types
       * </pre>
       *
       * <code>FLOAT4E2M1 = 23;</code>
       */
      public static final int FLOAT4E2M1_VALUE = 23;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DataType valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static DataType forNumber(int value) {
        switch (value) {
          case 0: return UNDEFINED;
          case 1: return FLOAT;
          case 2: return UINT8;
          case 3: return INT8;
          case 4: return UINT16;
          case 5: return INT16;
          case 6: return INT32;
          case 7: return INT64;
          case 8: return STRING;
          case 9: return BOOL;
          case 10: return FLOAT16;
          case 11: return DOUBLE;
          case 12: return UINT32;
          case 13: return UINT64;
          case 14: return COMPLEX64;
          case 15: return COMPLEX128;
          case 16: return BFLOAT16;
          case 17: return FLOAT8E4M3FN;
          case 18: return FLOAT8E4M3FNUZ;
          case 19: return FLOAT8E5M2;
          case 20: return FLOAT8E5M2FNUZ;
          case 21: return UINT4;
          case 22: return INT4;
          case 23: return FLOAT4E2M1;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<DataType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          DataType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<DataType>() {
              public DataType findValueByNumber(int number) {
                return DataType.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return Onnx.TensorProto.getDescriptor().getEnumTypes().get(0);
      }

      private static final DataType[] VALUES = values();

      public static DataType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private DataType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:TensorProto.DataType)
    }

    /**
     * <pre>
     * Location of the data for this tensor. MUST be one of:
     * - DEFAULT - data stored inside the protobuf message. Data is stored in raw_data (if set) otherwise in type-specified field.
     * - EXTERNAL - data stored in an external location as described by external_data field.
     * </pre>
     *
     * Protobuf enum {@code TensorProto.DataLocation}
     */
    public enum DataLocation
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>DEFAULT = 0;</code>
       */
      DEFAULT(0),
      /**
       * <code>EXTERNAL = 1;</code>
       */
      EXTERNAL(1),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          DataLocation.class.getName());
      }
      /**
       * <code>DEFAULT = 0;</code>
       */
      public static final int DEFAULT_VALUE = 0;
      /**
       * <code>EXTERNAL = 1;</code>
       */
      public static final int EXTERNAL_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DataLocation valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static DataLocation forNumber(int value) {
        switch (value) {
          case 0: return DEFAULT;
          case 1: return EXTERNAL;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<DataLocation>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          DataLocation> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<DataLocation>() {
              public DataLocation findValueByNumber(int number) {
                return DataLocation.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return Onnx.TensorProto.getDescriptor().getEnumTypes().get(1);
      }

      private static final DataLocation[] VALUES = values();

      public static DataLocation valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private DataLocation(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:TensorProto.DataLocation)
    }

    public interface SegmentOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TensorProto.Segment)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional int64 begin = 1;</code>
       * @return Whether the begin field is set.
       */
      boolean hasBegin();
      /**
       * <code>optional int64 begin = 1;</code>
       * @return The begin.
       */
      long getBegin();

      /**
       * <code>optional int64 end = 2;</code>
       * @return Whether the end field is set.
       */
      boolean hasEnd();
      /**
       * <code>optional int64 end = 2;</code>
       * @return The end.
       */
      long getEnd();
    }
    /**
     * <pre>
     * For very large tensors, we may want to store them in chunks, in which
     * case the following fields will specify the segment that is stored in
     * the current TensorProto.
     * </pre>
     *
     * Protobuf type {@code TensorProto.Segment}
     */
    public static final class Segment extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TensorProto.Segment)
        SegmentOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Segment.class.getName());
      }
      // Use Segment.newBuilder() to construct.
      private Segment(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Segment() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TensorProto_Segment_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TensorProto.Segment.class, Onnx.TensorProto.Segment.Builder.class);
      }

      private int bitField0_;
      public static final int BEGIN_FIELD_NUMBER = 1;
      private long begin_ = 0L;
      /**
       * <code>optional int64 begin = 1;</code>
       * @return Whether the begin field is set.
       */
      @java.lang.Override
      public boolean hasBegin() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional int64 begin = 1;</code>
       * @return The begin.
       */
      @java.lang.Override
      public long getBegin() {
        return begin_;
      }

      public static final int END_FIELD_NUMBER = 2;
      private long end_ = 0L;
      /**
       * <code>optional int64 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int64 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public long getEnd() {
        return end_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt64(1, begin_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeInt64(2, end_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(1, begin_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(2, end_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TensorProto.Segment)) {
          return super.equals(obj);
        }
        Onnx.TensorProto.Segment other = (Onnx.TensorProto.Segment) obj;

        if (hasBegin() != other.hasBegin()) return false;
        if (hasBegin()) {
          if (getBegin()
              != other.getBegin()) return false;
        }
        if (hasEnd() != other.hasEnd()) return false;
        if (hasEnd()) {
          if (getEnd()
              != other.getEnd()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasBegin()) {
          hash = (37 * hash) + BEGIN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getBegin());
        }
        if (hasEnd()) {
          hash = (37 * hash) + END_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getEnd());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TensorProto.Segment parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorProto.Segment parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorProto.Segment parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TensorProto.Segment parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TensorProto.Segment parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TensorProto.Segment parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TensorProto.Segment prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * For very large tensors, we may want to store them in chunks, in which
       * case the following fields will specify the segment that is stored in
       * the current TensorProto.
       * </pre>
       *
       * Protobuf type {@code TensorProto.Segment}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TensorProto.Segment)
          Onnx.TensorProto.SegmentOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TensorProto_Segment_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TensorProto_Segment_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TensorProto.Segment.class, Onnx.TensorProto.Segment.Builder.class);
        }

        // Construct using Onnx.TensorProto.Segment.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          begin_ = 0L;
          end_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TensorProto_Segment_descriptor;
        }

        @java.lang.Override
        public Onnx.TensorProto.Segment getDefaultInstanceForType() {
          return Onnx.TensorProto.Segment.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TensorProto.Segment build() {
          Onnx.TensorProto.Segment result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TensorProto.Segment buildPartial() {
          Onnx.TensorProto.Segment result = new Onnx.TensorProto.Segment(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TensorProto.Segment result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.begin_ = begin_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.end_ = end_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TensorProto.Segment) {
            return mergeFrom((Onnx.TensorProto.Segment)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TensorProto.Segment other) {
          if (other == Onnx.TensorProto.Segment.getDefaultInstance()) return this;
          if (other.hasBegin()) {
            setBegin(other.getBegin());
          }
          if (other.hasEnd()) {
            setEnd(other.getEnd());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  begin_ = input.readInt64();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  end_ = input.readInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private long begin_ ;
        /**
         * <code>optional int64 begin = 1;</code>
         * @return Whether the begin field is set.
         */
        @java.lang.Override
        public boolean hasBegin() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional int64 begin = 1;</code>
         * @return The begin.
         */
        @java.lang.Override
        public long getBegin() {
          return begin_;
        }
        /**
         * <code>optional int64 begin = 1;</code>
         * @param value The begin to set.
         * @return This builder for chaining.
         */
        public Builder setBegin(long value) {

          begin_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional int64 begin = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearBegin() {
          bitField0_ = (bitField0_ & ~0x00000001);
          begin_ = 0L;
          onChanged();
          return this;
        }

        private long end_ ;
        /**
         * <code>optional int64 end = 2;</code>
         * @return Whether the end field is set.
         */
        @java.lang.Override
        public boolean hasEnd() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional int64 end = 2;</code>
         * @return The end.
         */
        @java.lang.Override
        public long getEnd() {
          return end_;
        }
        /**
         * <code>optional int64 end = 2;</code>
         * @param value The end to set.
         * @return This builder for chaining.
         */
        public Builder setEnd(long value) {

          end_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional int64 end = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnd() {
          bitField0_ = (bitField0_ & ~0x00000002);
          end_ = 0L;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:TensorProto.Segment)
      }

      // @@protoc_insertion_point(class_scope:TensorProto.Segment)
      private static final Onnx.TensorProto.Segment DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TensorProto.Segment();
      }

      public static Onnx.TensorProto.Segment getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Segment>
          PARSER = new com.google.protobuf.AbstractParser<Segment>() {
        @java.lang.Override
        public Segment parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Segment> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Segment> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TensorProto.Segment getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int DIMS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList dims_ =
        emptyLongList();
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @return A list containing the dims.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getDimsList() {
      return dims_;
    }
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @return The count of dims.
     */
    public int getDimsCount() {
      return dims_.size();
    }
    /**
     * <pre>
     * The shape of the tensor.
     * </pre>
     *
     * <code>repeated int64 dims = 1;</code>
     * @param index The index of the element to return.
     * @return The dims at the given index.
     */
    public long getDims(int index) {
      return dims_.getLong(index);
    }

    public static final int DATA_TYPE_FIELD_NUMBER = 2;
    private int dataType_ = 0;
    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>optional int32 data_type = 2;</code>
     * @return Whether the dataType field is set.
     */
    @java.lang.Override
    public boolean hasDataType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The data type of the tensor.
     * This field MUST have a valid TensorProto.DataType value
     * </pre>
     *
     * <code>optional int32 data_type = 2;</code>
     * @return The dataType.
     */
    @java.lang.Override
    public int getDataType() {
      return dataType_;
    }

    public static final int SEGMENT_FIELD_NUMBER = 3;
    private Onnx.TensorProto.Segment segment_;
    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     * @return Whether the segment field is set.
     */
    @java.lang.Override
    public boolean hasSegment() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     * @return The segment.
     */
    @java.lang.Override
    public Onnx.TensorProto.Segment getSegment() {
      return segment_ == null ? Onnx.TensorProto.Segment.getDefaultInstance() : segment_;
    }
    /**
     * <code>optional .TensorProto.Segment segment = 3;</code>
     */
    @java.lang.Override
    public Onnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
      return segment_ == null ? Onnx.TensorProto.Segment.getDefaultInstance() : segment_;
    }

    public static final int FLOAT_DATA_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.FloatList floatData_ =
        emptyFloatList();
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @return A list containing the floatData.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getFloatDataList() {
      return floatData_;
    }
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @return The count of floatData.
     */
    public int getFloatDataCount() {
      return floatData_.size();
    }
    /**
     * <pre>
     * For float and complex64 values
     * Complex64 tensors are encoded as a single array of floats,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
     * </pre>
     *
     * <code>repeated float float_data = 4 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The floatData at the given index.
     */
    public float getFloatData(int index) {
      return floatData_.getFloat(index);
    }
    private int floatDataMemoizedSerializedSize = -1;

    public static final int INT32_DATA_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList int32Data_ =
        emptyIntList();
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @return A list containing the int32Data.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getInt32DataList() {
      return int32Data_;
    }
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @return The count of int32Data.
     */
    public int getInt32DataCount() {
      return int32Data_.size();
    }
    /**
     * <pre>
     * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
     * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
     * representation before being written to the buffer.
     * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
     * The first element is stored in the 4 least significant bits (LSB),
     * and the second element is stored in the 4 most significant bits (MSB).
     *
     * Consequently:
     * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
     * - For 4-bit data types, each `int32_data` stores two elements.
     *
     * When this field is present, the data_type field MUST be
     * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
     * </pre>
     *
     * <code>repeated int32 int32_data = 5 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The int32Data at the given index.
     */
    public int getInt32Data(int index) {
      return int32Data_.getInt(index);
    }
    private int int32DataMemoizedSerializedSize = -1;

    public static final int STRING_DATA_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ =
        emptyList(com.google.protobuf.ByteString.class);
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @return A list containing the stringData.
     */
    @java.lang.Override
    public java.util.List<com.google.protobuf.ByteString>
        getStringDataList() {
      return stringData_;
    }
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @return The count of stringData.
     */
    public int getStringDataCount() {
      return stringData_.size();
    }
    /**
     * <pre>
     * For strings.
     * Each element of string_data is a UTF-8 encoded Unicode
     * string. No trailing null, no leading BOM. The protobuf "string"
     * scalar type is not used to match ML community conventions.
     * When this field is present, the data_type field MUST be STRING
     * </pre>
     *
     * <code>repeated bytes string_data = 6;</code>
     * @param index The index of the element to return.
     * @return The stringData at the given index.
     */
    public com.google.protobuf.ByteString getStringData(int index) {
      return stringData_.get(index);
    }

    public static final int INT64_DATA_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList int64Data_ =
        emptyLongList();
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @return A list containing the int64Data.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getInt64DataList() {
      return int64Data_;
    }
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @return The count of int64Data.
     */
    public int getInt64DataCount() {
      return int64Data_.size();
    }
    /**
     * <pre>
     * For int64.
     * When this field is present, the data_type field MUST be INT64
     * </pre>
     *
     * <code>repeated int64 int64_data = 7 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The int64Data at the given index.
     */
    public long getInt64Data(int index) {
      return int64Data_.getLong(index);
    }
    private int int64DataMemoizedSerializedSize = -1;

    public static final int NAME_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Optionally, a name for the tensor.
     * </pre>
     *
     * <code>optional string name = 8;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DOC_STRING_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this tensor. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 12;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RAW_DATA_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     *
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
     *
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>optional bytes raw_data = 9;</code>
     * @return Whether the rawData field is set.
     */
    @java.lang.Override
    public boolean hasRawData() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Serializations can either use one of the fields above, or use this
     * raw bytes field. The only exception is the string case, where one is
     * required to store the content in the repeated bytes string_data field.
     *
     * When this raw_data field is used to store tensor value, elements MUST
     * be stored in as fixed-width, little-endian order.
     * Floating-point data types MUST be stored in IEEE 754 format.
     * Complex64 elements must be written as two consecutive FLOAT values, real component first.
     * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
     * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
     * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
     *
     * Note: the advantage of specific field rather than the raw_data field is
     * that in some cases (e.g. int data), protobuf does a better packing via
     * variable length storage, and may lead to smaller binary footprint.
     * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
     * </pre>
     *
     * <code>optional bytes raw_data = 9;</code>
     * @return The rawData.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getRawData() {
      return rawData_;
    }

    public static final int EXTERNAL_DATA_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> externalData_;
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getExternalDataList() {
      return externalData_;
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getExternalDataOrBuilderList() {
      return externalData_;
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    @java.lang.Override
    public int getExternalDataCount() {
      return externalData_.size();
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getExternalData(int index) {
      return externalData_.get(index);
    }
    /**
     * <pre>
     * Data can be stored inside the protobuf file using type-specific fields or raw_data.
     * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
     * external_data stores key-value pairs describing data location. Recognized keys are:
     * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
     * protobuf model was stored
     * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
     * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
     * - "length" (optional) - number of bytes containing data. Integer stored as string.
     * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto external_data = 13;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
        int index) {
      return externalData_.get(index);
    }

    public static final int DATA_LOCATION_FIELD_NUMBER = 14;
    private int dataLocation_ = 0;
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>optional .TensorProto.DataLocation data_location = 14;</code>
     * @return Whether the dataLocation field is set.
     */
    @java.lang.Override public boolean hasDataLocation() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
     * </pre>
     *
     * <code>optional .TensorProto.DataLocation data_location = 14;</code>
     * @return The dataLocation.
     */
    @java.lang.Override public Onnx.TensorProto.DataLocation getDataLocation() {
      Onnx.TensorProto.DataLocation result = Onnx.TensorProto.DataLocation.forNumber(dataLocation_);
      return result == null ? Onnx.TensorProto.DataLocation.DEFAULT : result;
    }

    public static final int DOUBLE_DATA_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.DoubleList doubleData_ =
        emptyDoubleList();
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @return A list containing the doubleData.
     */
    @java.lang.Override
    public java.util.List<java.lang.Double>
        getDoubleDataList() {
      return doubleData_;
    }
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @return The count of doubleData.
     */
    public int getDoubleDataCount() {
      return doubleData_.size();
    }
    /**
     * <pre>
     * For double
     * Complex128 tensors are encoded as a single array of doubles,
     * with the real components appearing in odd numbered positions,
     * and the corresponding imaginary component appearing in the
     * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
     * is encoded as [1.0, 2.0 ,3.0 ,4.0]
     * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
     * </pre>
     *
     * <code>repeated double double_data = 10 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The doubleData at the given index.
     */
    public double getDoubleData(int index) {
      return doubleData_.getDouble(index);
    }
    private int doubleDataMemoizedSerializedSize = -1;

    public static final int UINT64_DATA_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList uint64Data_ =
        emptyLongList();
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @return A list containing the uint64Data.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getUint64DataList() {
      return uint64Data_;
    }
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @return The count of uint64Data.
     */
    public int getUint64DataCount() {
      return uint64Data_.size();
    }
    /**
     * <pre>
     * For uint64 and uint32 values
     * When this field is present, the data_type field MUST be
     * UINT32 or UINT64
     * </pre>
     *
     * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
     * @param index The index of the element to return.
     * @return The uint64Data at the given index.
     */
    public long getUint64Data(int index) {
      return uint64Data_.getLong(index);
    }
    private int uint64DataMemoizedSerializedSize = -1;

    public static final int METADATA_PROPS_FIELD_NUMBER = 16;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < dims_.size(); i++) {
        output.writeInt64(1, dims_.getLong(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(2, dataType_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(3, getSegment());
      }
      if (getFloatDataList().size() > 0) {
        output.writeUInt32NoTag(34);
        output.writeUInt32NoTag(floatDataMemoizedSerializedSize);
      }
      for (int i = 0; i < floatData_.size(); i++) {
        output.writeFloatNoTag(floatData_.getFloat(i));
      }
      if (getInt32DataList().size() > 0) {
        output.writeUInt32NoTag(42);
        output.writeUInt32NoTag(int32DataMemoizedSerializedSize);
      }
      for (int i = 0; i < int32Data_.size(); i++) {
        output.writeInt32NoTag(int32Data_.getInt(i));
      }
      for (int i = 0; i < stringData_.size(); i++) {
        output.writeBytes(6, stringData_.get(i));
      }
      if (getInt64DataList().size() > 0) {
        output.writeUInt32NoTag(58);
        output.writeUInt32NoTag(int64DataMemoizedSerializedSize);
      }
      for (int i = 0; i < int64Data_.size(); i++) {
        output.writeInt64NoTag(int64Data_.getLong(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, name_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBytes(9, rawData_);
      }
      if (getDoubleDataList().size() > 0) {
        output.writeUInt32NoTag(82);
        output.writeUInt32NoTag(doubleDataMemoizedSerializedSize);
      }
      for (int i = 0; i < doubleData_.size(); i++) {
        output.writeDoubleNoTag(doubleData_.getDouble(i));
      }
      if (getUint64DataList().size() > 0) {
        output.writeUInt32NoTag(90);
        output.writeUInt32NoTag(uint64DataMemoizedSerializedSize);
      }
      for (int i = 0; i < uint64Data_.size(); i++) {
        output.writeUInt64NoTag(uint64Data_.getLong(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 12, docString_);
      }
      for (int i = 0; i < externalData_.size(); i++) {
        output.writeMessage(13, externalData_.get(i));
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeEnum(14, dataLocation_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(16, metadataProps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < dims_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(dims_.getLong(i));
        }
        size += dataSize;
        size += 1 * getDimsList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, dataType_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getSegment());
      }
      {
        int dataSize = 0;
        dataSize = 4 * getFloatDataList().size();
        size += dataSize;
        if (!getFloatDataList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        floatDataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < int32Data_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(int32Data_.getInt(i));
        }
        size += dataSize;
        if (!getInt32DataList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int32DataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < stringData_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(stringData_.get(i));
        }
        size += dataSize;
        size += 1 * getStringDataList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < int64Data_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(int64Data_.getLong(i));
        }
        size += dataSize;
        if (!getInt64DataList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        int64DataMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, name_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, rawData_);
      }
      {
        int dataSize = 0;
        dataSize = 8 * getDoubleDataList().size();
        size += dataSize;
        if (!getDoubleDataList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        doubleDataMemoizedSerializedSize = dataSize;
      }
      {
        int dataSize = 0;
        for (int i = 0; i < uint64Data_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt64SizeNoTag(uint64Data_.getLong(i));
        }
        size += dataSize;
        if (!getUint64DataList().isEmpty()) {
          size += 1;
          size += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(dataSize);
        }
        uint64DataMemoizedSerializedSize = dataSize;
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(12, docString_);
      }
      for (int i = 0; i < externalData_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, externalData_.get(i));
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(14, dataLocation_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, metadataProps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.TensorProto)) {
        return super.equals(obj);
      }
      Onnx.TensorProto other = (Onnx.TensorProto) obj;

      if (!getDimsList()
          .equals(other.getDimsList())) return false;
      if (hasDataType() != other.hasDataType()) return false;
      if (hasDataType()) {
        if (getDataType()
            != other.getDataType()) return false;
      }
      if (hasSegment() != other.hasSegment()) return false;
      if (hasSegment()) {
        if (!getSegment()
            .equals(other.getSegment())) return false;
      }
      if (!getFloatDataList()
          .equals(other.getFloatDataList())) return false;
      if (!getInt32DataList()
          .equals(other.getInt32DataList())) return false;
      if (!getStringDataList()
          .equals(other.getStringDataList())) return false;
      if (!getInt64DataList()
          .equals(other.getInt64DataList())) return false;
      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (hasRawData() != other.hasRawData()) return false;
      if (hasRawData()) {
        if (!getRawData()
            .equals(other.getRawData())) return false;
      }
      if (!getExternalDataList()
          .equals(other.getExternalDataList())) return false;
      if (hasDataLocation() != other.hasDataLocation()) return false;
      if (hasDataLocation()) {
        if (dataLocation_ != other.dataLocation_) return false;
      }
      if (!getDoubleDataList()
          .equals(other.getDoubleDataList())) return false;
      if (!getUint64DataList()
          .equals(other.getUint64DataList())) return false;
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDimsCount() > 0) {
        hash = (37 * hash) + DIMS_FIELD_NUMBER;
        hash = (53 * hash) + getDimsList().hashCode();
      }
      if (hasDataType()) {
        hash = (37 * hash) + DATA_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getDataType();
      }
      if (hasSegment()) {
        hash = (37 * hash) + SEGMENT_FIELD_NUMBER;
        hash = (53 * hash) + getSegment().hashCode();
      }
      if (getFloatDataCount() > 0) {
        hash = (37 * hash) + FLOAT_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getFloatDataList().hashCode();
      }
      if (getInt32DataCount() > 0) {
        hash = (37 * hash) + INT32_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getInt32DataList().hashCode();
      }
      if (getStringDataCount() > 0) {
        hash = (37 * hash) + STRING_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getStringDataList().hashCode();
      }
      if (getInt64DataCount() > 0) {
        hash = (37 * hash) + INT64_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getInt64DataList().hashCode();
      }
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (hasRawData()) {
        hash = (37 * hash) + RAW_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getRawData().hashCode();
      }
      if (getExternalDataCount() > 0) {
        hash = (37 * hash) + EXTERNAL_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getExternalDataList().hashCode();
      }
      if (hasDataLocation()) {
        hash = (37 * hash) + DATA_LOCATION_FIELD_NUMBER;
        hash = (53 * hash) + dataLocation_;
      }
      if (getDoubleDataCount() > 0) {
        hash = (37 * hash) + DOUBLE_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getDoubleDataList().hashCode();
      }
      if (getUint64DataCount() > 0) {
        hash = (37 * hash) + UINT64_DATA_FIELD_NUMBER;
        hash = (53 * hash) + getUint64DataList().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.TensorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.TensorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.TensorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.TensorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.TensorProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Tensors
     *
     * A serialized tensor value.
     * </pre>
     *
     * Protobuf type {@code TensorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:TensorProto)
        Onnx.TensorProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TensorProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TensorProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TensorProto.class, Onnx.TensorProto.Builder.class);
      }

      // Construct using Onnx.TensorProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetSegmentFieldBuilder();
          internalGetExternalDataFieldBuilder();
          internalGetMetadataPropsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        dims_ = emptyLongList();
        dataType_ = 0;
        segment_ = null;
        if (segmentBuilder_ != null) {
          segmentBuilder_.dispose();
          segmentBuilder_ = null;
        }
        floatData_ = emptyFloatList();
        int32Data_ = emptyIntList();
        stringData_ = emptyList(com.google.protobuf.ByteString.class);
        int64Data_ = emptyLongList();
        name_ = "";
        docString_ = "";
        rawData_ = com.google.protobuf.ByteString.EMPTY;
        if (externalDataBuilder_ == null) {
          externalData_ = java.util.Collections.emptyList();
        } else {
          externalData_ = null;
          externalDataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        dataLocation_ = 0;
        doubleData_ = emptyDoubleList();
        uint64Data_ = emptyLongList();
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_TensorProto_descriptor;
      }

      @java.lang.Override
      public Onnx.TensorProto getDefaultInstanceForType() {
        return Onnx.TensorProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.TensorProto build() {
        Onnx.TensorProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.TensorProto buildPartial() {
        Onnx.TensorProto result = new Onnx.TensorProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.TensorProto result) {
        if (externalDataBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            externalData_ = java.util.Collections.unmodifiableList(externalData_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.externalData_ = externalData_;
        } else {
          result.externalData_ = externalDataBuilder_.build();
        }
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00004000);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.TensorProto result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          dims_.makeImmutable();
          result.dims_ = dims_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.dataType_ = dataType_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.segment_ = segmentBuilder_ == null
              ? segment_
              : segmentBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          floatData_.makeImmutable();
          result.floatData_ = floatData_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          int32Data_.makeImmutable();
          result.int32Data_ = int32Data_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          stringData_.makeImmutable();
          result.stringData_ = stringData_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          int64Data_.makeImmutable();
          result.int64Data_ = int64Data_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.rawData_ = rawData_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.dataLocation_ = dataLocation_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          doubleData_.makeImmutable();
          result.doubleData_ = doubleData_;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          uint64Data_.makeImmutable();
          result.uint64Data_ = uint64Data_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.TensorProto) {
          return mergeFrom((Onnx.TensorProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.TensorProto other) {
        if (other == Onnx.TensorProto.getDefaultInstance()) return this;
        if (!other.dims_.isEmpty()) {
          if (dims_.isEmpty()) {
            dims_ = other.dims_;
            dims_.makeImmutable();
            bitField0_ |= 0x00000001;
          } else {
            ensureDimsIsMutable();
            dims_.addAll(other.dims_);
          }
          onChanged();
        }
        if (other.hasDataType()) {
          setDataType(other.getDataType());
        }
        if (other.hasSegment()) {
          mergeSegment(other.getSegment());
        }
        if (!other.floatData_.isEmpty()) {
          if (floatData_.isEmpty()) {
            floatData_ = other.floatData_;
            floatData_.makeImmutable();
            bitField0_ |= 0x00000008;
          } else {
            ensureFloatDataIsMutable();
            floatData_.addAll(other.floatData_);
          }
          onChanged();
        }
        if (!other.int32Data_.isEmpty()) {
          if (int32Data_.isEmpty()) {
            int32Data_ = other.int32Data_;
            int32Data_.makeImmutable();
            bitField0_ |= 0x00000010;
          } else {
            ensureInt32DataIsMutable();
            int32Data_.addAll(other.int32Data_);
          }
          onChanged();
        }
        if (!other.stringData_.isEmpty()) {
          if (stringData_.isEmpty()) {
            stringData_ = other.stringData_;
            stringData_.makeImmutable();
            bitField0_ |= 0x00000020;
          } else {
            ensureStringDataIsMutable();
            stringData_.addAll(other.stringData_);
          }
          onChanged();
        }
        if (!other.int64Data_.isEmpty()) {
          if (int64Data_.isEmpty()) {
            int64Data_ = other.int64Data_;
            int64Data_.makeImmutable();
            bitField0_ |= 0x00000040;
          } else {
            ensureInt64DataIsMutable();
            int64Data_.addAll(other.int64Data_);
          }
          onChanged();
        }
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000080;
          onChanged();
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasRawData()) {
          setRawData(other.getRawData());
        }
        if (externalDataBuilder_ == null) {
          if (!other.externalData_.isEmpty()) {
            if (externalData_.isEmpty()) {
              externalData_ = other.externalData_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureExternalDataIsMutable();
              externalData_.addAll(other.externalData_);
            }
            onChanged();
          }
        } else {
          if (!other.externalData_.isEmpty()) {
            if (externalDataBuilder_.isEmpty()) {
              externalDataBuilder_.dispose();
              externalDataBuilder_ = null;
              externalData_ = other.externalData_;
              bitField0_ = (bitField0_ & ~0x00000400);
              externalDataBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetExternalDataFieldBuilder() : null;
            } else {
              externalDataBuilder_.addAllMessages(other.externalData_);
            }
          }
        }
        if (other.hasDataLocation()) {
          setDataLocation(other.getDataLocation());
        }
        if (!other.doubleData_.isEmpty()) {
          if (doubleData_.isEmpty()) {
            doubleData_ = other.doubleData_;
            doubleData_.makeImmutable();
            bitField0_ |= 0x00001000;
          } else {
            ensureDoubleDataIsMutable();
            doubleData_.addAll(other.doubleData_);
          }
          onChanged();
        }
        if (!other.uint64Data_.isEmpty()) {
          if (uint64Data_.isEmpty()) {
            uint64Data_ = other.uint64Data_;
            uint64Data_.makeImmutable();
            bitField0_ |= 0x00002000;
          } else {
            ensureUint64DataIsMutable();
            uint64Data_.addAll(other.uint64Data_);
          }
          onChanged();
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00004000);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00004000);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                long v = input.readInt64();
                ensureDimsIsMutable();
                dims_.addLong(v);
                break;
              } // case 8
              case 10: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureDimsIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  dims_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 10
              case 16: {
                dataType_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                input.readMessage(
                    internalGetSegmentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 37: {
                float v = input.readFloat();
                ensureFloatDataIsMutable();
                floatData_.addFloat(v);
                break;
              } // case 37
              case 34: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                int alloc = length > 4096 ? 4096 : length;
                ensureFloatDataIsMutable(alloc / 4);
                while (input.getBytesUntilLimit() > 0) {
                  floatData_.addFloat(input.readFloat());
                }
                input.popLimit(limit);
                break;
              } // case 34
              case 40: {
                int v = input.readInt32();
                ensureInt32DataIsMutable();
                int32Data_.addInt(v);
                break;
              } // case 40
              case 42: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureInt32DataIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  int32Data_.addInt(input.readInt32());
                }
                input.popLimit(limit);
                break;
              } // case 42
              case 50: {
                com.google.protobuf.ByteString v = input.readBytes();
                ensureStringDataIsMutable();
                stringData_.add(v);
                break;
              } // case 50
              case 56: {
                long v = input.readInt64();
                ensureInt64DataIsMutable();
                int64Data_.addLong(v);
                break;
              } // case 56
              case 58: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureInt64DataIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  int64Data_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 58
              case 66: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                rawData_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 74
              case 81: {
                double v = input.readDouble();
                ensureDoubleDataIsMutable();
                doubleData_.addDouble(v);
                break;
              } // case 81
              case 82: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                int alloc = length > 4096 ? 4096 : length;
                ensureDoubleDataIsMutable(alloc / 8);
                while (input.getBytesUntilLimit() > 0) {
                  doubleData_.addDouble(input.readDouble());
                }
                input.popLimit(limit);
                break;
              } // case 82
              case 88: {
                long v = input.readUInt64();
                ensureUint64DataIsMutable();
                uint64Data_.addLong(v);
                break;
              } // case 88
              case 90: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureUint64DataIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  uint64Data_.addLong(input.readUInt64());
                }
                input.popLimit(limit);
                break;
              } // case 90
              case 98: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 98
              case 106: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (externalDataBuilder_ == null) {
                  ensureExternalDataIsMutable();
                  externalData_.add(m);
                } else {
                  externalDataBuilder_.addMessage(m);
                }
                break;
              } // case 106
              case 112: {
                int tmpRaw = input.readEnum();
                Onnx.TensorProto.DataLocation tmpValue =
                    Onnx.TensorProto.DataLocation.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(14, tmpRaw);
                } else {
                  dataLocation_ = tmpRaw;
                  bitField0_ |= 0x00000800;
                }
                break;
              } // case 112
              case 130: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 130
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
      private void ensureDimsIsMutable() {
        if (!dims_.isModifiable()) {
          dims_ = makeMutableCopy(dims_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @return A list containing the dims.
       */
      public java.util.List<java.lang.Long>
          getDimsList() {
        dims_.makeImmutable();
        return dims_;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @return The count of dims.
       */
      public int getDimsCount() {
        return dims_.size();
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @param index The index of the element to return.
       * @return The dims at the given index.
       */
      public long getDims(int index) {
        return dims_.getLong(index);
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @param index The index to set the value at.
       * @param value The dims to set.
       * @return This builder for chaining.
       */
      public Builder setDims(
          int index, long value) {

        ensureDimsIsMutable();
        dims_.setLong(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @param value The dims to add.
       * @return This builder for chaining.
       */
      public Builder addDims(long value) {

        ensureDimsIsMutable();
        dims_.addLong(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @param values The dims to add.
       * @return This builder for chaining.
       */
      public Builder addAllDims(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureDimsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dims_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the tensor.
       * </pre>
       *
       * <code>repeated int64 dims = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDims() {
        dims_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private int dataType_ ;
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>optional int32 data_type = 2;</code>
       * @return Whether the dataType field is set.
       */
      @java.lang.Override
      public boolean hasDataType() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>optional int32 data_type = 2;</code>
       * @return The dataType.
       */
      @java.lang.Override
      public int getDataType() {
        return dataType_;
      }
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>optional int32 data_type = 2;</code>
       * @param value The dataType to set.
       * @return This builder for chaining.
       */
      public Builder setDataType(int value) {

        dataType_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The data type of the tensor.
       * This field MUST have a valid TensorProto.DataType value
       * </pre>
       *
       * <code>optional int32 data_type = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        dataType_ = 0;
        onChanged();
        return this;
      }

      private Onnx.TensorProto.Segment segment_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto.Segment, Onnx.TensorProto.Segment.Builder, Onnx.TensorProto.SegmentOrBuilder> segmentBuilder_;
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       * @return Whether the segment field is set.
       */
      public boolean hasSegment() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       * @return The segment.
       */
      public Onnx.TensorProto.Segment getSegment() {
        if (segmentBuilder_ == null) {
          return segment_ == null ? Onnx.TensorProto.Segment.getDefaultInstance() : segment_;
        } else {
          return segmentBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Builder setSegment(Onnx.TensorProto.Segment value) {
        if (segmentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          segment_ = value;
        } else {
          segmentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Builder setSegment(
          Onnx.TensorProto.Segment.Builder builderForValue) {
        if (segmentBuilder_ == null) {
          segment_ = builderForValue.build();
        } else {
          segmentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Builder mergeSegment(Onnx.TensorProto.Segment value) {
        if (segmentBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            segment_ != null &&
            segment_ != Onnx.TensorProto.Segment.getDefaultInstance()) {
            getSegmentBuilder().mergeFrom(value);
          } else {
            segment_ = value;
          }
        } else {
          segmentBuilder_.mergeFrom(value);
        }
        if (segment_ != null) {
          bitField0_ |= 0x00000004;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Builder clearSegment() {
        bitField0_ = (bitField0_ & ~0x00000004);
        segment_ = null;
        if (segmentBuilder_ != null) {
          segmentBuilder_.dispose();
          segmentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Onnx.TensorProto.Segment.Builder getSegmentBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return internalGetSegmentFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      public Onnx.TensorProto.SegmentOrBuilder getSegmentOrBuilder() {
        if (segmentBuilder_ != null) {
          return segmentBuilder_.getMessageOrBuilder();
        } else {
          return segment_ == null ?
              Onnx.TensorProto.Segment.getDefaultInstance() : segment_;
        }
      }
      /**
       * <code>optional .TensorProto.Segment segment = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto.Segment, Onnx.TensorProto.Segment.Builder, Onnx.TensorProto.SegmentOrBuilder> 
          internalGetSegmentFieldBuilder() {
        if (segmentBuilder_ == null) {
          segmentBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TensorProto.Segment, Onnx.TensorProto.Segment.Builder, Onnx.TensorProto.SegmentOrBuilder>(
                  getSegment(),
                  getParentForChildren(),
                  isClean());
          segment_ = null;
        }
        return segmentBuilder_;
      }

      private com.google.protobuf.Internal.FloatList floatData_ = emptyFloatList();
      private void ensureFloatDataIsMutable() {
        if (!floatData_.isModifiable()) {
          floatData_ = makeMutableCopy(floatData_);
        }
        bitField0_ |= 0x00000008;
      }
      private void ensureFloatDataIsMutable(int capacity) {
        if (!floatData_.isModifiable()) {
          floatData_ = makeMutableCopy(floatData_, capacity);
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @return A list containing the floatData.
       */
      public java.util.List<java.lang.Float>
          getFloatDataList() {
        floatData_.makeImmutable();
        return floatData_;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @return The count of floatData.
       */
      public int getFloatDataCount() {
        return floatData_.size();
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The floatData at the given index.
       */
      public float getFloatData(int index) {
        return floatData_.getFloat(index);
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The floatData to set.
       * @return This builder for chaining.
       */
      public Builder setFloatData(
          int index, float value) {

        ensureFloatDataIsMutable();
        floatData_.setFloat(index, value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @param value The floatData to add.
       * @return This builder for chaining.
       */
      public Builder addFloatData(float value) {

        ensureFloatDataIsMutable();
        floatData_.addFloat(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @param values The floatData to add.
       * @return This builder for chaining.
       */
      public Builder addAllFloatData(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureFloatDataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, floatData_);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For float and complex64 values
       * Complex64 tensors are encoded as a single array of floats,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
       * </pre>
       *
       * <code>repeated float float_data = 4 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearFloatData() {
        floatData_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList int32Data_ = emptyIntList();
      private void ensureInt32DataIsMutable() {
        if (!int32Data_.isModifiable()) {
          int32Data_ = makeMutableCopy(int32Data_);
        }
        bitField0_ |= 0x00000010;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @return A list containing the int32Data.
       */
      public java.util.List<java.lang.Integer>
          getInt32DataList() {
        int32Data_.makeImmutable();
        return int32Data_;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @return The count of int32Data.
       */
      public int getInt32DataCount() {
        return int32Data_.size();
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The int32Data at the given index.
       */
      public int getInt32Data(int index) {
        return int32Data_.getInt(index);
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The int32Data to set.
       * @return This builder for chaining.
       */
      public Builder setInt32Data(
          int index, int value) {

        ensureInt32DataIsMutable();
        int32Data_.setInt(index, value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @param value The int32Data to add.
       * @return This builder for chaining.
       */
      public Builder addInt32Data(int value) {

        ensureInt32DataIsMutable();
        int32Data_.addInt(value);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @param values The int32Data to add.
       * @return This builder for chaining.
       */
      public Builder addAllInt32Data(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureInt32DataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, int32Data_);
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int32, uint8, int8, uint16, int16, uint4, int4, bool, (b)float16, float8, and float4:
       * - (b)float16 and float8 values MUST be converted bit-wise into an unsigned integer
       * representation before being written to the buffer.
       * - Each pair of uint4, int4, and float4 values MUST be packed as two 4-bit elements into a single byte.
       * The first element is stored in the 4 least significant bits (LSB),
       * and the second element is stored in the 4 most significant bits (MSB).
       *
       * Consequently:
       * - For data types with a bit-width of 8 or greater, each `int32_data` stores one element.
       * - For 4-bit data types, each `int32_data` stores two elements.
       *
       * When this field is present, the data_type field MUST be
       * INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1
       * </pre>
       *
       * <code>repeated int32 int32_data = 5 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearInt32Data() {
        int32Data_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> stringData_ = emptyList(com.google.protobuf.ByteString.class);
      private void ensureStringDataIsMutable() {
        if (!stringData_.isModifiable()) {
          stringData_ = makeMutableCopy(stringData_);
        }
        bitField0_ |= 0x00000020;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @return A list containing the stringData.
       */
      public java.util.List<com.google.protobuf.ByteString>
          getStringDataList() {
        stringData_.makeImmutable();
        return stringData_;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @return The count of stringData.
       */
      public int getStringDataCount() {
        return stringData_.size();
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @param index The index of the element to return.
       * @return The stringData at the given index.
       */
      public com.google.protobuf.ByteString getStringData(int index) {
        return stringData_.get(index);
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @param index The index to set the value at.
       * @param value The stringData to set.
       * @return This builder for chaining.
       */
      public Builder setStringData(
          int index, com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStringDataIsMutable();
        stringData_.set(index, value);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @param value The stringData to add.
       * @return This builder for chaining.
       */
      public Builder addStringData(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureStringDataIsMutable();
        stringData_.add(value);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @param values The stringData to add.
       * @return This builder for chaining.
       */
      public Builder addAllStringData(
          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
        ensureStringDataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, stringData_);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For strings.
       * Each element of string_data is a UTF-8 encoded Unicode
       * string. No trailing null, no leading BOM. The protobuf "string"
       * scalar type is not used to match ML community conventions.
       * When this field is present, the data_type field MUST be STRING
       * </pre>
       *
       * <code>repeated bytes string_data = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStringData() {
        stringData_ = emptyList(com.google.protobuf.ByteString.class);
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList int64Data_ = emptyLongList();
      private void ensureInt64DataIsMutable() {
        if (!int64Data_.isModifiable()) {
          int64Data_ = makeMutableCopy(int64Data_);
        }
        bitField0_ |= 0x00000040;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @return A list containing the int64Data.
       */
      public java.util.List<java.lang.Long>
          getInt64DataList() {
        int64Data_.makeImmutable();
        return int64Data_;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @return The count of int64Data.
       */
      public int getInt64DataCount() {
        return int64Data_.size();
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The int64Data at the given index.
       */
      public long getInt64Data(int index) {
        return int64Data_.getLong(index);
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The int64Data to set.
       * @return This builder for chaining.
       */
      public Builder setInt64Data(
          int index, long value) {

        ensureInt64DataIsMutable();
        int64Data_.setLong(index, value);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @param value The int64Data to add.
       * @return This builder for chaining.
       */
      public Builder addInt64Data(long value) {

        ensureInt64DataIsMutable();
        int64Data_.addLong(value);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @param values The int64Data to add.
       * @return This builder for chaining.
       */
      public Builder addAllInt64Data(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureInt64DataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, int64Data_);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For int64.
       * When this field is present, the data_type field MUST be INT64
       * </pre>
       *
       * <code>repeated int64 int64_data = 7 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearInt64Data() {
        int64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000080);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optionally, a name for the tensor.
       * </pre>
       *
       * <code>optional string name = 8;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this tensor. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 12;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString rawData_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       *
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
       *
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>optional bytes raw_data = 9;</code>
       * @return Whether the rawData field is set.
       */
      @java.lang.Override
      public boolean hasRawData() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       *
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
       *
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>optional bytes raw_data = 9;</code>
       * @return The rawData.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getRawData() {
        return rawData_;
      }
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       *
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
       *
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>optional bytes raw_data = 9;</code>
       * @param value The rawData to set.
       * @return This builder for chaining.
       */
      public Builder setRawData(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        rawData_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Serializations can either use one of the fields above, or use this
       * raw bytes field. The only exception is the string case, where one is
       * required to store the content in the repeated bytes string_data field.
       *
       * When this raw_data field is used to store tensor value, elements MUST
       * be stored in as fixed-width, little-endian order.
       * Floating-point data types MUST be stored in IEEE 754 format.
       * Complex64 elements must be written as two consecutive FLOAT values, real component first.
       * Complex128 elements must be written as two consecutive DOUBLE values, real component first.
       * Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
       * uint4 and int4 values must be packed to 4bitx2, the first element is stored in the 4 LSB and the second element is stored in the 4 MSB.
       *
       * Note: the advantage of specific field rather than the raw_data field is
       * that in some cases (e.g. int data), protobuf does a better packing via
       * variable length storage, and may lead to smaller binary footprint.
       * When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
       * </pre>
       *
       * <code>optional bytes raw_data = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearRawData() {
        bitField0_ = (bitField0_ & ~0x00000200);
        rawData_ = getDefaultInstance().getRawData();
        onChanged();
        return this;
      }

      private java.util.List<Onnx.StringStringEntryProto> externalData_ =
        java.util.Collections.emptyList();
      private void ensureExternalDataIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          externalData_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(externalData_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> externalDataBuilder_;

      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getExternalDataList() {
        if (externalDataBuilder_ == null) {
          return java.util.Collections.unmodifiableList(externalData_);
        } else {
          return externalDataBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public int getExternalDataCount() {
        if (externalDataBuilder_ == null) {
          return externalData_.size();
        } else {
          return externalDataBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Onnx.StringStringEntryProto getExternalData(int index) {
        if (externalDataBuilder_ == null) {
          return externalData_.get(index);
        } else {
          return externalDataBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder setExternalData(
          int index, Onnx.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.set(index, value);
          onChanged();
        } else {
          externalDataBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder setExternalData(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.set(index, builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(Onnx.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.add(value);
          onChanged();
        } else {
          externalDataBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          int index, Onnx.StringStringEntryProto value) {
        if (externalDataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureExternalDataIsMutable();
          externalData_.add(index, value);
          onChanged();
        } else {
          externalDataBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.add(builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder addExternalData(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.add(index, builderForValue.build());
          onChanged();
        } else {
          externalDataBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder addAllExternalData(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, externalData_);
          onChanged();
        } else {
          externalDataBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder clearExternalData() {
        if (externalDataBuilder_ == null) {
          externalData_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          externalDataBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Builder removeExternalData(int index) {
        if (externalDataBuilder_ == null) {
          ensureExternalDataIsMutable();
          externalData_.remove(index);
          onChanged();
        } else {
          externalDataBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Onnx.StringStringEntryProto.Builder getExternalDataBuilder(
          int index) {
        return internalGetExternalDataFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getExternalDataOrBuilder(
          int index) {
        if (externalDataBuilder_ == null) {
          return externalData_.get(index);  } else {
          return externalDataBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getExternalDataOrBuilderList() {
        if (externalDataBuilder_ != null) {
          return externalDataBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(externalData_);
        }
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Onnx.StringStringEntryProto.Builder addExternalDataBuilder() {
        return internalGetExternalDataFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public Onnx.StringStringEntryProto.Builder addExternalDataBuilder(
          int index) {
        return internalGetExternalDataFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Data can be stored inside the protobuf file using type-specific fields or raw_data.
       * Alternatively, raw bytes data can be stored in an external file, using the external_data field.
       * external_data stores key-value pairs describing data location. Recognized keys are:
       * - "location" (required) - POSIX filesystem path relative to the directory where the ONNX
       * protobuf model was stored
       * - "offset" (optional) - position of byte at which stored data begins. Integer stored as string.
       * Offset values SHOULD be multiples 4096 (page size) to enable mmap support.
       * - "length" (optional) - number of bytes containing data. Integer stored as string.
       * - "checksum" (optional) - SHA1 digest of file specified in under 'location' key.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto external_data = 13;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getExternalDataBuilderList() {
        return internalGetExternalDataFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetExternalDataFieldBuilder() {
        if (externalDataBuilder_ == null) {
          externalDataBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  externalData_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          externalData_ = null;
        }
        return externalDataBuilder_;
      }

      private int dataLocation_ = 0;
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>optional .TensorProto.DataLocation data_location = 14;</code>
       * @return Whether the dataLocation field is set.
       */
      @java.lang.Override public boolean hasDataLocation() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>optional .TensorProto.DataLocation data_location = 14;</code>
       * @return The dataLocation.
       */
      @java.lang.Override
      public Onnx.TensorProto.DataLocation getDataLocation() {
        Onnx.TensorProto.DataLocation result = Onnx.TensorProto.DataLocation.forNumber(dataLocation_);
        return result == null ? Onnx.TensorProto.DataLocation.DEFAULT : result;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>optional .TensorProto.DataLocation data_location = 14;</code>
       * @param value The dataLocation to set.
       * @return This builder for chaining.
       */
      public Builder setDataLocation(Onnx.TensorProto.DataLocation value) {
        if (value == null) { throw new NullPointerException(); }
        bitField0_ |= 0x00000800;
        dataLocation_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If value not set, data is stored in raw_data (if set) otherwise in type-specified field.
       * </pre>
       *
       * <code>optional .TensorProto.DataLocation data_location = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataLocation() {
        bitField0_ = (bitField0_ & ~0x00000800);
        dataLocation_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.DoubleList doubleData_ = emptyDoubleList();
      private void ensureDoubleDataIsMutable() {
        if (!doubleData_.isModifiable()) {
          doubleData_ = makeMutableCopy(doubleData_);
        }
        bitField0_ |= 0x00001000;
      }
      private void ensureDoubleDataIsMutable(int capacity) {
        if (!doubleData_.isModifiable()) {
          doubleData_ = makeMutableCopy(doubleData_, capacity);
        }
        bitField0_ |= 0x00001000;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @return A list containing the doubleData.
       */
      public java.util.List<java.lang.Double>
          getDoubleDataList() {
        doubleData_.makeImmutable();
        return doubleData_;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @return The count of doubleData.
       */
      public int getDoubleDataCount() {
        return doubleData_.size();
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The doubleData at the given index.
       */
      public double getDoubleData(int index) {
        return doubleData_.getDouble(index);
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The doubleData to set.
       * @return This builder for chaining.
       */
      public Builder setDoubleData(
          int index, double value) {

        ensureDoubleDataIsMutable();
        doubleData_.setDouble(index, value);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @param value The doubleData to add.
       * @return This builder for chaining.
       */
      public Builder addDoubleData(double value) {

        ensureDoubleDataIsMutable();
        doubleData_.addDouble(value);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @param values The doubleData to add.
       * @return This builder for chaining.
       */
      public Builder addAllDoubleData(
          java.lang.Iterable<? extends java.lang.Double> values) {
        ensureDoubleDataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, doubleData_);
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For double
       * Complex128 tensors are encoded as a single array of doubles,
       * with the real components appearing in odd numbered positions,
       * and the corresponding imaginary component appearing in the
       * subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
       * is encoded as [1.0, 2.0 ,3.0 ,4.0]
       * When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
       * </pre>
       *
       * <code>repeated double double_data = 10 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearDoubleData() {
        doubleData_ = emptyDoubleList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.LongList uint64Data_ = emptyLongList();
      private void ensureUint64DataIsMutable() {
        if (!uint64Data_.isModifiable()) {
          uint64Data_ = makeMutableCopy(uint64Data_);
        }
        bitField0_ |= 0x00002000;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @return A list containing the uint64Data.
       */
      public java.util.List<java.lang.Long>
          getUint64DataList() {
        uint64Data_.makeImmutable();
        return uint64Data_;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @return The count of uint64Data.
       */
      public int getUint64DataCount() {
        return uint64Data_.size();
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @param index The index of the element to return.
       * @return The uint64Data at the given index.
       */
      public long getUint64Data(int index) {
        return uint64Data_.getLong(index);
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @param index The index to set the value at.
       * @param value The uint64Data to set.
       * @return This builder for chaining.
       */
      public Builder setUint64Data(
          int index, long value) {

        ensureUint64DataIsMutable();
        uint64Data_.setLong(index, value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @param value The uint64Data to add.
       * @return This builder for chaining.
       */
      public Builder addUint64Data(long value) {

        ensureUint64DataIsMutable();
        uint64Data_.addLong(value);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @param values The uint64Data to add.
       * @return This builder for chaining.
       */
      public Builder addAllUint64Data(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureUint64DataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, uint64Data_);
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For uint64 and uint32 values
       * When this field is present, the data_type field MUST be
       * UINT32 or UINT64
       * </pre>
       *
       * <code>repeated uint64 uint64_data = 11 [packed = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUint64Data() {
        uint64Data_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00004000) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00004000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00004000);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 16;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00004000) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:TensorProto)
    }

    // @@protoc_insertion_point(class_scope:TensorProto)
    private static final Onnx.TensorProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.TensorProto();
    }

    public static Onnx.TensorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TensorProto>
        PARSER = new com.google.protobuf.AbstractParser<TensorProto>() {
      @java.lang.Override
      public TensorProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TensorProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TensorProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.TensorProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SparseTensorProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:SparseTensorProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     * @return Whether the values field is set.
     */
    boolean hasValues();
    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     * @return The values.
     */
    Onnx.TensorProto getValues();
    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     */
    Onnx.TensorProtoOrBuilder getValuesOrBuilder();

    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     * @return Whether the indices field is set.
     */
    boolean hasIndices();
    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     * @return The indices.
     */
    Onnx.TensorProto getIndices();
    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     */
    Onnx.TensorProtoOrBuilder getIndicesOrBuilder();

    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @return A list containing the dims.
     */
    java.util.List<java.lang.Long> getDimsList();
    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @return The count of dims.
     */
    int getDimsCount();
    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @param index The index of the element to return.
     * @return The dims at the given index.
     */
    long getDims(int index);
  }
  /**
   * <pre>
   * A serialized sparse-tensor value
   * </pre>
   *
   * Protobuf type {@code SparseTensorProto}
   */
  public static final class SparseTensorProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:SparseTensorProto)
      SparseTensorProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        SparseTensorProto.class.getName());
    }
    // Use SparseTensorProto.newBuilder() to construct.
    private SparseTensorProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SparseTensorProto() {
      dims_ = emptyLongList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_SparseTensorProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_SparseTensorProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.SparseTensorProto.class, Onnx.SparseTensorProto.Builder.class);
    }

    private int bitField0_;
    public static final int VALUES_FIELD_NUMBER = 1;
    private Onnx.TensorProto values_;
    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     * @return Whether the values field is set.
     */
    @java.lang.Override
    public boolean hasValues() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     * @return The values.
     */
    @java.lang.Override
    public Onnx.TensorProto getValues() {
      return values_ == null ? Onnx.TensorProto.getDefaultInstance() : values_;
    }
    /**
     * <pre>
     * The sequence of non-default values are encoded as a tensor of shape [NNZ].
     * The default-value is zero for numeric tensors, and empty-string for string tensors.
     * values must have a non-empty name present which serves as a name for SparseTensorProto
     * when used in sparse_initializer list.
     * </pre>
     *
     * <code>optional .TensorProto values = 1;</code>
     */
    @java.lang.Override
    public Onnx.TensorProtoOrBuilder getValuesOrBuilder() {
      return values_ == null ? Onnx.TensorProto.getDefaultInstance() : values_;
    }

    public static final int INDICES_FIELD_NUMBER = 2;
    private Onnx.TensorProto indices_;
    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     * @return Whether the indices field is set.
     */
    @java.lang.Override
    public boolean hasIndices() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     * @return The indices.
     */
    @java.lang.Override
    public Onnx.TensorProto getIndices() {
      return indices_ == null ? Onnx.TensorProto.getDefaultInstance() : indices_;
    }
    /**
     * <pre>
     * The indices of the non-default values, which may be stored in one of two formats.
     * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
     * corresponding to the j-th index of the i-th value (in the values tensor).
     * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
     * must be the linearized-index of the i-th value (in the values tensor).
     * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
     * using the shape provided below.
     * The indices must appear in ascending order without duplication.
     * In the first format, the ordering is lexicographic-ordering:
     * e.g., index-value [1,4] must appear before [2,1]
     * </pre>
     *
     * <code>optional .TensorProto indices = 2;</code>
     */
    @java.lang.Override
    public Onnx.TensorProtoOrBuilder getIndicesOrBuilder() {
      return indices_ == null ? Onnx.TensorProto.getDefaultInstance() : indices_;
    }

    public static final int DIMS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.LongList dims_ =
        emptyLongList();
    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @return A list containing the dims.
     */
    @java.lang.Override
    public java.util.List<java.lang.Long>
        getDimsList() {
      return dims_;
    }
    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @return The count of dims.
     */
    public int getDimsCount() {
      return dims_.size();
    }
    /**
     * <pre>
     * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
     * </pre>
     *
     * <code>repeated int64 dims = 3;</code>
     * @param index The index of the element to return.
     * @return The dims at the given index.
     */
    public long getDims(int index) {
      return dims_.getLong(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(1, getValues());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getIndices());
      }
      for (int i = 0; i < dims_.size(); i++) {
        output.writeInt64(3, dims_.getLong(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getValues());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getIndices());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < dims_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt64SizeNoTag(dims_.getLong(i));
        }
        size += dataSize;
        size += 1 * getDimsList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.SparseTensorProto)) {
        return super.equals(obj);
      }
      Onnx.SparseTensorProto other = (Onnx.SparseTensorProto) obj;

      if (hasValues() != other.hasValues()) return false;
      if (hasValues()) {
        if (!getValues()
            .equals(other.getValues())) return false;
      }
      if (hasIndices() != other.hasIndices()) return false;
      if (hasIndices()) {
        if (!getIndices()
            .equals(other.getIndices())) return false;
      }
      if (!getDimsList()
          .equals(other.getDimsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasValues()) {
        hash = (37 * hash) + VALUES_FIELD_NUMBER;
        hash = (53 * hash) + getValues().hashCode();
      }
      if (hasIndices()) {
        hash = (37 * hash) + INDICES_FIELD_NUMBER;
        hash = (53 * hash) + getIndices().hashCode();
      }
      if (getDimsCount() > 0) {
        hash = (37 * hash) + DIMS_FIELD_NUMBER;
        hash = (53 * hash) + getDimsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.SparseTensorProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SparseTensorProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SparseTensorProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SparseTensorProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SparseTensorProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.SparseTensorProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.SparseTensorProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.SparseTensorProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.SparseTensorProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.SparseTensorProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.SparseTensorProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.SparseTensorProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.SparseTensorProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A serialized sparse-tensor value
     * </pre>
     *
     * Protobuf type {@code SparseTensorProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:SparseTensorProto)
        Onnx.SparseTensorProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_SparseTensorProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_SparseTensorProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.SparseTensorProto.class, Onnx.SparseTensorProto.Builder.class);
      }

      // Construct using Onnx.SparseTensorProto.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          internalGetValuesFieldBuilder();
          internalGetIndicesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        values_ = null;
        if (valuesBuilder_ != null) {
          valuesBuilder_.dispose();
          valuesBuilder_ = null;
        }
        indices_ = null;
        if (indicesBuilder_ != null) {
          indicesBuilder_.dispose();
          indicesBuilder_ = null;
        }
        dims_ = emptyLongList();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_SparseTensorProto_descriptor;
      }

      @java.lang.Override
      public Onnx.SparseTensorProto getDefaultInstanceForType() {
        return Onnx.SparseTensorProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.SparseTensorProto build() {
        Onnx.SparseTensorProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.SparseTensorProto buildPartial() {
        Onnx.SparseTensorProto result = new Onnx.SparseTensorProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.SparseTensorProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.values_ = valuesBuilder_ == null
              ? values_
              : valuesBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.indices_ = indicesBuilder_ == null
              ? indices_
              : indicesBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          dims_.makeImmutable();
          result.dims_ = dims_;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.SparseTensorProto) {
          return mergeFrom((Onnx.SparseTensorProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.SparseTensorProto other) {
        if (other == Onnx.SparseTensorProto.getDefaultInstance()) return this;
        if (other.hasValues()) {
          mergeValues(other.getValues());
        }
        if (other.hasIndices()) {
          mergeIndices(other.getIndices());
        }
        if (!other.dims_.isEmpty()) {
          if (dims_.isEmpty()) {
            dims_ = other.dims_;
            dims_.makeImmutable();
            bitField0_ |= 0x00000004;
          } else {
            ensureDimsIsMutable();
            dims_.addAll(other.dims_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    internalGetValuesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                input.readMessage(
                    internalGetIndicesFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                long v = input.readInt64();
                ensureDimsIsMutable();
                dims_.addLong(v);
                break;
              } // case 24
              case 26: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureDimsIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  dims_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private Onnx.TensorProto values_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> valuesBuilder_;
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       * @return Whether the values field is set.
       */
      public boolean hasValues() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       * @return The values.
       */
      public Onnx.TensorProto getValues() {
        if (valuesBuilder_ == null) {
          return values_ == null ? Onnx.TensorProto.getDefaultInstance() : values_;
        } else {
          return valuesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Builder setValues(Onnx.TensorProto value) {
        if (valuesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          values_ = value;
        } else {
          valuesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Builder setValues(
          Onnx.TensorProto.Builder builderForValue) {
        if (valuesBuilder_ == null) {
          values_ = builderForValue.build();
        } else {
          valuesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Builder mergeValues(Onnx.TensorProto value) {
        if (valuesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            values_ != null &&
            values_ != Onnx.TensorProto.getDefaultInstance()) {
            getValuesBuilder().mergeFrom(value);
          } else {
            values_ = value;
          }
        } else {
          valuesBuilder_.mergeFrom(value);
        }
        if (values_ != null) {
          bitField0_ |= 0x00000001;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Builder clearValues() {
        bitField0_ = (bitField0_ & ~0x00000001);
        values_ = null;
        if (valuesBuilder_ != null) {
          valuesBuilder_.dispose();
          valuesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Onnx.TensorProto.Builder getValuesBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return internalGetValuesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      public Onnx.TensorProtoOrBuilder getValuesOrBuilder() {
        if (valuesBuilder_ != null) {
          return valuesBuilder_.getMessageOrBuilder();
        } else {
          return values_ == null ?
              Onnx.TensorProto.getDefaultInstance() : values_;
        }
      }
      /**
       * <pre>
       * The sequence of non-default values are encoded as a tensor of shape [NNZ].
       * The default-value is zero for numeric tensors, and empty-string for string tensors.
       * values must have a non-empty name present which serves as a name for SparseTensorProto
       * when used in sparse_initializer list.
       * </pre>
       *
       * <code>optional .TensorProto values = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> 
          internalGetValuesFieldBuilder() {
        if (valuesBuilder_ == null) {
          valuesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder>(
                  getValues(),
                  getParentForChildren(),
                  isClean());
          values_ = null;
        }
        return valuesBuilder_;
      }

      private Onnx.TensorProto indices_;
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> indicesBuilder_;
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       * @return Whether the indices field is set.
       */
      public boolean hasIndices() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       * @return The indices.
       */
      public Onnx.TensorProto getIndices() {
        if (indicesBuilder_ == null) {
          return indices_ == null ? Onnx.TensorProto.getDefaultInstance() : indices_;
        } else {
          return indicesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Builder setIndices(Onnx.TensorProto value) {
        if (indicesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          indices_ = value;
        } else {
          indicesBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Builder setIndices(
          Onnx.TensorProto.Builder builderForValue) {
        if (indicesBuilder_ == null) {
          indices_ = builderForValue.build();
        } else {
          indicesBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Builder mergeIndices(Onnx.TensorProto value) {
        if (indicesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            indices_ != null &&
            indices_ != Onnx.TensorProto.getDefaultInstance()) {
            getIndicesBuilder().mergeFrom(value);
          } else {
            indices_ = value;
          }
        } else {
          indicesBuilder_.mergeFrom(value);
        }
        if (indices_ != null) {
          bitField0_ |= 0x00000002;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Builder clearIndices() {
        bitField0_ = (bitField0_ & ~0x00000002);
        indices_ = null;
        if (indicesBuilder_ != null) {
          indicesBuilder_.dispose();
          indicesBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Onnx.TensorProto.Builder getIndicesBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return internalGetIndicesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      public Onnx.TensorProtoOrBuilder getIndicesOrBuilder() {
        if (indicesBuilder_ != null) {
          return indicesBuilder_.getMessageOrBuilder();
        } else {
          return indices_ == null ?
              Onnx.TensorProto.getDefaultInstance() : indices_;
        }
      }
      /**
       * <pre>
       * The indices of the non-default values, which may be stored in one of two formats.
       * (a) Indices can be a tensor of shape [NNZ, rank] with the [i,j]-th value
       * corresponding to the j-th index of the i-th value (in the values tensor).
       * (b) Indices can be a tensor of shape [NNZ], in which case the i-th value
       * must be the linearized-index of the i-th value (in the values tensor).
       * The linearized-index can be converted into an index tuple (k_1,...,k_rank)
       * using the shape provided below.
       * The indices must appear in ascending order without duplication.
       * In the first format, the ordering is lexicographic-ordering:
       * e.g., index-value [1,4] must appear before [2,1]
       * </pre>
       *
       * <code>optional .TensorProto indices = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder> 
          internalGetIndicesFieldBuilder() {
        if (indicesBuilder_ == null) {
          indicesBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TensorProto, Onnx.TensorProto.Builder, Onnx.TensorProtoOrBuilder>(
                  getIndices(),
                  getParentForChildren(),
                  isClean());
          indices_ = null;
        }
        return indicesBuilder_;
      }

      private com.google.protobuf.Internal.LongList dims_ = emptyLongList();
      private void ensureDimsIsMutable() {
        if (!dims_.isModifiable()) {
          dims_ = makeMutableCopy(dims_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @return A list containing the dims.
       */
      public java.util.List<java.lang.Long>
          getDimsList() {
        dims_.makeImmutable();
        return dims_;
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @return The count of dims.
       */
      public int getDimsCount() {
        return dims_.size();
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @param index The index of the element to return.
       * @return The dims at the given index.
       */
      public long getDims(int index) {
        return dims_.getLong(index);
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @param index The index to set the value at.
       * @param value The dims to set.
       * @return This builder for chaining.
       */
      public Builder setDims(
          int index, long value) {

        ensureDimsIsMutable();
        dims_.setLong(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @param value The dims to add.
       * @return This builder for chaining.
       */
      public Builder addDims(long value) {

        ensureDimsIsMutable();
        dims_.addLong(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @param values The dims to add.
       * @return This builder for chaining.
       */
      public Builder addAllDims(
          java.lang.Iterable<? extends java.lang.Long> values) {
        ensureDimsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, dims_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The shape of the underlying dense-tensor: [dim_1, dim_2, ... dim_rank]
       * </pre>
       *
       * <code>repeated int64 dims = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDims() {
        dims_ = emptyLongList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:SparseTensorProto)
    }

    // @@protoc_insertion_point(class_scope:SparseTensorProto)
    private static final Onnx.SparseTensorProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.SparseTensorProto();
    }

    public static Onnx.SparseTensorProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SparseTensorProto>
        PARSER = new com.google.protobuf.AbstractParser<SparseTensorProto>() {
      @java.lang.Override
      public SparseTensorProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SparseTensorProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SparseTensorProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.SparseTensorProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TensorShapeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TensorShapeProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    java.util.List<Onnx.TensorShapeProto.Dimension> 
        getDimList();
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    Onnx.TensorShapeProto.Dimension getDim(int index);
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    int getDimCount();
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    java.util.List<? extends Onnx.TensorShapeProto.DimensionOrBuilder> 
        getDimOrBuilderList();
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    Onnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Defines a tensor shape. A dimension can be either an integer value
   * or a symbolic variable. A symbolic variable represents an unknown
   * dimension.
   * </pre>
   *
   * Protobuf type {@code TensorShapeProto}
   */
  public static final class TensorShapeProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:TensorShapeProto)
      TensorShapeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        TensorShapeProto.class.getName());
    }
    // Use TensorShapeProto.newBuilder() to construct.
    private TensorShapeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TensorShapeProto() {
      dim_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_TensorShapeProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_TensorShapeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.TensorShapeProto.class, Onnx.TensorShapeProto.Builder.class);
    }

    public interface DimensionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TensorShapeProto.Dimension)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>int64 dim_value = 1;</code>
       * @return Whether the dimValue field is set.
       */
      boolean hasDimValue();
      /**
       * <code>int64 dim_value = 1;</code>
       * @return The dimValue.
       */
      long getDimValue();

      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return Whether the dimParam field is set.
       */
      boolean hasDimParam();
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return The dimParam.
       */
      java.lang.String getDimParam();
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return The bytes for dimParam.
       */
      com.google.protobuf.ByteString
          getDimParamBytes();

      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return Whether the denotation field is set.
       */
      boolean hasDenotation();
      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return The denotation.
       */
      java.lang.String getDenotation();
      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return The bytes for denotation.
       */
      com.google.protobuf.ByteString
          getDenotationBytes();

      Onnx.TensorShapeProto.Dimension.ValueCase getValueCase();
    }
    /**
     * Protobuf type {@code TensorShapeProto.Dimension}
     */
    public static final class Dimension extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TensorShapeProto.Dimension)
        DimensionOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Dimension.class.getName());
      }
      // Use Dimension.newBuilder() to construct.
      private Dimension(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Dimension() {
        denotation_ = "";
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TensorShapeProto.Dimension.class, Onnx.TensorShapeProto.Dimension.Builder.class);
      }

      private int bitField0_;
      private int valueCase_ = 0;
      @SuppressWarnings("serial")
      private java.lang.Object value_;
      public enum ValueCase
          implements com.google.protobuf.Internal.EnumLite,
              com.google.protobuf.AbstractMessage.InternalOneOfEnum {
        DIM_VALUE(1),
        DIM_PARAM(2),
        VALUE_NOT_SET(0);
        private final int value;
        private ValueCase(int value) {
          this.value = value;
        }
        /**
         * @param value The number of the enum to look for.
         * @return The enum associated with the given number.
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static ValueCase valueOf(int value) {
          return forNumber(value);
        }

        public static ValueCase forNumber(int value) {
          switch (value) {
            case 1: return DIM_VALUE;
            case 2: return DIM_PARAM;
            case 0: return VALUE_NOT_SET;
            default: return null;
          }
        }
        public int getNumber() {
          return this.value;
        }
      };

      public ValueCase
      getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public static final int DIM_VALUE_FIELD_NUMBER = 1;
      /**
       * <code>int64 dim_value = 1;</code>
       * @return Whether the dimValue field is set.
       */
      @java.lang.Override
      public boolean hasDimValue() {
        return valueCase_ == 1;
      }
      /**
       * <code>int64 dim_value = 1;</code>
       * @return The dimValue.
       */
      @java.lang.Override
      public long getDimValue() {
        if (valueCase_ == 1) {
          return (java.lang.Long) value_;
        }
        return 0L;
      }

      public static final int DIM_PARAM_FIELD_NUMBER = 2;
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return Whether the dimParam field is set.
       */
      public boolean hasDimParam() {
        return valueCase_ == 2;
      }
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return The dimParam.
       */
      public java.lang.String getDimParam() {
        java.lang.Object ref = "";
        if (valueCase_ == 2) {
          ref = value_;
        }
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8() && (valueCase_ == 2)) {
            value_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * namespace Shape
       * </pre>
       *
       * <code>string dim_param = 2;</code>
       * @return The bytes for dimParam.
       */
      public com.google.protobuf.ByteString
          getDimParamBytes() {
        java.lang.Object ref = "";
        if (valueCase_ == 2) {
          ref = value_;
        }
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          if (valueCase_ == 2) {
            value_ = b;
          }
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int DENOTATION_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private volatile java.lang.Object denotation_ = "";
      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return Whether the denotation field is set.
       */
      @java.lang.Override
      public boolean hasDenotation() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return The denotation.
       */
      @java.lang.Override
      public java.lang.String getDenotation() {
        java.lang.Object ref = denotation_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            denotation_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Standard denotation can optionally be used to denote tensor
       * dimensions with standard semantic descriptions to ensure
       * that operations are applied to the correct axis of a tensor.
       * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
       * for pre-defined dimension denotations.
       * </pre>
       *
       * <code>optional string denotation = 3;</code>
       * @return The bytes for denotation.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getDenotationBytes() {
        java.lang.Object ref = denotation_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          denotation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (valueCase_ == 1) {
          output.writeInt64(
              1, (long)((java.lang.Long) value_));
        }
        if (valueCase_ == 2) {
          com.google.protobuf.GeneratedMessage.writeString(output, 2, value_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessage.writeString(output, 3, denotation_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (valueCase_ == 1) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt64Size(
                1, (long)((java.lang.Long) value_));
        }
        if (valueCase_ == 2) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(2, value_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessage.computeStringSize(3, denotation_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TensorShapeProto.Dimension)) {
          return super.equals(obj);
        }
        Onnx.TensorShapeProto.Dimension other = (Onnx.TensorShapeProto.Dimension) obj;

        if (hasDenotation() != other.hasDenotation()) return false;
        if (hasDenotation()) {
          if (!getDenotation()
              .equals(other.getDenotation())) return false;
        }
        if (!getValueCase().equals(other.getValueCase())) return false;
        switch (valueCase_) {
          case 1:
            if (getDimValue()
                != other.getDimValue()) return false;
            break;
          case 2:
            if (!getDimParam()
                .equals(other.getDimParam())) return false;
            break;
          case 0:
          default:
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasDenotation()) {
          hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
          hash = (53 * hash) + getDenotation().hashCode();
        }
        switch (valueCase_) {
          case 1:
            hash = (37 * hash) + DIM_VALUE_FIELD_NUMBER;
            hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
                getDimValue());
            break;
          case 2:
            hash = (37 * hash) + DIM_PARAM_FIELD_NUMBER;
            hash = (53 * hash) + getDimParam().hashCode();
            break;
          case 0:
          default:
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TensorShapeProto.Dimension parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TensorShapeProto.Dimension parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TensorShapeProto.Dimension parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TensorShapeProto.Dimension parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TensorShapeProto.Dimension prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code TensorShapeProto.Dimension}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TensorShapeProto.Dimension)
          Onnx.TensorShapeProto.DimensionOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TensorShapeProto.Dimension.class, Onnx.TensorShapeProto.Dimension.Builder.class);
        }

        // Construct using Onnx.TensorShapeProto.Dimension.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          denotation_ = "";
          valueCase_ = 0;
          value_ = null;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TensorShapeProto_Dimension_descriptor;
        }

        @java.lang.Override
        public Onnx.TensorShapeProto.Dimension getDefaultInstanceForType() {
          return Onnx.TensorShapeProto.Dimension.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TensorShapeProto.Dimension build() {
          Onnx.TensorShapeProto.Dimension result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TensorShapeProto.Dimension buildPartial() {
          Onnx.TensorShapeProto.Dimension result = new Onnx.TensorShapeProto.Dimension(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          buildPartialOneofs(result);
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TensorShapeProto.Dimension result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.denotation_ = denotation_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        private void buildPartialOneofs(Onnx.TensorShapeProto.Dimension result) {
          result.valueCase_ = valueCase_;
          result.value_ = this.value_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TensorShapeProto.Dimension) {
            return mergeFrom((Onnx.TensorShapeProto.Dimension)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TensorShapeProto.Dimension other) {
          if (other == Onnx.TensorShapeProto.Dimension.getDefaultInstance()) return this;
          if (other.hasDenotation()) {
            denotation_ = other.denotation_;
            bitField0_ |= 0x00000004;
            onChanged();
          }
          switch (other.getValueCase()) {
            case DIM_VALUE: {
              setDimValue(other.getDimValue());
              break;
            }
            case DIM_PARAM: {
              valueCase_ = 2;
              value_ = other.value_;
              onChanged();
              break;
            }
            case VALUE_NOT_SET: {
              break;
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  value_ = input.readInt64();
                  valueCase_ = 1;
                  break;
                } // case 8
                case 18: {
                  com.google.protobuf.ByteString bs = input.readBytes();
                  valueCase_ = 2;
                  value_ = bs;
                  break;
                } // case 18
                case 26: {
                  denotation_ = input.readBytes();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 26
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int valueCase_ = 0;
        private java.lang.Object value_;
        public ValueCase
            getValueCase() {
          return ValueCase.forNumber(
              valueCase_);
        }

        public Builder clearValue() {
          valueCase_ = 0;
          value_ = null;
          onChanged();
          return this;
        }

        private int bitField0_;

        /**
         * <code>int64 dim_value = 1;</code>
         * @return Whether the dimValue field is set.
         */
        public boolean hasDimValue() {
          return valueCase_ == 1;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         * @return The dimValue.
         */
        public long getDimValue() {
          if (valueCase_ == 1) {
            return (java.lang.Long) value_;
          }
          return 0L;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         * @param value The dimValue to set.
         * @return This builder for chaining.
         */
        public Builder setDimValue(long value) {

          valueCase_ = 1;
          value_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>int64 dim_value = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearDimValue() {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
          return this;
        }

        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @return Whether the dimParam field is set.
         */
        @java.lang.Override
        public boolean hasDimParam() {
          return valueCase_ == 2;
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @return The dimParam.
         */
        @java.lang.Override
        public java.lang.String getDimParam() {
          java.lang.Object ref = "";
          if (valueCase_ == 2) {
            ref = value_;
          }
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (valueCase_ == 2) {
              if (bs.isValidUtf8()) {
                value_ = s;
              }
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @return The bytes for dimParam.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString
            getDimParamBytes() {
          java.lang.Object ref = "";
          if (valueCase_ == 2) {
            ref = value_;
          }
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            if (valueCase_ == 2) {
              value_ = b;
            }
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @param value The dimParam to set.
         * @return This builder for chaining.
         */
        public Builder setDimParam(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          valueCase_ = 2;
          value_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearDimParam() {
          if (valueCase_ == 2) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * namespace Shape
         * </pre>
         *
         * <code>string dim_param = 2;</code>
         * @param value The bytes for dimParam to set.
         * @return This builder for chaining.
         */
        public Builder setDimParamBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          valueCase_ = 2;
          value_ = value;
          onChanged();
          return this;
        }

        private java.lang.Object denotation_ = "";
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @return Whether the denotation field is set.
         */
        public boolean hasDenotation() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @return The denotation.
         */
        public java.lang.String getDenotation() {
          java.lang.Object ref = denotation_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              denotation_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @return The bytes for denotation.
         */
        public com.google.protobuf.ByteString
            getDenotationBytes() {
          java.lang.Object ref = denotation_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            denotation_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @param value The denotation to set.
         * @return This builder for chaining.
         */
        public Builder setDenotation(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          denotation_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearDenotation() {
          denotation_ = getDefaultInstance().getDenotation();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Standard denotation can optionally be used to denote tensor
         * dimensions with standard semantic descriptions to ensure
         * that operations are applied to the correct axis of a tensor.
         * Refer to https://github.com/onnx/onnx/blob/main/docs/DimensionDenotation.md#denotation-definition
         * for pre-defined dimension denotations.
         * </pre>
         *
         * <code>optional string denotation = 3;</code>
         * @param value The bytes for denotation to set.
         * @return This builder for chaining.
         */
        public Builder setDenotationBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          denotation_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:TensorShapeProto.Dimension)
      }

      // @@protoc_insertion_point(class_scope:TensorShapeProto.Dimension)
      private static final Onnx.TensorShapeProto.Dimension DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TensorShapeProto.Dimension();
      }

      public static Onnx.TensorShapeProto.Dimension getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Dimension>
          PARSER = new com.google.protobuf.AbstractParser<Dimension>() {
        @java.lang.Override
        public Dimension parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Dimension> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Dimension> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TensorShapeProto.Dimension getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int DIM_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.TensorShapeProto.Dimension> dim_;
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.TensorShapeProto.Dimension> getDimList() {
      return dim_;
    }
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.TensorShapeProto.DimensionOrBuilder> 
        getDimOrBuilderList() {
      return dim_;
    }
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    @java.lang.Override
    public int getDimCount() {
      return dim_.size();
    }
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    @java.lang.Override
    public Onnx.TensorShapeProto.Dimension getDim(int index) {
      return dim_.get(index);
    }
    /**
     * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
     */
    @java.lang.Override
    public Onnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
        int index) {
      return dim_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < dim_.size(); i++) {
        output.writeMessage(1, dim_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < dim_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, dim_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.TensorShapeProto)) {
        return super.equals(obj);
      }
      Onnx.TensorShapeProto other = (Onnx.TensorShapeProto) obj;

      if (!getDimList()
          .equals(other.getDimList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getDimCount() > 0) {
        hash = (37 * hash) + DIM_FIELD_NUMBER;
        hash = (53 * hash) + getDimList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.TensorShapeProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorShapeProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorShapeProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorShapeProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorShapeProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TensorShapeProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TensorShapeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorShapeProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.TensorShapeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.TensorShapeProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.TensorShapeProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TensorShapeProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.TensorShapeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Defines a tensor shape. A dimension can be either an integer value
     * or a symbolic variable. A symbolic variable represents an unknown
     * dimension.
     * </pre>
     *
     * Protobuf type {@code TensorShapeProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:TensorShapeProto)
        Onnx.TensorShapeProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TensorShapeProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TensorShapeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TensorShapeProto.class, Onnx.TensorShapeProto.Builder.class);
      }

      // Construct using Onnx.TensorShapeProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (dimBuilder_ == null) {
          dim_ = java.util.Collections.emptyList();
        } else {
          dim_ = null;
          dimBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_TensorShapeProto_descriptor;
      }

      @java.lang.Override
      public Onnx.TensorShapeProto getDefaultInstanceForType() {
        return Onnx.TensorShapeProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.TensorShapeProto build() {
        Onnx.TensorShapeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.TensorShapeProto buildPartial() {
        Onnx.TensorShapeProto result = new Onnx.TensorShapeProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.TensorShapeProto result) {
        if (dimBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            dim_ = java.util.Collections.unmodifiableList(dim_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.dim_ = dim_;
        } else {
          result.dim_ = dimBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.TensorShapeProto result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.TensorShapeProto) {
          return mergeFrom((Onnx.TensorShapeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.TensorShapeProto other) {
        if (other == Onnx.TensorShapeProto.getDefaultInstance()) return this;
        if (dimBuilder_ == null) {
          if (!other.dim_.isEmpty()) {
            if (dim_.isEmpty()) {
              dim_ = other.dim_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureDimIsMutable();
              dim_.addAll(other.dim_);
            }
            onChanged();
          }
        } else {
          if (!other.dim_.isEmpty()) {
            if (dimBuilder_.isEmpty()) {
              dimBuilder_.dispose();
              dimBuilder_ = null;
              dim_ = other.dim_;
              bitField0_ = (bitField0_ & ~0x00000001);
              dimBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetDimFieldBuilder() : null;
            } else {
              dimBuilder_.addAllMessages(other.dim_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                Onnx.TensorShapeProto.Dimension m =
                    input.readMessage(
                        Onnx.TensorShapeProto.Dimension.parser(),
                        extensionRegistry);
                if (dimBuilder_ == null) {
                  ensureDimIsMutable();
                  dim_.add(m);
                } else {
                  dimBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<Onnx.TensorShapeProto.Dimension> dim_ =
        java.util.Collections.emptyList();
      private void ensureDimIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          dim_ = new java.util.ArrayList<Onnx.TensorShapeProto.Dimension>(dim_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorShapeProto.Dimension, Onnx.TensorShapeProto.Dimension.Builder, Onnx.TensorShapeProto.DimensionOrBuilder> dimBuilder_;

      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<Onnx.TensorShapeProto.Dimension> getDimList() {
        if (dimBuilder_ == null) {
          return java.util.Collections.unmodifiableList(dim_);
        } else {
          return dimBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public int getDimCount() {
        if (dimBuilder_ == null) {
          return dim_.size();
        } else {
          return dimBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Onnx.TensorShapeProto.Dimension getDim(int index) {
        if (dimBuilder_ == null) {
          return dim_.get(index);
        } else {
          return dimBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder setDim(
          int index, Onnx.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.set(index, value);
          onChanged();
        } else {
          dimBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder setDim(
          int index, Onnx.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.set(index, builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(Onnx.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.add(value);
          onChanged();
        } else {
          dimBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          int index, Onnx.TensorShapeProto.Dimension value) {
        if (dimBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDimIsMutable();
          dim_.add(index, value);
          onChanged();
        } else {
          dimBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          Onnx.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.add(builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addDim(
          int index, Onnx.TensorShapeProto.Dimension.Builder builderForValue) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.add(index, builderForValue.build());
          onChanged();
        } else {
          dimBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder addAllDim(
          java.lang.Iterable<? extends Onnx.TensorShapeProto.Dimension> values) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, dim_);
          onChanged();
        } else {
          dimBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder clearDim() {
        if (dimBuilder_ == null) {
          dim_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          dimBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Builder removeDim(int index) {
        if (dimBuilder_ == null) {
          ensureDimIsMutable();
          dim_.remove(index);
          onChanged();
        } else {
          dimBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Onnx.TensorShapeProto.Dimension.Builder getDimBuilder(
          int index) {
        return internalGetDimFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Onnx.TensorShapeProto.DimensionOrBuilder getDimOrBuilder(
          int index) {
        if (dimBuilder_ == null) {
          return dim_.get(index);  } else {
          return dimBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<? extends Onnx.TensorShapeProto.DimensionOrBuilder> 
           getDimOrBuilderList() {
        if (dimBuilder_ != null) {
          return dimBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(dim_);
        }
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Onnx.TensorShapeProto.Dimension.Builder addDimBuilder() {
        return internalGetDimFieldBuilder().addBuilder(
            Onnx.TensorShapeProto.Dimension.getDefaultInstance());
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public Onnx.TensorShapeProto.Dimension.Builder addDimBuilder(
          int index) {
        return internalGetDimFieldBuilder().addBuilder(
            index, Onnx.TensorShapeProto.Dimension.getDefaultInstance());
      }
      /**
       * <code>repeated .TensorShapeProto.Dimension dim = 1;</code>
       */
      public java.util.List<Onnx.TensorShapeProto.Dimension.Builder> 
           getDimBuilderList() {
        return internalGetDimFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.TensorShapeProto.Dimension, Onnx.TensorShapeProto.Dimension.Builder, Onnx.TensorShapeProto.DimensionOrBuilder> 
          internalGetDimFieldBuilder() {
        if (dimBuilder_ == null) {
          dimBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.TensorShapeProto.Dimension, Onnx.TensorShapeProto.Dimension.Builder, Onnx.TensorShapeProto.DimensionOrBuilder>(
                  dim_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          dim_ = null;
        }
        return dimBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:TensorShapeProto)
    }

    // @@protoc_insertion_point(class_scope:TensorShapeProto)
    private static final Onnx.TensorShapeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.TensorShapeProto();
    }

    public static Onnx.TensorShapeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TensorShapeProto>
        PARSER = new com.google.protobuf.AbstractParser<TensorShapeProto>() {
      @java.lang.Override
      public TensorShapeProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TensorShapeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TensorShapeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.TensorShapeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TypeProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:TypeProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     * @return Whether the tensorType field is set.
     */
    boolean hasTensorType();
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     * @return The tensorType.
     */
    Onnx.TypeProto.Tensor getTensorType();
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     */
    Onnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder();

    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     * @return Whether the sequenceType field is set.
     */
    boolean hasSequenceType();
    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     * @return The sequenceType.
     */
    Onnx.TypeProto.Sequence getSequenceType();
    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     */
    Onnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder();

    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     * @return Whether the mapType field is set.
     */
    boolean hasMapType();
    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     * @return The mapType.
     */
    Onnx.TypeProto.Map getMapType();
    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     */
    Onnx.TypeProto.MapOrBuilder getMapTypeOrBuilder();

    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     * @return Whether the optionalType field is set.
     */
    boolean hasOptionalType();
    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     * @return The optionalType.
     */
    Onnx.TypeProto.Optional getOptionalType();
    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     */
    Onnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder();

    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     * @return Whether the sparseTensorType field is set.
     */
    boolean hasSparseTensorType();
    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     * @return The sparseTensorType.
     */
    Onnx.TypeProto.SparseTensor getSparseTensorType();
    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     */
    Onnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder();

    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return Whether the denotation field is set.
     */
    boolean hasDenotation();
    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return The denotation.
     */
    java.lang.String getDenotation();
    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return The bytes for denotation.
     */
    com.google.protobuf.ByteString
        getDenotationBytes();

    Onnx.TypeProto.ValueCase getValueCase();
  }
  /**
   * <pre>
   * Types
   *
   * The standard ONNX data types.
   * </pre>
   *
   * Protobuf type {@code TypeProto}
   */
  public static final class TypeProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:TypeProto)
      TypeProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        TypeProto.class.getName());
    }
    // Use TypeProto.newBuilder() to construct.
    private TypeProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private TypeProto() {
      denotation_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_TypeProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_TypeProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.TypeProto.class, Onnx.TypeProto.Builder.class);
    }

    public interface TensorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TypeProto.Tensor)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      boolean hasElemType();
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return The elemType.
       */
      int getElemType();

      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return Whether the shape field is set.
       */
      boolean hasShape();
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return The shape.
       */
      Onnx.TensorShapeProto getShape();
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       */
      Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder();
    }
    /**
     * Protobuf type {@code TypeProto.Tensor}
     */
    public static final class Tensor extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TypeProto.Tensor)
        TensorOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Tensor.class.getName());
      }
      // Use Tensor.newBuilder() to construct.
      private Tensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Tensor() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_Tensor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.Tensor.class, Onnx.TypeProto.Tensor.Builder.class);
      }

      private int bitField0_;
      public static final int ELEM_TYPE_FIELD_NUMBER = 1;
      private int elemType_ = 0;
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      @java.lang.Override
      public boolean hasElemType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return The elemType.
       */
      @java.lang.Override
      public int getElemType() {
        return elemType_;
      }

      public static final int SHAPE_FIELD_NUMBER = 2;
      private Onnx.TensorShapeProto shape_;
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return Whether the shape field is set.
       */
      @java.lang.Override
      public boolean hasShape() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return The shape.
       */
      @java.lang.Override
      public Onnx.TensorShapeProto getShape() {
        return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
      }
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       */
      @java.lang.Override
      public Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
        return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt32(1, elemType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getShape());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, elemType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getShape());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TypeProto.Tensor)) {
          return super.equals(obj);
        }
        Onnx.TypeProto.Tensor other = (Onnx.TypeProto.Tensor) obj;

        if (hasElemType() != other.hasElemType()) return false;
        if (hasElemType()) {
          if (getElemType()
              != other.getElemType()) return false;
        }
        if (hasShape() != other.hasShape()) return false;
        if (hasShape()) {
          if (!getShape()
              .equals(other.getShape())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasElemType()) {
          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getElemType();
        }
        if (hasShape()) {
          hash = (37 * hash) + SHAPE_FIELD_NUMBER;
          hash = (53 * hash) + getShape().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TypeProto.Tensor parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Tensor parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Tensor parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TypeProto.Tensor parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TypeProto.Tensor parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Tensor parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TypeProto.Tensor prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code TypeProto.Tensor}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TypeProto.Tensor)
          Onnx.TypeProto.TensorOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TypeProto_Tensor_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TypeProto_Tensor_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TypeProto.Tensor.class, Onnx.TypeProto.Tensor.Builder.class);
        }

        // Construct using Onnx.TypeProto.Tensor.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetShapeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          elemType_ = 0;
          shape_ = null;
          if (shapeBuilder_ != null) {
            shapeBuilder_.dispose();
            shapeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TypeProto_Tensor_descriptor;
        }

        @java.lang.Override
        public Onnx.TypeProto.Tensor getDefaultInstanceForType() {
          return Onnx.TypeProto.Tensor.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TypeProto.Tensor build() {
          Onnx.TypeProto.Tensor result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TypeProto.Tensor buildPartial() {
          Onnx.TypeProto.Tensor result = new Onnx.TypeProto.Tensor(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TypeProto.Tensor result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.elemType_ = elemType_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.shape_ = shapeBuilder_ == null
                ? shape_
                : shapeBuilder_.build();
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TypeProto.Tensor) {
            return mergeFrom((Onnx.TypeProto.Tensor)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TypeProto.Tensor other) {
          if (other == Onnx.TypeProto.Tensor.getDefaultInstance()) return this;
          if (other.hasElemType()) {
            setElemType(other.getElemType());
          }
          if (other.hasShape()) {
            mergeShape(other.getShape());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  elemType_ = input.readInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  input.readMessage(
                      internalGetShapeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int elemType_ ;
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return Whether the elemType field is set.
         */
        @java.lang.Override
        public boolean hasElemType() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return The elemType.
         */
        @java.lang.Override
        public int getElemType() {
          return elemType_;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @param value The elemType to set.
         * @return This builder for chaining.
         */
        public Builder setElemType(int value) {

          elemType_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearElemType() {
          bitField0_ = (bitField0_ & ~0x00000001);
          elemType_ = 0;
          onChanged();
          return this;
        }

        private Onnx.TensorShapeProto shape_;
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder> shapeBuilder_;
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         * @return Whether the shape field is set.
         */
        public boolean hasShape() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         * @return The shape.
         */
        public Onnx.TensorShapeProto getShape() {
          if (shapeBuilder_ == null) {
            return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
          } else {
            return shapeBuilder_.getMessage();
          }
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(Onnx.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            shape_ = value;
          } else {
            shapeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(
            Onnx.TensorShapeProto.Builder builderForValue) {
          if (shapeBuilder_ == null) {
            shape_ = builderForValue.build();
          } else {
            shapeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder mergeShape(Onnx.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
              shape_ != null &&
              shape_ != Onnx.TensorShapeProto.getDefaultInstance()) {
              getShapeBuilder().mergeFrom(value);
            } else {
              shape_ = value;
            }
          } else {
            shapeBuilder_.mergeFrom(value);
          }
          if (shape_ != null) {
            bitField0_ |= 0x00000002;
            onChanged();
          }
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder clearShape() {
          bitField0_ = (bitField0_ & ~0x00000002);
          shape_ = null;
          if (shapeBuilder_ != null) {
            shapeBuilder_.dispose();
            shapeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Onnx.TensorShapeProto.Builder getShapeBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return internalGetShapeFieldBuilder().getBuilder();
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
          if (shapeBuilder_ != null) {
            return shapeBuilder_.getMessageOrBuilder();
          } else {
            return shape_ == null ?
                Onnx.TensorShapeProto.getDefaultInstance() : shape_;
          }
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder> 
            internalGetShapeFieldBuilder() {
          if (shapeBuilder_ == null) {
            shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder>(
                    getShape(),
                    getParentForChildren(),
                    isClean());
            shape_ = null;
          }
          return shapeBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:TypeProto.Tensor)
      }

      // @@protoc_insertion_point(class_scope:TypeProto.Tensor)
      private static final Onnx.TypeProto.Tensor DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TypeProto.Tensor();
      }

      public static Onnx.TypeProto.Tensor getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Tensor>
          PARSER = new com.google.protobuf.AbstractParser<Tensor>() {
        @java.lang.Override
        public Tensor parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Tensor> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Tensor> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TypeProto.Tensor getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SequenceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TypeProto.Sequence)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      boolean hasElemType();
      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return The elemType.
       */
      Onnx.TypeProto getElemType();
      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       */
      Onnx.TypeProtoOrBuilder getElemTypeOrBuilder();
    }
    /**
     * <pre>
     * repeated T
     * </pre>
     *
     * Protobuf type {@code TypeProto.Sequence}
     */
    public static final class Sequence extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TypeProto.Sequence)
        SequenceOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Sequence.class.getName());
      }
      // Use Sequence.newBuilder() to construct.
      private Sequence(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Sequence() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_Sequence_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.Sequence.class, Onnx.TypeProto.Sequence.Builder.class);
      }

      private int bitField0_;
      public static final int ELEM_TYPE_FIELD_NUMBER = 1;
      private Onnx.TypeProto elemType_;
      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      @java.lang.Override
      public boolean hasElemType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return The elemType.
       */
      @java.lang.Override
      public Onnx.TypeProto getElemType() {
        return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
      }
      /**
       * <pre>
       * The type and optional shape of each element of the sequence.
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       */
      @java.lang.Override
      public Onnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
        return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(1, getElemType());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getElemType());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TypeProto.Sequence)) {
          return super.equals(obj);
        }
        Onnx.TypeProto.Sequence other = (Onnx.TypeProto.Sequence) obj;

        if (hasElemType() != other.hasElemType()) return false;
        if (hasElemType()) {
          if (!getElemType()
              .equals(other.getElemType())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasElemType()) {
          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getElemType().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TypeProto.Sequence parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Sequence parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Sequence parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TypeProto.Sequence parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TypeProto.Sequence parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Sequence parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TypeProto.Sequence prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * repeated T
       * </pre>
       *
       * Protobuf type {@code TypeProto.Sequence}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TypeProto.Sequence)
          Onnx.TypeProto.SequenceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TypeProto_Sequence_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TypeProto_Sequence_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TypeProto.Sequence.class, Onnx.TypeProto.Sequence.Builder.class);
        }

        // Construct using Onnx.TypeProto.Sequence.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetElemTypeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          elemType_ = null;
          if (elemTypeBuilder_ != null) {
            elemTypeBuilder_.dispose();
            elemTypeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TypeProto_Sequence_descriptor;
        }

        @java.lang.Override
        public Onnx.TypeProto.Sequence getDefaultInstanceForType() {
          return Onnx.TypeProto.Sequence.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TypeProto.Sequence build() {
          Onnx.TypeProto.Sequence result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TypeProto.Sequence buildPartial() {
          Onnx.TypeProto.Sequence result = new Onnx.TypeProto.Sequence(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TypeProto.Sequence result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.elemType_ = elemTypeBuilder_ == null
                ? elemType_
                : elemTypeBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TypeProto.Sequence) {
            return mergeFrom((Onnx.TypeProto.Sequence)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TypeProto.Sequence other) {
          if (other == Onnx.TypeProto.Sequence.getDefaultInstance()) return this;
          if (other.hasElemType()) {
            mergeElemType(other.getElemType());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  input.readMessage(
                      internalGetElemTypeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private Onnx.TypeProto elemType_;
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> elemTypeBuilder_;
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         * @return Whether the elemType field is set.
         */
        public boolean hasElemType() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         * @return The elemType.
         */
        public Onnx.TypeProto getElemType() {
          if (elemTypeBuilder_ == null) {
            return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
          } else {
            return elemTypeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder setElemType(Onnx.TypeProto value) {
          if (elemTypeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            elemType_ = value;
          } else {
            elemTypeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder setElemType(
            Onnx.TypeProto.Builder builderForValue) {
          if (elemTypeBuilder_ == null) {
            elemType_ = builderForValue.build();
          } else {
            elemTypeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder mergeElemType(Onnx.TypeProto value) {
          if (elemTypeBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0) &&
              elemType_ != null &&
              elemType_ != Onnx.TypeProto.getDefaultInstance()) {
              getElemTypeBuilder().mergeFrom(value);
            } else {
              elemType_ = value;
            }
          } else {
            elemTypeBuilder_.mergeFrom(value);
          }
          if (elemType_ != null) {
            bitField0_ |= 0x00000001;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder clearElemType() {
          bitField0_ = (bitField0_ & ~0x00000001);
          elemType_ = null;
          if (elemTypeBuilder_ != null) {
            elemTypeBuilder_.dispose();
            elemTypeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Onnx.TypeProto.Builder getElemTypeBuilder() {
          bitField0_ |= 0x00000001;
          onChanged();
          return internalGetElemTypeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Onnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
          if (elemTypeBuilder_ != null) {
            return elemTypeBuilder_.getMessageOrBuilder();
          } else {
            return elemType_ == null ?
                Onnx.TypeProto.getDefaultInstance() : elemType_;
          }
        }
        /**
         * <pre>
         * The type and optional shape of each element of the sequence.
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
            internalGetElemTypeFieldBuilder() {
          if (elemTypeBuilder_ == null) {
            elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                    getElemType(),
                    getParentForChildren(),
                    isClean());
            elemType_ = null;
          }
          return elemTypeBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:TypeProto.Sequence)
      }

      // @@protoc_insertion_point(class_scope:TypeProto.Sequence)
      private static final Onnx.TypeProto.Sequence DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TypeProto.Sequence();
      }

      public static Onnx.TypeProto.Sequence getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Sequence>
          PARSER = new com.google.protobuf.AbstractParser<Sequence>() {
        @java.lang.Override
        public Sequence parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Sequence> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Sequence> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TypeProto.Sequence getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface MapOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TypeProto.Map)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
       * </pre>
       *
       * <code>optional int32 key_type = 1;</code>
       * @return Whether the keyType field is set.
       */
      boolean hasKeyType();
      /**
       * <pre>
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
       * </pre>
       *
       * <code>optional int32 key_type = 1;</code>
       * @return The keyType.
       */
      int getKeyType();

      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       * @return Whether the valueType field is set.
       */
      boolean hasValueType();
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       * @return The valueType.
       */
      Onnx.TypeProto getValueType();
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       */
      Onnx.TypeProtoOrBuilder getValueTypeOrBuilder();
    }
    /**
     * <pre>
     * map&lt;K,V&gt;
     * </pre>
     *
     * Protobuf type {@code TypeProto.Map}
     */
    public static final class Map extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TypeProto.Map)
        MapOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Map.class.getName());
      }
      // Use Map.newBuilder() to construct.
      private Map(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Map() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_Map_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_Map_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.Map.class, Onnx.TypeProto.Map.Builder.class);
      }

      private int bitField0_;
      public static final int KEY_TYPE_FIELD_NUMBER = 1;
      private int keyType_ = 0;
      /**
       * <pre>
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
       * </pre>
       *
       * <code>optional int32 key_type = 1;</code>
       * @return Whether the keyType field is set.
       */
      @java.lang.Override
      public boolean hasKeyType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
       * </pre>
       *
       * <code>optional int32 key_type = 1;</code>
       * @return The keyType.
       */
      @java.lang.Override
      public int getKeyType() {
        return keyType_;
      }

      public static final int VALUE_TYPE_FIELD_NUMBER = 2;
      private Onnx.TypeProto valueType_;
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       * @return Whether the valueType field is set.
       */
      @java.lang.Override
      public boolean hasValueType() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       * @return The valueType.
       */
      @java.lang.Override
      public Onnx.TypeProto getValueType() {
        return valueType_ == null ? Onnx.TypeProto.getDefaultInstance() : valueType_;
      }
      /**
       * <pre>
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional .TypeProto value_type = 2;</code>
       */
      @java.lang.Override
      public Onnx.TypeProtoOrBuilder getValueTypeOrBuilder() {
        return valueType_ == null ? Onnx.TypeProto.getDefaultInstance() : valueType_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt32(1, keyType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getValueType());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, keyType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getValueType());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TypeProto.Map)) {
          return super.equals(obj);
        }
        Onnx.TypeProto.Map other = (Onnx.TypeProto.Map) obj;

        if (hasKeyType() != other.hasKeyType()) return false;
        if (hasKeyType()) {
          if (getKeyType()
              != other.getKeyType()) return false;
        }
        if (hasValueType() != other.hasValueType()) return false;
        if (hasValueType()) {
          if (!getValueType()
              .equals(other.getValueType())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasKeyType()) {
          hash = (37 * hash) + KEY_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getKeyType();
        }
        if (hasValueType()) {
          hash = (37 * hash) + VALUE_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getValueType().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TypeProto.Map parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Map parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Map parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Map parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Map parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Map parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Map parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Map parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TypeProto.Map parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TypeProto.Map parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TypeProto.Map parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Map parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TypeProto.Map prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * map&lt;K,V&gt;
       * </pre>
       *
       * Protobuf type {@code TypeProto.Map}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TypeProto.Map)
          Onnx.TypeProto.MapOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TypeProto_Map_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TypeProto_Map_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TypeProto.Map.class, Onnx.TypeProto.Map.Builder.class);
        }

        // Construct using Onnx.TypeProto.Map.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetValueTypeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          keyType_ = 0;
          valueType_ = null;
          if (valueTypeBuilder_ != null) {
            valueTypeBuilder_.dispose();
            valueTypeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TypeProto_Map_descriptor;
        }

        @java.lang.Override
        public Onnx.TypeProto.Map getDefaultInstanceForType() {
          return Onnx.TypeProto.Map.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TypeProto.Map build() {
          Onnx.TypeProto.Map result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TypeProto.Map buildPartial() {
          Onnx.TypeProto.Map result = new Onnx.TypeProto.Map(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TypeProto.Map result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.keyType_ = keyType_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.valueType_ = valueTypeBuilder_ == null
                ? valueType_
                : valueTypeBuilder_.build();
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TypeProto.Map) {
            return mergeFrom((Onnx.TypeProto.Map)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TypeProto.Map other) {
          if (other == Onnx.TypeProto.Map.getDefaultInstance()) return this;
          if (other.hasKeyType()) {
            setKeyType(other.getKeyType());
          }
          if (other.hasValueType()) {
            mergeValueType(other.getValueType());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  keyType_ = input.readInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  input.readMessage(
                      internalGetValueTypeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int keyType_ ;
        /**
         * <pre>
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
         * </pre>
         *
         * <code>optional int32 key_type = 1;</code>
         * @return Whether the keyType field is set.
         */
        @java.lang.Override
        public boolean hasKeyType() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
         * </pre>
         *
         * <code>optional int32 key_type = 1;</code>
         * @return The keyType.
         */
        @java.lang.Override
        public int getKeyType() {
          return keyType_;
        }
        /**
         * <pre>
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
         * </pre>
         *
         * <code>optional int32 key_type = 1;</code>
         * @param value The keyType to set.
         * @return This builder for chaining.
         */
        public Builder setKeyType(int value) {

          keyType_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
         * </pre>
         *
         * <code>optional int32 key_type = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearKeyType() {
          bitField0_ = (bitField0_ & ~0x00000001);
          keyType_ = 0;
          onChanged();
          return this;
        }

        private Onnx.TypeProto valueType_;
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> valueTypeBuilder_;
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         * @return Whether the valueType field is set.
         */
        public boolean hasValueType() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         * @return The valueType.
         */
        public Onnx.TypeProto getValueType() {
          if (valueTypeBuilder_ == null) {
            return valueType_ == null ? Onnx.TypeProto.getDefaultInstance() : valueType_;
          } else {
            return valueTypeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Builder setValueType(Onnx.TypeProto value) {
          if (valueTypeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            valueType_ = value;
          } else {
            valueTypeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Builder setValueType(
            Onnx.TypeProto.Builder builderForValue) {
          if (valueTypeBuilder_ == null) {
            valueType_ = builderForValue.build();
          } else {
            valueTypeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Builder mergeValueType(Onnx.TypeProto value) {
          if (valueTypeBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
              valueType_ != null &&
              valueType_ != Onnx.TypeProto.getDefaultInstance()) {
              getValueTypeBuilder().mergeFrom(value);
            } else {
              valueType_ = value;
            }
          } else {
            valueTypeBuilder_.mergeFrom(value);
          }
          if (valueType_ != null) {
            bitField0_ |= 0x00000002;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Builder clearValueType() {
          bitField0_ = (bitField0_ & ~0x00000002);
          valueType_ = null;
          if (valueTypeBuilder_ != null) {
            valueTypeBuilder_.dispose();
            valueTypeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Onnx.TypeProto.Builder getValueTypeBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return internalGetValueTypeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        public Onnx.TypeProtoOrBuilder getValueTypeOrBuilder() {
          if (valueTypeBuilder_ != null) {
            return valueTypeBuilder_.getMessageOrBuilder();
          } else {
            return valueType_ == null ?
                Onnx.TypeProto.getDefaultInstance() : valueType_;
          }
        }
        /**
         * <pre>
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional .TypeProto value_type = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
            internalGetValueTypeFieldBuilder() {
          if (valueTypeBuilder_ == null) {
            valueTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                    getValueType(),
                    getParentForChildren(),
                    isClean());
            valueType_ = null;
          }
          return valueTypeBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:TypeProto.Map)
      }

      // @@protoc_insertion_point(class_scope:TypeProto.Map)
      private static final Onnx.TypeProto.Map DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TypeProto.Map();
      }

      public static Onnx.TypeProto.Map getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Map>
          PARSER = new com.google.protobuf.AbstractParser<Map>() {
        @java.lang.Override
        public Map parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Map> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Map> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TypeProto.Map getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface OptionalOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TypeProto.Optional)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      boolean hasElemType();
      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return The elemType.
       */
      Onnx.TypeProto getElemType();
      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       */
      Onnx.TypeProtoOrBuilder getElemTypeOrBuilder();
    }
    /**
     * <pre>
     * wrapper for Tensor, Sequence, or Map
     * </pre>
     *
     * Protobuf type {@code TypeProto.Optional}
     */
    public static final class Optional extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TypeProto.Optional)
        OptionalOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          Optional.class.getName());
      }
      // Use Optional.newBuilder() to construct.
      private Optional(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private Optional() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_Optional_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_Optional_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.Optional.class, Onnx.TypeProto.Optional.Builder.class);
      }

      private int bitField0_;
      public static final int ELEM_TYPE_FIELD_NUMBER = 1;
      private Onnx.TypeProto elemType_;
      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      @java.lang.Override
      public boolean hasElemType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       * @return The elemType.
       */
      @java.lang.Override
      public Onnx.TypeProto getElemType() {
        return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
      }
      /**
       * <pre>
       * The type and optional shape of the element wrapped.
       * This field MUST be present for this version of the IR.
       * Possible values correspond to OptionalProto.DataType enum
       * </pre>
       *
       * <code>optional .TypeProto elem_type = 1;</code>
       */
      @java.lang.Override
      public Onnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
        return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(1, getElemType());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getElemType());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TypeProto.Optional)) {
          return super.equals(obj);
        }
        Onnx.TypeProto.Optional other = (Onnx.TypeProto.Optional) obj;

        if (hasElemType() != other.hasElemType()) return false;
        if (hasElemType()) {
          if (!getElemType()
              .equals(other.getElemType())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasElemType()) {
          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getElemType().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TypeProto.Optional parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Optional parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.Optional parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TypeProto.Optional parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TypeProto.Optional parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.Optional parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TypeProto.Optional prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * wrapper for Tensor, Sequence, or Map
       * </pre>
       *
       * Protobuf type {@code TypeProto.Optional}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TypeProto.Optional)
          Onnx.TypeProto.OptionalOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TypeProto_Optional_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TypeProto_Optional_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TypeProto.Optional.class, Onnx.TypeProto.Optional.Builder.class);
        }

        // Construct using Onnx.TypeProto.Optional.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetElemTypeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          elemType_ = null;
          if (elemTypeBuilder_ != null) {
            elemTypeBuilder_.dispose();
            elemTypeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TypeProto_Optional_descriptor;
        }

        @java.lang.Override
        public Onnx.TypeProto.Optional getDefaultInstanceForType() {
          return Onnx.TypeProto.Optional.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TypeProto.Optional build() {
          Onnx.TypeProto.Optional result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TypeProto.Optional buildPartial() {
          Onnx.TypeProto.Optional result = new Onnx.TypeProto.Optional(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TypeProto.Optional result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.elemType_ = elemTypeBuilder_ == null
                ? elemType_
                : elemTypeBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TypeProto.Optional) {
            return mergeFrom((Onnx.TypeProto.Optional)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TypeProto.Optional other) {
          if (other == Onnx.TypeProto.Optional.getDefaultInstance()) return this;
          if (other.hasElemType()) {
            mergeElemType(other.getElemType());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  input.readMessage(
                      internalGetElemTypeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private Onnx.TypeProto elemType_;
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> elemTypeBuilder_;
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         * @return Whether the elemType field is set.
         */
        public boolean hasElemType() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         * @return The elemType.
         */
        public Onnx.TypeProto getElemType() {
          if (elemTypeBuilder_ == null) {
            return elemType_ == null ? Onnx.TypeProto.getDefaultInstance() : elemType_;
          } else {
            return elemTypeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder setElemType(Onnx.TypeProto value) {
          if (elemTypeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            elemType_ = value;
          } else {
            elemTypeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder setElemType(
            Onnx.TypeProto.Builder builderForValue) {
          if (elemTypeBuilder_ == null) {
            elemType_ = builderForValue.build();
          } else {
            elemTypeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder mergeElemType(Onnx.TypeProto value) {
          if (elemTypeBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0) &&
              elemType_ != null &&
              elemType_ != Onnx.TypeProto.getDefaultInstance()) {
              getElemTypeBuilder().mergeFrom(value);
            } else {
              elemType_ = value;
            }
          } else {
            elemTypeBuilder_.mergeFrom(value);
          }
          if (elemType_ != null) {
            bitField0_ |= 0x00000001;
            onChanged();
          }
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Builder clearElemType() {
          bitField0_ = (bitField0_ & ~0x00000001);
          elemType_ = null;
          if (elemTypeBuilder_ != null) {
            elemTypeBuilder_.dispose();
            elemTypeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Onnx.TypeProto.Builder getElemTypeBuilder() {
          bitField0_ |= 0x00000001;
          onChanged();
          return internalGetElemTypeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        public Onnx.TypeProtoOrBuilder getElemTypeOrBuilder() {
          if (elemTypeBuilder_ != null) {
            return elemTypeBuilder_.getMessageOrBuilder();
          } else {
            return elemType_ == null ?
                Onnx.TypeProto.getDefaultInstance() : elemType_;
          }
        }
        /**
         * <pre>
         * The type and optional shape of the element wrapped.
         * This field MUST be present for this version of the IR.
         * Possible values correspond to OptionalProto.DataType enum
         * </pre>
         *
         * <code>optional .TypeProto elem_type = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder> 
            internalGetElemTypeFieldBuilder() {
          if (elemTypeBuilder_ == null) {
            elemTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                Onnx.TypeProto, Onnx.TypeProto.Builder, Onnx.TypeProtoOrBuilder>(
                    getElemType(),
                    getParentForChildren(),
                    isClean());
            elemType_ = null;
          }
          return elemTypeBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:TypeProto.Optional)
      }

      // @@protoc_insertion_point(class_scope:TypeProto.Optional)
      private static final Onnx.TypeProto.Optional DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TypeProto.Optional();
      }

      public static Onnx.TypeProto.Optional getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Optional>
          PARSER = new com.google.protobuf.AbstractParser<Optional>() {
        @java.lang.Override
        public Optional parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Optional> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Optional> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TypeProto.Optional getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface SparseTensorOrBuilder extends
        // @@protoc_insertion_point(interface_extends:TypeProto.SparseTensor)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      boolean hasElemType();
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return The elemType.
       */
      int getElemType();

      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return Whether the shape field is set.
       */
      boolean hasShape();
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return The shape.
       */
      Onnx.TensorShapeProto getShape();
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       */
      Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder();
    }
    /**
     * Protobuf type {@code TypeProto.SparseTensor}
     */
    public static final class SparseTensor extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:TypeProto.SparseTensor)
        SparseTensorOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 31,
          /* patch= */ 1,
          /* suffix= */ "",
          SparseTensor.class.getName());
      }
      // Use SparseTensor.newBuilder() to construct.
      private SparseTensor(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private SparseTensor() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.SparseTensor.class, Onnx.TypeProto.SparseTensor.Builder.class);
      }

      private int bitField0_;
      public static final int ELEM_TYPE_FIELD_NUMBER = 1;
      private int elemType_ = 0;
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return Whether the elemType field is set.
       */
      @java.lang.Override
      public boolean hasElemType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * This field MUST NOT have the value of UNDEFINED
       * This field MUST have a valid TensorProto.DataType value
       * This field MUST be present for this version of the IR.
       * </pre>
       *
       * <code>optional int32 elem_type = 1;</code>
       * @return The elemType.
       */
      @java.lang.Override
      public int getElemType() {
        return elemType_;
      }

      public static final int SHAPE_FIELD_NUMBER = 2;
      private Onnx.TensorShapeProto shape_;
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return Whether the shape field is set.
       */
      @java.lang.Override
      public boolean hasShape() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       * @return The shape.
       */
      @java.lang.Override
      public Onnx.TensorShapeProto getShape() {
        return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
      }
      /**
       * <code>optional .TensorShapeProto shape = 2;</code>
       */
      @java.lang.Override
      public Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
        return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt32(1, elemType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getShape());
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, elemType_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getShape());
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof Onnx.TypeProto.SparseTensor)) {
          return super.equals(obj);
        }
        Onnx.TypeProto.SparseTensor other = (Onnx.TypeProto.SparseTensor) obj;

        if (hasElemType() != other.hasElemType()) return false;
        if (hasElemType()) {
          if (getElemType()
              != other.getElemType()) return false;
        }
        if (hasShape() != other.hasShape()) return false;
        if (hasShape()) {
          if (!getShape()
              .equals(other.getShape())) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasElemType()) {
          hash = (37 * hash) + ELEM_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getElemType();
        }
        if (hasShape()) {
          hash = (37 * hash) + SHAPE_FIELD_NUMBER;
          hash = (53 * hash) + getShape().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static Onnx.TypeProto.SparseTensor parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static Onnx.TypeProto.SparseTensor parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static Onnx.TypeProto.SparseTensor parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static Onnx.TypeProto.SparseTensor parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(Onnx.TypeProto.SparseTensor prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code TypeProto.SparseTensor}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:TypeProto.SparseTensor)
          Onnx.TypeProto.SparseTensorOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return Onnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return Onnx.internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  Onnx.TypeProto.SparseTensor.class, Onnx.TypeProto.SparseTensor.Builder.class);
        }

        // Construct using Onnx.TypeProto.SparseTensor.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessage
                  .alwaysUseFieldBuilders) {
            internalGetShapeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          elemType_ = 0;
          shape_ = null;
          if (shapeBuilder_ != null) {
            shapeBuilder_.dispose();
            shapeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return Onnx.internal_static_onnx_TypeProto_SparseTensor_descriptor;
        }

        @java.lang.Override
        public Onnx.TypeProto.SparseTensor getDefaultInstanceForType() {
          return Onnx.TypeProto.SparseTensor.getDefaultInstance();
        }

        @java.lang.Override
        public Onnx.TypeProto.SparseTensor build() {
          Onnx.TypeProto.SparseTensor result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public Onnx.TypeProto.SparseTensor buildPartial() {
          Onnx.TypeProto.SparseTensor result = new Onnx.TypeProto.SparseTensor(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(Onnx.TypeProto.SparseTensor result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.elemType_ = elemType_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.shape_ = shapeBuilder_ == null
                ? shape_
                : shapeBuilder_.build();
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof Onnx.TypeProto.SparseTensor) {
            return mergeFrom((Onnx.TypeProto.SparseTensor)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(Onnx.TypeProto.SparseTensor other) {
          if (other == Onnx.TypeProto.SparseTensor.getDefaultInstance()) return this;
          if (other.hasElemType()) {
            setElemType(other.getElemType());
          }
          if (other.hasShape()) {
            mergeShape(other.getShape());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  elemType_ = input.readInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  input.readMessage(
                      internalGetShapeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int elemType_ ;
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return Whether the elemType field is set.
         */
        @java.lang.Override
        public boolean hasElemType() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return The elemType.
         */
        @java.lang.Override
        public int getElemType() {
          return elemType_;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @param value The elemType to set.
         * @return This builder for chaining.
         */
        public Builder setElemType(int value) {

          elemType_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field MUST NOT have the value of UNDEFINED
         * This field MUST have a valid TensorProto.DataType value
         * This field MUST be present for this version of the IR.
         * </pre>
         *
         * <code>optional int32 elem_type = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearElemType() {
          bitField0_ = (bitField0_ & ~0x00000001);
          elemType_ = 0;
          onChanged();
          return this;
        }

        private Onnx.TensorShapeProto shape_;
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder> shapeBuilder_;
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         * @return Whether the shape field is set.
         */
        public boolean hasShape() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         * @return The shape.
         */
        public Onnx.TensorShapeProto getShape() {
          if (shapeBuilder_ == null) {
            return shape_ == null ? Onnx.TensorShapeProto.getDefaultInstance() : shape_;
          } else {
            return shapeBuilder_.getMessage();
          }
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(Onnx.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            shape_ = value;
          } else {
            shapeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder setShape(
            Onnx.TensorShapeProto.Builder builderForValue) {
          if (shapeBuilder_ == null) {
            shape_ = builderForValue.build();
          } else {
            shapeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder mergeShape(Onnx.TensorShapeProto value) {
          if (shapeBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
              shape_ != null &&
              shape_ != Onnx.TensorShapeProto.getDefaultInstance()) {
              getShapeBuilder().mergeFrom(value);
            } else {
              shape_ = value;
            }
          } else {
            shapeBuilder_.mergeFrom(value);
          }
          if (shape_ != null) {
            bitField0_ |= 0x00000002;
            onChanged();
          }
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Builder clearShape() {
          bitField0_ = (bitField0_ & ~0x00000002);
          shape_ = null;
          if (shapeBuilder_ != null) {
            shapeBuilder_.dispose();
            shapeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Onnx.TensorShapeProto.Builder getShapeBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return internalGetShapeFieldBuilder().getBuilder();
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        public Onnx.TensorShapeProtoOrBuilder getShapeOrBuilder() {
          if (shapeBuilder_ != null) {
            return shapeBuilder_.getMessageOrBuilder();
          } else {
            return shape_ == null ?
                Onnx.TensorShapeProto.getDefaultInstance() : shape_;
          }
        }
        /**
         * <code>optional .TensorShapeProto shape = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilder<
            Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder> 
            internalGetShapeFieldBuilder() {
          if (shapeBuilder_ == null) {
            shapeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                Onnx.TensorShapeProto, Onnx.TensorShapeProto.Builder, Onnx.TensorShapeProtoOrBuilder>(
                    getShape(),
                    getParentForChildren(),
                    isClean());
            shape_ = null;
          }
          return shapeBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:TypeProto.SparseTensor)
      }

      // @@protoc_insertion_point(class_scope:TypeProto.SparseTensor)
      private static final Onnx.TypeProto.SparseTensor DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new Onnx.TypeProto.SparseTensor();
      }

      public static Onnx.TypeProto.SparseTensor getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SparseTensor>
          PARSER = new com.google.protobuf.AbstractParser<SparseTensor>() {
        @java.lang.Override
        public SparseTensor parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<SparseTensor> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SparseTensor> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public Onnx.TypeProto.SparseTensor getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    private int valueCase_ = 0;
    @SuppressWarnings("serial")
    private java.lang.Object value_;
    public enum ValueCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      TENSOR_TYPE(1),
      SEQUENCE_TYPE(4),
      MAP_TYPE(5),
      OPTIONAL_TYPE(9),
      SPARSE_TENSOR_TYPE(8),
      VALUE_NOT_SET(0);
      private final int value;
      private ValueCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValueCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValueCase forNumber(int value) {
        switch (value) {
          case 1: return TENSOR_TYPE;
          case 4: return SEQUENCE_TYPE;
          case 5: return MAP_TYPE;
          case 9: return OPTIONAL_TYPE;
          case 8: return SPARSE_TENSOR_TYPE;
          case 0: return VALUE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ValueCase
    getValueCase() {
      return ValueCase.forNumber(
          valueCase_);
    }

    public static final int TENSOR_TYPE_FIELD_NUMBER = 1;
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     * @return Whether the tensorType field is set.
     */
    @java.lang.Override
    public boolean hasTensorType() {
      return valueCase_ == 1;
    }
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     * @return The tensorType.
     */
    @java.lang.Override
    public Onnx.TypeProto.Tensor getTensorType() {
      if (valueCase_ == 1) {
         return (Onnx.TypeProto.Tensor) value_;
      }
      return Onnx.TypeProto.Tensor.getDefaultInstance();
    }
    /**
     * <pre>
     * The type of a tensor.
     * </pre>
     *
     * <code>.TypeProto.Tensor tensor_type = 1;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
      if (valueCase_ == 1) {
         return (Onnx.TypeProto.Tensor) value_;
      }
      return Onnx.TypeProto.Tensor.getDefaultInstance();
    }

    public static final int SEQUENCE_TYPE_FIELD_NUMBER = 4;
    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     * @return Whether the sequenceType field is set.
     */
    @java.lang.Override
    public boolean hasSequenceType() {
      return valueCase_ == 4;
    }
    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     * @return The sequenceType.
     */
    @java.lang.Override
    public Onnx.TypeProto.Sequence getSequenceType() {
      if (valueCase_ == 4) {
         return (Onnx.TypeProto.Sequence) value_;
      }
      return Onnx.TypeProto.Sequence.getDefaultInstance();
    }
    /**
     * <pre>
     * The type of a sequence.
     * </pre>
     *
     * <code>.TypeProto.Sequence sequence_type = 4;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
      if (valueCase_ == 4) {
         return (Onnx.TypeProto.Sequence) value_;
      }
      return Onnx.TypeProto.Sequence.getDefaultInstance();
    }

    public static final int MAP_TYPE_FIELD_NUMBER = 5;
    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     * @return Whether the mapType field is set.
     */
    @java.lang.Override
    public boolean hasMapType() {
      return valueCase_ == 5;
    }
    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     * @return The mapType.
     */
    @java.lang.Override
    public Onnx.TypeProto.Map getMapType() {
      if (valueCase_ == 5) {
         return (Onnx.TypeProto.Map) value_;
      }
      return Onnx.TypeProto.Map.getDefaultInstance();
    }
    /**
     * <pre>
     * The type of a map.
     * </pre>
     *
     * <code>.TypeProto.Map map_type = 5;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
      if (valueCase_ == 5) {
         return (Onnx.TypeProto.Map) value_;
      }
      return Onnx.TypeProto.Map.getDefaultInstance();
    }

    public static final int OPTIONAL_TYPE_FIELD_NUMBER = 9;
    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     * @return Whether the optionalType field is set.
     */
    @java.lang.Override
    public boolean hasOptionalType() {
      return valueCase_ == 9;
    }
    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     * @return The optionalType.
     */
    @java.lang.Override
    public Onnx.TypeProto.Optional getOptionalType() {
      if (valueCase_ == 9) {
         return (Onnx.TypeProto.Optional) value_;
      }
      return Onnx.TypeProto.Optional.getDefaultInstance();
    }
    /**
     * <pre>
     * The type of an optional.
     * </pre>
     *
     * <code>.TypeProto.Optional optional_type = 9;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {
      if (valueCase_ == 9) {
         return (Onnx.TypeProto.Optional) value_;
      }
      return Onnx.TypeProto.Optional.getDefaultInstance();
    }

    public static final int SPARSE_TENSOR_TYPE_FIELD_NUMBER = 8;
    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     * @return Whether the sparseTensorType field is set.
     */
    @java.lang.Override
    public boolean hasSparseTensorType() {
      return valueCase_ == 8;
    }
    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     * @return The sparseTensorType.
     */
    @java.lang.Override
    public Onnx.TypeProto.SparseTensor getSparseTensorType() {
      if (valueCase_ == 8) {
         return (Onnx.TypeProto.SparseTensor) value_;
      }
      return Onnx.TypeProto.SparseTensor.getDefaultInstance();
    }
    /**
     * <pre>
     * Type of the sparse tensor
     * </pre>
     *
     * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
     */
    @java.lang.Override
    public Onnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
      if (valueCase_ == 8) {
         return (Onnx.TypeProto.SparseTensor) value_;
      }
      return Onnx.TypeProto.SparseTensor.getDefaultInstance();
    }

    public static final int DENOTATION_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private volatile java.lang.Object denotation_ = "";
    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return Whether the denotation field is set.
     */
    @java.lang.Override
    public boolean hasDenotation() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return The denotation.
     */
    @java.lang.Override
    public java.lang.String getDenotation() {
      java.lang.Object ref = denotation_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          denotation_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * An optional denotation can be used to denote the whole
     * type with a standard semantic description as to what is
     * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
     * for pre-defined type denotations.
     * </pre>
     *
     * <code>optional string denotation = 6;</code>
     * @return The bytes for denotation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDenotationBytes() {
      java.lang.Object ref = denotation_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        denotation_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (valueCase_ == 1) {
        output.writeMessage(1, (Onnx.TypeProto.Tensor) value_);
      }
      if (valueCase_ == 4) {
        output.writeMessage(4, (Onnx.TypeProto.Sequence) value_);
      }
      if (valueCase_ == 5) {
        output.writeMessage(5, (Onnx.TypeProto.Map) value_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, denotation_);
      }
      if (valueCase_ == 8) {
        output.writeMessage(8, (Onnx.TypeProto.SparseTensor) value_);
      }
      if (valueCase_ == 9) {
        output.writeMessage(9, (Onnx.TypeProto.Optional) value_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (valueCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (Onnx.TypeProto.Tensor) value_);
      }
      if (valueCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, (Onnx.TypeProto.Sequence) value_);
      }
      if (valueCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, (Onnx.TypeProto.Map) value_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(6, denotation_);
      }
      if (valueCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (Onnx.TypeProto.SparseTensor) value_);
      }
      if (valueCase_ == 9) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, (Onnx.TypeProto.Optional) value_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.TypeProto)) {
        return super.equals(obj);
      }
      Onnx.TypeProto other = (Onnx.TypeProto) obj;

      if (hasDenotation() != other.hasDenotation()) return false;
      if (hasDenotation()) {
        if (!getDenotation()
            .equals(other.getDenotation())) return false;
      }
      if (!getValueCase().equals(other.getValueCase())) return false;
      switch (valueCase_) {
        case 1:
          if (!getTensorType()
              .equals(other.getTensorType())) return false;
          break;
        case 4:
          if (!getSequenceType()
              .equals(other.getSequenceType())) return false;
          break;
        case 5:
          if (!getMapType()
              .equals(other.getMapType())) return false;
          break;
        case 9:
          if (!getOptionalType()
              .equals(other.getOptionalType())) return false;
          break;
        case 8:
          if (!getSparseTensorType()
              .equals(other.getSparseTensorType())) return false;
          break;
        case 0:
        default:
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasDenotation()) {
        hash = (37 * hash) + DENOTATION_FIELD_NUMBER;
        hash = (53 * hash) + getDenotation().hashCode();
      }
      switch (valueCase_) {
        case 1:
          hash = (37 * hash) + TENSOR_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getTensorType().hashCode();
          break;
        case 4:
          hash = (37 * hash) + SEQUENCE_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getSequenceType().hashCode();
          break;
        case 5:
          hash = (37 * hash) + MAP_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getMapType().hashCode();
          break;
        case 9:
          hash = (37 * hash) + OPTIONAL_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getOptionalType().hashCode();
          break;
        case 8:
          hash = (37 * hash) + SPARSE_TENSOR_TYPE_FIELD_NUMBER;
          hash = (53 * hash) + getSparseTensorType().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.TypeProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TypeProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TypeProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TypeProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TypeProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.TypeProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.TypeProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TypeProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.TypeProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.TypeProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.TypeProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.TypeProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.TypeProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Types
     *
     * The standard ONNX data types.
     * </pre>
     *
     * Protobuf type {@code TypeProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:TypeProto)
        Onnx.TypeProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_TypeProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_TypeProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.TypeProto.class, Onnx.TypeProto.Builder.class);
      }

      // Construct using Onnx.TypeProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (tensorTypeBuilder_ != null) {
          tensorTypeBuilder_.clear();
        }
        if (sequenceTypeBuilder_ != null) {
          sequenceTypeBuilder_.clear();
        }
        if (mapTypeBuilder_ != null) {
          mapTypeBuilder_.clear();
        }
        if (optionalTypeBuilder_ != null) {
          optionalTypeBuilder_.clear();
        }
        if (sparseTensorTypeBuilder_ != null) {
          sparseTensorTypeBuilder_.clear();
        }
        denotation_ = "";
        valueCase_ = 0;
        value_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_TypeProto_descriptor;
      }

      @java.lang.Override
      public Onnx.TypeProto getDefaultInstanceForType() {
        return Onnx.TypeProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.TypeProto build() {
        Onnx.TypeProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.TypeProto buildPartial() {
        Onnx.TypeProto result = new Onnx.TypeProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        buildPartialOneofs(result);
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.TypeProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.denotation_ = denotation_;
          to_bitField0_ |= 0x00000001;
        }
        result.bitField0_ |= to_bitField0_;
      }

      private void buildPartialOneofs(Onnx.TypeProto result) {
        result.valueCase_ = valueCase_;
        result.value_ = this.value_;
        if (valueCase_ == 1 &&
            tensorTypeBuilder_ != null) {
          result.value_ = tensorTypeBuilder_.build();
        }
        if (valueCase_ == 4 &&
            sequenceTypeBuilder_ != null) {
          result.value_ = sequenceTypeBuilder_.build();
        }
        if (valueCase_ == 5 &&
            mapTypeBuilder_ != null) {
          result.value_ = mapTypeBuilder_.build();
        }
        if (valueCase_ == 9 &&
            optionalTypeBuilder_ != null) {
          result.value_ = optionalTypeBuilder_.build();
        }
        if (valueCase_ == 8 &&
            sparseTensorTypeBuilder_ != null) {
          result.value_ = sparseTensorTypeBuilder_.build();
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.TypeProto) {
          return mergeFrom((Onnx.TypeProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.TypeProto other) {
        if (other == Onnx.TypeProto.getDefaultInstance()) return this;
        if (other.hasDenotation()) {
          denotation_ = other.denotation_;
          bitField0_ |= 0x00000020;
          onChanged();
        }
        switch (other.getValueCase()) {
          case TENSOR_TYPE: {
            mergeTensorType(other.getTensorType());
            break;
          }
          case SEQUENCE_TYPE: {
            mergeSequenceType(other.getSequenceType());
            break;
          }
          case MAP_TYPE: {
            mergeMapType(other.getMapType());
            break;
          }
          case OPTIONAL_TYPE: {
            mergeOptionalType(other.getOptionalType());
            break;
          }
          case SPARSE_TENSOR_TYPE: {
            mergeSparseTensorType(other.getSparseTensorType());
            break;
          }
          case VALUE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                input.readMessage(
                    internalGetTensorTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 1;
                break;
              } // case 10
              case 34: {
                input.readMessage(
                    internalGetSequenceTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 4;
                break;
              } // case 34
              case 42: {
                input.readMessage(
                    internalGetMapTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 5;
                break;
              } // case 42
              case 50: {
                denotation_ = input.readBytes();
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 66: {
                input.readMessage(
                    internalGetSparseTensorTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 8;
                break;
              } // case 66
              case 74: {
                input.readMessage(
                    internalGetOptionalTypeFieldBuilder().getBuilder(),
                    extensionRegistry);
                valueCase_ = 9;
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int valueCase_ = 0;
      private java.lang.Object value_;
      public ValueCase
          getValueCase() {
        return ValueCase.forNumber(
            valueCase_);
      }

      public Builder clearValue() {
        valueCase_ = 0;
        value_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Tensor, Onnx.TypeProto.Tensor.Builder, Onnx.TypeProto.TensorOrBuilder> tensorTypeBuilder_;
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       * @return Whether the tensorType field is set.
       */
      @java.lang.Override
      public boolean hasTensorType() {
        return valueCase_ == 1;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       * @return The tensorType.
       */
      @java.lang.Override
      public Onnx.TypeProto.Tensor getTensorType() {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1) {
            return (Onnx.TypeProto.Tensor) value_;
          }
          return Onnx.TypeProto.Tensor.getDefaultInstance();
        } else {
          if (valueCase_ == 1) {
            return tensorTypeBuilder_.getMessage();
          }
          return Onnx.TypeProto.Tensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder setTensorType(Onnx.TypeProto.Tensor value) {
        if (tensorTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          tensorTypeBuilder_.setMessage(value);
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder setTensorType(
          Onnx.TypeProto.Tensor.Builder builderForValue) {
        if (tensorTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          tensorTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder mergeTensorType(Onnx.TypeProto.Tensor value) {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1 &&
              value_ != Onnx.TypeProto.Tensor.getDefaultInstance()) {
            value_ = Onnx.TypeProto.Tensor.newBuilder((Onnx.TypeProto.Tensor) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 1) {
            tensorTypeBuilder_.mergeFrom(value);
          } else {
            tensorTypeBuilder_.setMessage(value);
          }
        }
        valueCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Builder clearTensorType() {
        if (tensorTypeBuilder_ == null) {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 1) {
            valueCase_ = 0;
            value_ = null;
          }
          tensorTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      public Onnx.TypeProto.Tensor.Builder getTensorTypeBuilder() {
        return internalGetTensorTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      @java.lang.Override
      public Onnx.TypeProto.TensorOrBuilder getTensorTypeOrBuilder() {
        if ((valueCase_ == 1) && (tensorTypeBuilder_ != null)) {
          return tensorTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 1) {
            return (Onnx.TypeProto.Tensor) value_;
          }
          return Onnx.TypeProto.Tensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a tensor.
       * </pre>
       *
       * <code>.TypeProto.Tensor tensor_type = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Tensor, Onnx.TypeProto.Tensor.Builder, Onnx.TypeProto.TensorOrBuilder> 
          internalGetTensorTypeFieldBuilder() {
        if (tensorTypeBuilder_ == null) {
          if (!(valueCase_ == 1)) {
            value_ = Onnx.TypeProto.Tensor.getDefaultInstance();
          }
          tensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto.Tensor, Onnx.TypeProto.Tensor.Builder, Onnx.TypeProto.TensorOrBuilder>(
                  (Onnx.TypeProto.Tensor) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 1;
        onChanged();
        return tensorTypeBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Sequence, Onnx.TypeProto.Sequence.Builder, Onnx.TypeProto.SequenceOrBuilder> sequenceTypeBuilder_;
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       * @return Whether the sequenceType field is set.
       */
      @java.lang.Override
      public boolean hasSequenceType() {
        return valueCase_ == 4;
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       * @return The sequenceType.
       */
      @java.lang.Override
      public Onnx.TypeProto.Sequence getSequenceType() {
        if (sequenceTypeBuilder_ == null) {
          if (valueCase_ == 4) {
            return (Onnx.TypeProto.Sequence) value_;
          }
          return Onnx.TypeProto.Sequence.getDefaultInstance();
        } else {
          if (valueCase_ == 4) {
            return sequenceTypeBuilder_.getMessage();
          }
          return Onnx.TypeProto.Sequence.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      public Builder setSequenceType(Onnx.TypeProto.Sequence value) {
        if (sequenceTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          sequenceTypeBuilder_.setMessage(value);
        }
        valueCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      public Builder setSequenceType(
          Onnx.TypeProto.Sequence.Builder builderForValue) {
        if (sequenceTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          sequenceTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      public Builder mergeSequenceType(Onnx.TypeProto.Sequence value) {
        if (sequenceTypeBuilder_ == null) {
          if (valueCase_ == 4 &&
              value_ != Onnx.TypeProto.Sequence.getDefaultInstance()) {
            value_ = Onnx.TypeProto.Sequence.newBuilder((Onnx.TypeProto.Sequence) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 4) {
            sequenceTypeBuilder_.mergeFrom(value);
          } else {
            sequenceTypeBuilder_.setMessage(value);
          }
        }
        valueCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      public Builder clearSequenceType() {
        if (sequenceTypeBuilder_ == null) {
          if (valueCase_ == 4) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 4) {
            valueCase_ = 0;
            value_ = null;
          }
          sequenceTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      public Onnx.TypeProto.Sequence.Builder getSequenceTypeBuilder() {
        return internalGetSequenceTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      @java.lang.Override
      public Onnx.TypeProto.SequenceOrBuilder getSequenceTypeOrBuilder() {
        if ((valueCase_ == 4) && (sequenceTypeBuilder_ != null)) {
          return sequenceTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 4) {
            return (Onnx.TypeProto.Sequence) value_;
          }
          return Onnx.TypeProto.Sequence.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a sequence.
       * </pre>
       *
       * <code>.TypeProto.Sequence sequence_type = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Sequence, Onnx.TypeProto.Sequence.Builder, Onnx.TypeProto.SequenceOrBuilder> 
          internalGetSequenceTypeFieldBuilder() {
        if (sequenceTypeBuilder_ == null) {
          if (!(valueCase_ == 4)) {
            value_ = Onnx.TypeProto.Sequence.getDefaultInstance();
          }
          sequenceTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto.Sequence, Onnx.TypeProto.Sequence.Builder, Onnx.TypeProto.SequenceOrBuilder>(
                  (Onnx.TypeProto.Sequence) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 4;
        onChanged();
        return sequenceTypeBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Map, Onnx.TypeProto.Map.Builder, Onnx.TypeProto.MapOrBuilder> mapTypeBuilder_;
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       * @return Whether the mapType field is set.
       */
      @java.lang.Override
      public boolean hasMapType() {
        return valueCase_ == 5;
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       * @return The mapType.
       */
      @java.lang.Override
      public Onnx.TypeProto.Map getMapType() {
        if (mapTypeBuilder_ == null) {
          if (valueCase_ == 5) {
            return (Onnx.TypeProto.Map) value_;
          }
          return Onnx.TypeProto.Map.getDefaultInstance();
        } else {
          if (valueCase_ == 5) {
            return mapTypeBuilder_.getMessage();
          }
          return Onnx.TypeProto.Map.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      public Builder setMapType(Onnx.TypeProto.Map value) {
        if (mapTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          mapTypeBuilder_.setMessage(value);
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      public Builder setMapType(
          Onnx.TypeProto.Map.Builder builderForValue) {
        if (mapTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          mapTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      public Builder mergeMapType(Onnx.TypeProto.Map value) {
        if (mapTypeBuilder_ == null) {
          if (valueCase_ == 5 &&
              value_ != Onnx.TypeProto.Map.getDefaultInstance()) {
            value_ = Onnx.TypeProto.Map.newBuilder((Onnx.TypeProto.Map) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 5) {
            mapTypeBuilder_.mergeFrom(value);
          } else {
            mapTypeBuilder_.setMessage(value);
          }
        }
        valueCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      public Builder clearMapType() {
        if (mapTypeBuilder_ == null) {
          if (valueCase_ == 5) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 5) {
            valueCase_ = 0;
            value_ = null;
          }
          mapTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      public Onnx.TypeProto.Map.Builder getMapTypeBuilder() {
        return internalGetMapTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      @java.lang.Override
      public Onnx.TypeProto.MapOrBuilder getMapTypeOrBuilder() {
        if ((valueCase_ == 5) && (mapTypeBuilder_ != null)) {
          return mapTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 5) {
            return (Onnx.TypeProto.Map) value_;
          }
          return Onnx.TypeProto.Map.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of a map.
       * </pre>
       *
       * <code>.TypeProto.Map map_type = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Map, Onnx.TypeProto.Map.Builder, Onnx.TypeProto.MapOrBuilder> 
          internalGetMapTypeFieldBuilder() {
        if (mapTypeBuilder_ == null) {
          if (!(valueCase_ == 5)) {
            value_ = Onnx.TypeProto.Map.getDefaultInstance();
          }
          mapTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto.Map, Onnx.TypeProto.Map.Builder, Onnx.TypeProto.MapOrBuilder>(
                  (Onnx.TypeProto.Map) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 5;
        onChanged();
        return mapTypeBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Optional, Onnx.TypeProto.Optional.Builder, Onnx.TypeProto.OptionalOrBuilder> optionalTypeBuilder_;
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       * @return Whether the optionalType field is set.
       */
      @java.lang.Override
      public boolean hasOptionalType() {
        return valueCase_ == 9;
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       * @return The optionalType.
       */
      @java.lang.Override
      public Onnx.TypeProto.Optional getOptionalType() {
        if (optionalTypeBuilder_ == null) {
          if (valueCase_ == 9) {
            return (Onnx.TypeProto.Optional) value_;
          }
          return Onnx.TypeProto.Optional.getDefaultInstance();
        } else {
          if (valueCase_ == 9) {
            return optionalTypeBuilder_.getMessage();
          }
          return Onnx.TypeProto.Optional.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      public Builder setOptionalType(Onnx.TypeProto.Optional value) {
        if (optionalTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          optionalTypeBuilder_.setMessage(value);
        }
        valueCase_ = 9;
        return this;
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      public Builder setOptionalType(
          Onnx.TypeProto.Optional.Builder builderForValue) {
        if (optionalTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          optionalTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 9;
        return this;
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      public Builder mergeOptionalType(Onnx.TypeProto.Optional value) {
        if (optionalTypeBuilder_ == null) {
          if (valueCase_ == 9 &&
              value_ != Onnx.TypeProto.Optional.getDefaultInstance()) {
            value_ = Onnx.TypeProto.Optional.newBuilder((Onnx.TypeProto.Optional) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 9) {
            optionalTypeBuilder_.mergeFrom(value);
          } else {
            optionalTypeBuilder_.setMessage(value);
          }
        }
        valueCase_ = 9;
        return this;
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      public Builder clearOptionalType() {
        if (optionalTypeBuilder_ == null) {
          if (valueCase_ == 9) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 9) {
            valueCase_ = 0;
            value_ = null;
          }
          optionalTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      public Onnx.TypeProto.Optional.Builder getOptionalTypeBuilder() {
        return internalGetOptionalTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      @java.lang.Override
      public Onnx.TypeProto.OptionalOrBuilder getOptionalTypeOrBuilder() {
        if ((valueCase_ == 9) && (optionalTypeBuilder_ != null)) {
          return optionalTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 9) {
            return (Onnx.TypeProto.Optional) value_;
          }
          return Onnx.TypeProto.Optional.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * The type of an optional.
       * </pre>
       *
       * <code>.TypeProto.Optional optional_type = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.Optional, Onnx.TypeProto.Optional.Builder, Onnx.TypeProto.OptionalOrBuilder> 
          internalGetOptionalTypeFieldBuilder() {
        if (optionalTypeBuilder_ == null) {
          if (!(valueCase_ == 9)) {
            value_ = Onnx.TypeProto.Optional.getDefaultInstance();
          }
          optionalTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto.Optional, Onnx.TypeProto.Optional.Builder, Onnx.TypeProto.OptionalOrBuilder>(
                  (Onnx.TypeProto.Optional) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 9;
        onChanged();
        return optionalTypeBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.SparseTensor, Onnx.TypeProto.SparseTensor.Builder, Onnx.TypeProto.SparseTensorOrBuilder> sparseTensorTypeBuilder_;
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       * @return Whether the sparseTensorType field is set.
       */
      @java.lang.Override
      public boolean hasSparseTensorType() {
        return valueCase_ == 8;
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       * @return The sparseTensorType.
       */
      @java.lang.Override
      public Onnx.TypeProto.SparseTensor getSparseTensorType() {
        if (sparseTensorTypeBuilder_ == null) {
          if (valueCase_ == 8) {
            return (Onnx.TypeProto.SparseTensor) value_;
          }
          return Onnx.TypeProto.SparseTensor.getDefaultInstance();
        } else {
          if (valueCase_ == 8) {
            return sparseTensorTypeBuilder_.getMessage();
          }
          return Onnx.TypeProto.SparseTensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      public Builder setSparseTensorType(Onnx.TypeProto.SparseTensor value) {
        if (sparseTensorTypeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          value_ = value;
          onChanged();
        } else {
          sparseTensorTypeBuilder_.setMessage(value);
        }
        valueCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      public Builder setSparseTensorType(
          Onnx.TypeProto.SparseTensor.Builder builderForValue) {
        if (sparseTensorTypeBuilder_ == null) {
          value_ = builderForValue.build();
          onChanged();
        } else {
          sparseTensorTypeBuilder_.setMessage(builderForValue.build());
        }
        valueCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      public Builder mergeSparseTensorType(Onnx.TypeProto.SparseTensor value) {
        if (sparseTensorTypeBuilder_ == null) {
          if (valueCase_ == 8 &&
              value_ != Onnx.TypeProto.SparseTensor.getDefaultInstance()) {
            value_ = Onnx.TypeProto.SparseTensor.newBuilder((Onnx.TypeProto.SparseTensor) value_)
                .mergeFrom(value).buildPartial();
          } else {
            value_ = value;
          }
          onChanged();
        } else {
          if (valueCase_ == 8) {
            sparseTensorTypeBuilder_.mergeFrom(value);
          } else {
            sparseTensorTypeBuilder_.setMessage(value);
          }
        }
        valueCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      public Builder clearSparseTensorType() {
        if (sparseTensorTypeBuilder_ == null) {
          if (valueCase_ == 8) {
            valueCase_ = 0;
            value_ = null;
            onChanged();
          }
        } else {
          if (valueCase_ == 8) {
            valueCase_ = 0;
            value_ = null;
          }
          sparseTensorTypeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      public Onnx.TypeProto.SparseTensor.Builder getSparseTensorTypeBuilder() {
        return internalGetSparseTensorTypeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      @java.lang.Override
      public Onnx.TypeProto.SparseTensorOrBuilder getSparseTensorTypeOrBuilder() {
        if ((valueCase_ == 8) && (sparseTensorTypeBuilder_ != null)) {
          return sparseTensorTypeBuilder_.getMessageOrBuilder();
        } else {
          if (valueCase_ == 8) {
            return (Onnx.TypeProto.SparseTensor) value_;
          }
          return Onnx.TypeProto.SparseTensor.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Type of the sparse tensor
       * </pre>
       *
       * <code>.TypeProto.SparseTensor sparse_tensor_type = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          Onnx.TypeProto.SparseTensor, Onnx.TypeProto.SparseTensor.Builder, Onnx.TypeProto.SparseTensorOrBuilder> 
          internalGetSparseTensorTypeFieldBuilder() {
        if (sparseTensorTypeBuilder_ == null) {
          if (!(valueCase_ == 8)) {
            value_ = Onnx.TypeProto.SparseTensor.getDefaultInstance();
          }
          sparseTensorTypeBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              Onnx.TypeProto.SparseTensor, Onnx.TypeProto.SparseTensor.Builder, Onnx.TypeProto.SparseTensorOrBuilder>(
                  (Onnx.TypeProto.SparseTensor) value_,
                  getParentForChildren(),
                  isClean());
          value_ = null;
        }
        valueCase_ = 8;
        onChanged();
        return sparseTensorTypeBuilder_;
      }

      private java.lang.Object denotation_ = "";
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @return Whether the denotation field is set.
       */
      public boolean hasDenotation() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @return The denotation.
       */
      public java.lang.String getDenotation() {
        java.lang.Object ref = denotation_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            denotation_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @return The bytes for denotation.
       */
      public com.google.protobuf.ByteString
          getDenotationBytes() {
        java.lang.Object ref = denotation_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          denotation_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @param value The denotation to set.
       * @return This builder for chaining.
       */
      public Builder setDenotation(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        denotation_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDenotation() {
        denotation_ = getDefaultInstance().getDenotation();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional denotation can be used to denote the whole
       * type with a standard semantic description as to what is
       * stored inside. Refer to https://github.com/onnx/onnx/blob/main/docs/TypeDenotation.md#type-denotation-definition
       * for pre-defined type denotations.
       * </pre>
       *
       * <code>optional string denotation = 6;</code>
       * @param value The bytes for denotation to set.
       * @return This builder for chaining.
       */
      public Builder setDenotationBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        denotation_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:TypeProto)
    }

    // @@protoc_insertion_point(class_scope:TypeProto)
    private static final Onnx.TypeProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.TypeProto();
    }

    public static Onnx.TypeProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TypeProto>
        PARSER = new com.google.protobuf.AbstractParser<TypeProto>() {
      @java.lang.Override
      public TypeProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TypeProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TypeProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.TypeProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OperatorSetIdProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:OperatorSetIdProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return Whether the domain field is set.
     */
    boolean hasDomain();
    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return The domain.
     */
    java.lang.String getDomain();
    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return The bytes for domain.
     */
    com.google.protobuf.ByteString
        getDomainBytes();

    /**
     * <pre>
     * The version of the operator set being identified.
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * The version of the operator set being identified.
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    long getVersion();
  }
  /**
   * <pre>
   * Operator Sets
   *
   * OperatorSets are uniquely identified by a (domain, opset_version) pair.
   * </pre>
   *
   * Protobuf type {@code OperatorSetIdProto}
   */
  public static final class OperatorSetIdProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:OperatorSetIdProto)
      OperatorSetIdProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        OperatorSetIdProto.class.getName());
    }
    // Use OperatorSetIdProto.newBuilder() to construct.
    private OperatorSetIdProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private OperatorSetIdProto() {
      domain_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_OperatorSetIdProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.OperatorSetIdProto.class, Onnx.OperatorSetIdProto.Builder.class);
    }

    private int bitField0_;
    public static final int DOMAIN_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object domain_ = "";
    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return Whether the domain field is set.
     */
    @java.lang.Override
    public boolean hasDomain() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return The domain.
     */
    @java.lang.Override
    public java.lang.String getDomain() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          domain_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The domain of the operator set being identified.
     * The empty string ("") or absence of this field implies the operator
     * set that is defined as part of the ONNX specification.
     * This field MUST be present in this version of the IR when referring to any other operator set.
     * </pre>
     *
     * <code>optional string domain = 1;</code>
     * @return The bytes for domain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDomainBytes() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        domain_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    private long version_ = 0L;
    /**
     * <pre>
     * The version of the operator set being identified.
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The version of the operator set being identified.
     * This field MUST be present in this version of the IR.
     * </pre>
     *
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public long getVersion() {
      return version_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, domain_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, version_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, domain_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, version_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.OperatorSetIdProto)) {
        return super.equals(obj);
      }
      Onnx.OperatorSetIdProto other = (Onnx.OperatorSetIdProto) obj;

      if (hasDomain() != other.hasDomain()) return false;
      if (hasDomain()) {
        if (!getDomain()
            .equals(other.getDomain())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (getVersion()
            != other.getVersion()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasDomain()) {
        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
        hash = (53 * hash) + getDomain().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getVersion());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.OperatorSetIdProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.OperatorSetIdProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.OperatorSetIdProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.OperatorSetIdProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.OperatorSetIdProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.OperatorSetIdProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.OperatorSetIdProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Operator Sets
     *
     * OperatorSets are uniquely identified by a (domain, opset_version) pair.
     * </pre>
     *
     * Protobuf type {@code OperatorSetIdProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:OperatorSetIdProto)
        Onnx.OperatorSetIdProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_OperatorSetIdProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_OperatorSetIdProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.OperatorSetIdProto.class, Onnx.OperatorSetIdProto.Builder.class);
      }

      // Construct using Onnx.OperatorSetIdProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        domain_ = "";
        version_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_OperatorSetIdProto_descriptor;
      }

      @java.lang.Override
      public Onnx.OperatorSetIdProto getDefaultInstanceForType() {
        return Onnx.OperatorSetIdProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.OperatorSetIdProto build() {
        Onnx.OperatorSetIdProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.OperatorSetIdProto buildPartial() {
        Onnx.OperatorSetIdProto result = new Onnx.OperatorSetIdProto(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(Onnx.OperatorSetIdProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.domain_ = domain_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.OperatorSetIdProto) {
          return mergeFrom((Onnx.OperatorSetIdProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.OperatorSetIdProto other) {
        if (other == Onnx.OperatorSetIdProto.getDefaultInstance()) return this;
        if (other.hasDomain()) {
          domain_ = other.domain_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          setVersion(other.getVersion());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                domain_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                version_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object domain_ = "";
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @return Whether the domain field is set.
       */
      public boolean hasDomain() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @return The domain.
       */
      public java.lang.String getDomain() {
        java.lang.Object ref = domain_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            domain_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @return The bytes for domain.
       */
      public com.google.protobuf.ByteString
          getDomainBytes() {
        java.lang.Object ref = domain_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          domain_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @param value The domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomain(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDomain() {
        domain_ = getDefaultInstance().getDomain();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain of the operator set being identified.
       * The empty string ("") or absence of this field implies the operator
       * set that is defined as part of the ONNX specification.
       * This field MUST be present in this version of the IR when referring to any other operator set.
       * </pre>
       *
       * <code>optional string domain = 1;</code>
       * @param value The bytes for domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomainBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private long version_ ;
      /**
       * <pre>
       * The version of the operator set being identified.
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional int64 version = 2;</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The version of the operator set being identified.
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional int64 version = 2;</code>
       * @return The version.
       */
      @java.lang.Override
      public long getVersion() {
        return version_;
      }
      /**
       * <pre>
       * The version of the operator set being identified.
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional int64 version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(long value) {

        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the operator set being identified.
       * This field MUST be present in this version of the IR.
       * </pre>
       *
       * <code>optional int64 version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        version_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:OperatorSetIdProto)
    }

    // @@protoc_insertion_point(class_scope:OperatorSetIdProto)
    private static final Onnx.OperatorSetIdProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.OperatorSetIdProto();
    }

    public static Onnx.OperatorSetIdProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OperatorSetIdProto>
        PARSER = new com.google.protobuf.AbstractParser<OperatorSetIdProto>() {
      @java.lang.Override
      public OperatorSetIdProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<OperatorSetIdProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OperatorSetIdProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.OperatorSetIdProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FunctionProtoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:FunctionProto)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @return A list containing the input.
     */
    java.util.List<java.lang.String>
        getInputList();
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @return The count of input.
     */
    int getInputCount();
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @param index The index of the element to return.
     * @return The input at the given index.
     */
    java.lang.String getInput(int index);
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @param index The index of the value to return.
     * @return The bytes of the input at the given index.
     */
    com.google.protobuf.ByteString
        getInputBytes(int index);

    /**
     * <code>repeated string output = 5;</code>
     * @return A list containing the output.
     */
    java.util.List<java.lang.String>
        getOutputList();
    /**
     * <code>repeated string output = 5;</code>
     * @return The count of output.
     */
    int getOutputCount();
    /**
     * <code>repeated string output = 5;</code>
     * @param index The index of the element to return.
     * @return The output at the given index.
     */
    java.lang.String getOutput(int index);
    /**
     * <code>repeated string output = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the output at the given index.
     */
    com.google.protobuf.ByteString
        getOutputBytes(int index);

    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @return A list containing the attribute.
     */
    java.util.List<java.lang.String>
        getAttributeList();
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @return The count of attribute.
     */
    int getAttributeCount();
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @param index The index of the element to return.
     * @return The attribute at the given index.
     */
    java.lang.String getAttribute(int index);
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @param index The index of the value to return.
     * @return The bytes of the attribute at the given index.
     */
    com.google.protobuf.ByteString
        getAttributeBytes(int index);

    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    java.util.List<Onnx.AttributeProto> 
        getAttributeProtoList();
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    Onnx.AttributeProto getAttributeProto(int index);
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    int getAttributeProtoCount();
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
        getAttributeProtoOrBuilderList();
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    Onnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
        int index);

    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    java.util.List<Onnx.NodeProto> 
        getNodeList();
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    Onnx.NodeProto getNode(int index);
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    int getNodeCount();
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    java.util.List<? extends Onnx.NodeProtoOrBuilder> 
        getNodeOrBuilderList();
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    Onnx.NodeProtoOrBuilder getNodeOrBuilder(
        int index);

    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return Whether the docString field is set.
     */
    boolean hasDocString();
    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return The docString.
     */
    java.lang.String getDocString();
    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return The bytes for docString.
     */
    com.google.protobuf.ByteString
        getDocStringBytes();

    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    java.util.List<Onnx.OperatorSetIdProto> 
        getOpsetImportList();
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    Onnx.OperatorSetIdProto getOpsetImport(int index);
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    int getOpsetImportCount();
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
        getOpsetImportOrBuilderList();
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
        int index);

    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return Whether the domain field is set.
     */
    boolean hasDomain();
    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return The domain.
     */
    java.lang.String getDomain();
    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return The bytes for domain.
     */
    com.google.protobuf.ByteString
        getDomainBytes();

    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return Whether the overload field is set.
     */
    boolean hasOverload();
    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return The overload.
     */
    java.lang.String getOverload();
    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return The bytes for overload.
     */
    com.google.protobuf.ByteString
        getOverloadBytes();

    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    java.util.List<Onnx.ValueInfoProto> 
        getValueInfoList();
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    Onnx.ValueInfoProto getValueInfo(int index);
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    int getValueInfoCount();
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getValueInfoOrBuilderList();
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
        int index);

    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    java.util.List<Onnx.StringStringEntryProto> 
        getMetadataPropsList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    Onnx.StringStringEntryProto getMetadataProps(int index);
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    int getMetadataPropsCount();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList();
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code FunctionProto}
   */
  public static final class FunctionProto extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:FunctionProto)
      FunctionProtoOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 31,
        /* patch= */ 1,
        /* suffix= */ "",
        FunctionProto.class.getName());
    }
    // Use FunctionProto.newBuilder() to construct.
    private FunctionProto(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FunctionProto() {
      name_ = "";
      input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      attribute_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      attributeProto_ = java.util.Collections.emptyList();
      node_ = java.util.Collections.emptyList();
      docString_ = "";
      opsetImport_ = java.util.Collections.emptyList();
      domain_ = "";
      overload_ = "";
      valueInfo_ = java.util.Collections.emptyList();
      metadataProps_ = java.util.Collections.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Onnx.internal_static_onnx_FunctionProto_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Onnx.internal_static_onnx_FunctionProto_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Onnx.FunctionProto.class, Onnx.FunctionProto.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The name of the function, similar to op_type in NodeProto.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int INPUT_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList input_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @return A list containing the input.
     */
    public com.google.protobuf.ProtocolStringList
        getInputList() {
      return input_;
    }
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @return The count of input.
     */
    public int getInputCount() {
      return input_.size();
    }
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @param index The index of the element to return.
     * @return The input at the given index.
     */
    public java.lang.String getInput(int index) {
      return input_.get(index);
    }
    /**
     * <pre>
     * The inputs and outputs of the function.
     * </pre>
     *
     * <code>repeated string input = 4;</code>
     * @param index The index of the value to return.
     * @return The bytes of the input at the given index.
     */
    public com.google.protobuf.ByteString
        getInputBytes(int index) {
      return input_.getByteString(index);
    }

    public static final int OUTPUT_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList output_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <code>repeated string output = 5;</code>
     * @return A list containing the output.
     */
    public com.google.protobuf.ProtocolStringList
        getOutputList() {
      return output_;
    }
    /**
     * <code>repeated string output = 5;</code>
     * @return The count of output.
     */
    public int getOutputCount() {
      return output_.size();
    }
    /**
     * <code>repeated string output = 5;</code>
     * @param index The index of the element to return.
     * @return The output at the given index.
     */
    public java.lang.String getOutput(int index) {
      return output_.get(index);
    }
    /**
     * <code>repeated string output = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the output at the given index.
     */
    public com.google.protobuf.ByteString
        getOutputBytes(int index) {
      return output_.getByteString(index);
    }

    public static final int ATTRIBUTE_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList attribute_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @return A list containing the attribute.
     */
    public com.google.protobuf.ProtocolStringList
        getAttributeList() {
      return attribute_;
    }
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @return The count of attribute.
     */
    public int getAttributeCount() {
      return attribute_.size();
    }
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @param index The index of the element to return.
     * @return The attribute at the given index.
     */
    public java.lang.String getAttribute(int index) {
      return attribute_.get(index);
    }
    /**
     * <pre>
     * The attribute parameters of the function.
     * It is for function parameters without default values.
     * </pre>
     *
     * <code>repeated string attribute = 6;</code>
     * @param index The index of the value to return.
     * @return The bytes of the attribute at the given index.
     */
    public com.google.protobuf.ByteString
        getAttributeBytes(int index) {
      return attribute_.getByteString(index);
    }

    public static final int ATTRIBUTE_PROTO_FIELD_NUMBER = 11;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.AttributeProto> attributeProto_;
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.AttributeProto> getAttributeProtoList() {
      return attributeProto_;
    }
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
        getAttributeProtoOrBuilderList() {
      return attributeProto_;
    }
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    @java.lang.Override
    public int getAttributeProtoCount() {
      return attributeProto_.size();
    }
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    @java.lang.Override
    public Onnx.AttributeProto getAttributeProto(int index) {
      return attributeProto_.get(index);
    }
    /**
     * <pre>
     * The attribute protos of the function.
     * It is for function attributes with default values.
     * A function attribute shall be represented either as
     * a string attribute or an AttributeProto, not both.
     * </pre>
     *
     * <code>repeated .AttributeProto attribute_proto = 11;</code>
     */
    @java.lang.Override
    public Onnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
        int index) {
      return attributeProto_.get(index);
    }

    public static final int NODE_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.NodeProto> node_;
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.NodeProto> getNodeList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.NodeProtoOrBuilder> 
        getNodeOrBuilderList() {
      return node_;
    }
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    @java.lang.Override
    public int getNodeCount() {
      return node_.size();
    }
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    @java.lang.Override
    public Onnx.NodeProto getNode(int index) {
      return node_.get(index);
    }
    /**
     * <pre>
     * The nodes in the function.
     * </pre>
     *
     * <code>repeated .NodeProto node = 7;</code>
     */
    @java.lang.Override
    public Onnx.NodeProtoOrBuilder getNodeOrBuilder(
        int index) {
      return node_.get(index);
    }

    public static final int DOC_STRING_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private volatile java.lang.Object docString_ = "";
    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return Whether the docString field is set.
     */
    @java.lang.Override
    public boolean hasDocString() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return The docString.
     */
    @java.lang.Override
    public java.lang.String getDocString() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          docString_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A human-readable documentation for this function. Markdown is allowed.
     * </pre>
     *
     * <code>optional string doc_string = 8;</code>
     * @return The bytes for docString.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDocStringBytes() {
      java.lang.Object ref = docString_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        docString_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OPSET_IMPORT_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.OperatorSetIdProto> opsetImport_;
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.OperatorSetIdProto> getOpsetImportList() {
      return opsetImport_;
    }
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
        getOpsetImportOrBuilderList() {
      return opsetImport_;
    }
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    @java.lang.Override
    public int getOpsetImportCount() {
      return opsetImport_.size();
    }
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    @java.lang.Override
    public Onnx.OperatorSetIdProto getOpsetImport(int index) {
      return opsetImport_.get(index);
    }
    /**
     * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
     */
    @java.lang.Override
    public Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
        int index) {
      return opsetImport_.get(index);
    }

    public static final int DOMAIN_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private volatile java.lang.Object domain_ = "";
    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return Whether the domain field is set.
     */
    @java.lang.Override
    public boolean hasDomain() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return The domain.
     */
    @java.lang.Override
    public java.lang.String getDomain() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          domain_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The domain which this function belongs to.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string domain = 10;</code>
     * @return The bytes for domain.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDomainBytes() {
      java.lang.Object ref = domain_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        domain_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int OVERLOAD_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private volatile java.lang.Object overload_ = "";
    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return Whether the overload field is set.
     */
    @java.lang.Override
    public boolean hasOverload() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return The overload.
     */
    @java.lang.Override
    public java.lang.String getOverload() {
      java.lang.Object ref = overload_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          overload_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The overload identifier of the function.
     * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
     * </pre>
     *
     * <code>optional string overload = 13;</code>
     * @return The bytes for overload.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getOverloadBytes() {
      java.lang.Object ref = overload_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        overload_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_INFO_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.ValueInfoProto> valueInfo_;
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.ValueInfoProto> getValueInfoList() {
      return valueInfo_;
    }
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
        getValueInfoOrBuilderList() {
      return valueInfo_;
    }
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    @java.lang.Override
    public int getValueInfoCount() {
      return valueInfo_.size();
    }
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProto getValueInfo(int index) {
      return valueInfo_.get(index);
    }
    /**
     * <pre>
     * Information for the values in the function. The ValueInfoProto.name's
     * must be distinct and refer to names in the function (including inputs,
     * outputs, and intermediate values). It is optional for a value to appear
     * in value_info list.
     * </pre>
     *
     * <code>repeated .ValueInfoProto value_info = 12;</code>
     */
    @java.lang.Override
    public Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
        int index) {
      return valueInfo_.get(index);
    }

    public static final int METADATA_PROPS_FIELD_NUMBER = 14;
    @SuppressWarnings("serial")
    private java.util.List<Onnx.StringStringEntryProto> metadataProps_;
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
        getMetadataPropsOrBuilderList() {
      return metadataProps_;
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public int getMetadataPropsCount() {
      return metadataProps_.size();
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProto getMetadataProps(int index) {
      return metadataProps_.get(index);
    }
    /**
     * <pre>
     * Named metadata values; keys should be distinct.
     * </pre>
     *
     * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
     */
    @java.lang.Override
    public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
        int index) {
      return metadataProps_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      for (int i = 0; i < input_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 4, input_.getRaw(i));
      }
      for (int i = 0; i < output_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, output_.getRaw(i));
      }
      for (int i = 0; i < attribute_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, attribute_.getRaw(i));
      }
      for (int i = 0; i < node_.size(); i++) {
        output.writeMessage(7, node_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 8, docString_);
      }
      for (int i = 0; i < opsetImport_.size(); i++) {
        output.writeMessage(9, opsetImport_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 10, domain_);
      }
      for (int i = 0; i < attributeProto_.size(); i++) {
        output.writeMessage(11, attributeProto_.get(i));
      }
      for (int i = 0; i < valueInfo_.size(); i++) {
        output.writeMessage(12, valueInfo_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 13, overload_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        output.writeMessage(14, metadataProps_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < input_.size(); i++) {
          dataSize += computeStringSizeNoTag(input_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getInputList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < output_.size(); i++) {
          dataSize += computeStringSizeNoTag(output_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getOutputList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < attribute_.size(); i++) {
          dataSize += computeStringSizeNoTag(attribute_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAttributeList().size();
      }
      for (int i = 0; i < node_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, node_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(8, docString_);
      }
      for (int i = 0; i < opsetImport_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, opsetImport_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(10, domain_);
      }
      for (int i = 0; i < attributeProto_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, attributeProto_.get(i));
      }
      for (int i = 0; i < valueInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, valueInfo_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(13, overload_);
      }
      for (int i = 0; i < metadataProps_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, metadataProps_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Onnx.FunctionProto)) {
        return super.equals(obj);
      }
      Onnx.FunctionProto other = (Onnx.FunctionProto) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (!getInputList()
          .equals(other.getInputList())) return false;
      if (!getOutputList()
          .equals(other.getOutputList())) return false;
      if (!getAttributeList()
          .equals(other.getAttributeList())) return false;
      if (!getAttributeProtoList()
          .equals(other.getAttributeProtoList())) return false;
      if (!getNodeList()
          .equals(other.getNodeList())) return false;
      if (hasDocString() != other.hasDocString()) return false;
      if (hasDocString()) {
        if (!getDocString()
            .equals(other.getDocString())) return false;
      }
      if (!getOpsetImportList()
          .equals(other.getOpsetImportList())) return false;
      if (hasDomain() != other.hasDomain()) return false;
      if (hasDomain()) {
        if (!getDomain()
            .equals(other.getDomain())) return false;
      }
      if (hasOverload() != other.hasOverload()) return false;
      if (hasOverload()) {
        if (!getOverload()
            .equals(other.getOverload())) return false;
      }
      if (!getValueInfoList()
          .equals(other.getValueInfoList())) return false;
      if (!getMetadataPropsList()
          .equals(other.getMetadataPropsList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (getInputCount() > 0) {
        hash = (37 * hash) + INPUT_FIELD_NUMBER;
        hash = (53 * hash) + getInputList().hashCode();
      }
      if (getOutputCount() > 0) {
        hash = (37 * hash) + OUTPUT_FIELD_NUMBER;
        hash = (53 * hash) + getOutputList().hashCode();
      }
      if (getAttributeCount() > 0) {
        hash = (37 * hash) + ATTRIBUTE_FIELD_NUMBER;
        hash = (53 * hash) + getAttributeList().hashCode();
      }
      if (getAttributeProtoCount() > 0) {
        hash = (37 * hash) + ATTRIBUTE_PROTO_FIELD_NUMBER;
        hash = (53 * hash) + getAttributeProtoList().hashCode();
      }
      if (getNodeCount() > 0) {
        hash = (37 * hash) + NODE_FIELD_NUMBER;
        hash = (53 * hash) + getNodeList().hashCode();
      }
      if (hasDocString()) {
        hash = (37 * hash) + DOC_STRING_FIELD_NUMBER;
        hash = (53 * hash) + getDocString().hashCode();
      }
      if (getOpsetImportCount() > 0) {
        hash = (37 * hash) + OPSET_IMPORT_FIELD_NUMBER;
        hash = (53 * hash) + getOpsetImportList().hashCode();
      }
      if (hasDomain()) {
        hash = (37 * hash) + DOMAIN_FIELD_NUMBER;
        hash = (53 * hash) + getDomain().hashCode();
      }
      if (hasOverload()) {
        hash = (37 * hash) + OVERLOAD_FIELD_NUMBER;
        hash = (53 * hash) + getOverload().hashCode();
      }
      if (getValueInfoCount() > 0) {
        hash = (37 * hash) + VALUE_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getValueInfoList().hashCode();
      }
      if (getMetadataPropsCount() > 0) {
        hash = (37 * hash) + METADATA_PROPS_FIELD_NUMBER;
        hash = (53 * hash) + getMetadataPropsList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Onnx.FunctionProto parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.FunctionProto parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.FunctionProto parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.FunctionProto parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.FunctionProto parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Onnx.FunctionProto parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Onnx.FunctionProto parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.FunctionProto parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static Onnx.FunctionProto parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static Onnx.FunctionProto parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Onnx.FunctionProto parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static Onnx.FunctionProto parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Onnx.FunctionProto prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code FunctionProto}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:FunctionProto)
        Onnx.FunctionProtoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Onnx.internal_static_onnx_FunctionProto_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Onnx.internal_static_onnx_FunctionProto_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Onnx.FunctionProto.class, Onnx.FunctionProto.Builder.class);
      }

      // Construct using Onnx.FunctionProto.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        input_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        output_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        attribute_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        if (attributeProtoBuilder_ == null) {
          attributeProto_ = java.util.Collections.emptyList();
        } else {
          attributeProto_ = null;
          attributeProtoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
        } else {
          node_ = null;
          nodeBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        docString_ = "";
        if (opsetImportBuilder_ == null) {
          opsetImport_ = java.util.Collections.emptyList();
        } else {
          opsetImport_ = null;
          opsetImportBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        domain_ = "";
        overload_ = "";
        if (valueInfoBuilder_ == null) {
          valueInfo_ = java.util.Collections.emptyList();
        } else {
          valueInfo_ = null;
          valueInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
        } else {
          metadataProps_ = null;
          metadataPropsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Onnx.internal_static_onnx_FunctionProto_descriptor;
      }

      @java.lang.Override
      public Onnx.FunctionProto getDefaultInstanceForType() {
        return Onnx.FunctionProto.getDefaultInstance();
      }

      @java.lang.Override
      public Onnx.FunctionProto build() {
        Onnx.FunctionProto result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public Onnx.FunctionProto buildPartial() {
        Onnx.FunctionProto result = new Onnx.FunctionProto(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(Onnx.FunctionProto result) {
        if (attributeProtoBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            attributeProto_ = java.util.Collections.unmodifiableList(attributeProto_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.attributeProto_ = attributeProto_;
        } else {
          result.attributeProto_ = attributeProtoBuilder_.build();
        }
        if (nodeBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            node_ = java.util.Collections.unmodifiableList(node_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.node_ = node_;
        } else {
          result.node_ = nodeBuilder_.build();
        }
        if (opsetImportBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            opsetImport_ = java.util.Collections.unmodifiableList(opsetImport_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.opsetImport_ = opsetImport_;
        } else {
          result.opsetImport_ = opsetImportBuilder_.build();
        }
        if (valueInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0)) {
            valueInfo_ = java.util.Collections.unmodifiableList(valueInfo_);
            bitField0_ = (bitField0_ & ~0x00000400);
          }
          result.valueInfo_ = valueInfo_;
        } else {
          result.valueInfo_ = valueInfoBuilder_.build();
        }
        if (metadataPropsBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0)) {
            metadataProps_ = java.util.Collections.unmodifiableList(metadataProps_);
            bitField0_ = (bitField0_ & ~0x00000800);
          }
          result.metadataProps_ = metadataProps_;
        } else {
          result.metadataProps_ = metadataPropsBuilder_.build();
        }
      }

      private void buildPartial0(Onnx.FunctionProto result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          input_.makeImmutable();
          result.input_ = input_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          output_.makeImmutable();
          result.output_ = output_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          attribute_.makeImmutable();
          result.attribute_ = attribute_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.docString_ = docString_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.domain_ = domain_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.overload_ = overload_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Onnx.FunctionProto) {
          return mergeFrom((Onnx.FunctionProto)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Onnx.FunctionProto other) {
        if (other == Onnx.FunctionProto.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.input_.isEmpty()) {
          if (input_.isEmpty()) {
            input_ = other.input_;
            bitField0_ |= 0x00000002;
          } else {
            ensureInputIsMutable();
            input_.addAll(other.input_);
          }
          onChanged();
        }
        if (!other.output_.isEmpty()) {
          if (output_.isEmpty()) {
            output_ = other.output_;
            bitField0_ |= 0x00000004;
          } else {
            ensureOutputIsMutable();
            output_.addAll(other.output_);
          }
          onChanged();
        }
        if (!other.attribute_.isEmpty()) {
          if (attribute_.isEmpty()) {
            attribute_ = other.attribute_;
            bitField0_ |= 0x00000008;
          } else {
            ensureAttributeIsMutable();
            attribute_.addAll(other.attribute_);
          }
          onChanged();
        }
        if (attributeProtoBuilder_ == null) {
          if (!other.attributeProto_.isEmpty()) {
            if (attributeProto_.isEmpty()) {
              attributeProto_ = other.attributeProto_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAttributeProtoIsMutable();
              attributeProto_.addAll(other.attributeProto_);
            }
            onChanged();
          }
        } else {
          if (!other.attributeProto_.isEmpty()) {
            if (attributeProtoBuilder_.isEmpty()) {
              attributeProtoBuilder_.dispose();
              attributeProtoBuilder_ = null;
              attributeProto_ = other.attributeProto_;
              bitField0_ = (bitField0_ & ~0x00000010);
              attributeProtoBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetAttributeProtoFieldBuilder() : null;
            } else {
              attributeProtoBuilder_.addAllMessages(other.attributeProto_);
            }
          }
        }
        if (nodeBuilder_ == null) {
          if (!other.node_.isEmpty()) {
            if (node_.isEmpty()) {
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureNodeIsMutable();
              node_.addAll(other.node_);
            }
            onChanged();
          }
        } else {
          if (!other.node_.isEmpty()) {
            if (nodeBuilder_.isEmpty()) {
              nodeBuilder_.dispose();
              nodeBuilder_ = null;
              node_ = other.node_;
              bitField0_ = (bitField0_ & ~0x00000020);
              nodeBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetNodeFieldBuilder() : null;
            } else {
              nodeBuilder_.addAllMessages(other.node_);
            }
          }
        }
        if (other.hasDocString()) {
          docString_ = other.docString_;
          bitField0_ |= 0x00000040;
          onChanged();
        }
        if (opsetImportBuilder_ == null) {
          if (!other.opsetImport_.isEmpty()) {
            if (opsetImport_.isEmpty()) {
              opsetImport_ = other.opsetImport_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureOpsetImportIsMutable();
              opsetImport_.addAll(other.opsetImport_);
            }
            onChanged();
          }
        } else {
          if (!other.opsetImport_.isEmpty()) {
            if (opsetImportBuilder_.isEmpty()) {
              opsetImportBuilder_.dispose();
              opsetImportBuilder_ = null;
              opsetImport_ = other.opsetImport_;
              bitField0_ = (bitField0_ & ~0x00000080);
              opsetImportBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetOpsetImportFieldBuilder() : null;
            } else {
              opsetImportBuilder_.addAllMessages(other.opsetImport_);
            }
          }
        }
        if (other.hasDomain()) {
          domain_ = other.domain_;
          bitField0_ |= 0x00000100;
          onChanged();
        }
        if (other.hasOverload()) {
          overload_ = other.overload_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        if (valueInfoBuilder_ == null) {
          if (!other.valueInfo_.isEmpty()) {
            if (valueInfo_.isEmpty()) {
              valueInfo_ = other.valueInfo_;
              bitField0_ = (bitField0_ & ~0x00000400);
            } else {
              ensureValueInfoIsMutable();
              valueInfo_.addAll(other.valueInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.valueInfo_.isEmpty()) {
            if (valueInfoBuilder_.isEmpty()) {
              valueInfoBuilder_.dispose();
              valueInfoBuilder_ = null;
              valueInfo_ = other.valueInfo_;
              bitField0_ = (bitField0_ & ~0x00000400);
              valueInfoBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetValueInfoFieldBuilder() : null;
            } else {
              valueInfoBuilder_.addAllMessages(other.valueInfo_);
            }
          }
        }
        if (metadataPropsBuilder_ == null) {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataProps_.isEmpty()) {
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000800);
            } else {
              ensureMetadataPropsIsMutable();
              metadataProps_.addAll(other.metadataProps_);
            }
            onChanged();
          }
        } else {
          if (!other.metadataProps_.isEmpty()) {
            if (metadataPropsBuilder_.isEmpty()) {
              metadataPropsBuilder_.dispose();
              metadataPropsBuilder_ = null;
              metadataProps_ = other.metadataProps_;
              bitField0_ = (bitField0_ & ~0x00000800);
              metadataPropsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   internalGetMetadataPropsFieldBuilder() : null;
            } else {
              metadataPropsBuilder_.addAllMessages(other.metadataProps_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 34: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureInputIsMutable();
                input_.add(bs);
                break;
              } // case 34
              case 42: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureOutputIsMutable();
                output_.add(bs);
                break;
              } // case 42
              case 50: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAttributeIsMutable();
                attribute_.add(bs);
                break;
              } // case 50
              case 58: {
                Onnx.NodeProto m =
                    input.readMessage(
                        Onnx.NodeProto.parser(),
                        extensionRegistry);
                if (nodeBuilder_ == null) {
                  ensureNodeIsMutable();
                  node_.add(m);
                } else {
                  nodeBuilder_.addMessage(m);
                }
                break;
              } // case 58
              case 66: {
                docString_ = input.readBytes();
                bitField0_ |= 0x00000040;
                break;
              } // case 66
              case 74: {
                Onnx.OperatorSetIdProto m =
                    input.readMessage(
                        Onnx.OperatorSetIdProto.parser(),
                        extensionRegistry);
                if (opsetImportBuilder_ == null) {
                  ensureOpsetImportIsMutable();
                  opsetImport_.add(m);
                } else {
                  opsetImportBuilder_.addMessage(m);
                }
                break;
              } // case 74
              case 82: {
                domain_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 82
              case 90: {
                Onnx.AttributeProto m =
                    input.readMessage(
                        Onnx.AttributeProto.parser(),
                        extensionRegistry);
                if (attributeProtoBuilder_ == null) {
                  ensureAttributeProtoIsMutable();
                  attributeProto_.add(m);
                } else {
                  attributeProtoBuilder_.addMessage(m);
                }
                break;
              } // case 90
              case 98: {
                Onnx.ValueInfoProto m =
                    input.readMessage(
                        Onnx.ValueInfoProto.parser(),
                        extensionRegistry);
                if (valueInfoBuilder_ == null) {
                  ensureValueInfoIsMutable();
                  valueInfo_.add(m);
                } else {
                  valueInfoBuilder_.addMessage(m);
                }
                break;
              } // case 98
              case 106: {
                overload_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 106
              case 114: {
                Onnx.StringStringEntryProto m =
                    input.readMessage(
                        Onnx.StringStringEntryProto.parser(),
                        extensionRegistry);
                if (metadataPropsBuilder_ == null) {
                  ensureMetadataPropsIsMutable();
                  metadataProps_.add(m);
                } else {
                  metadataPropsBuilder_.addMessage(m);
                }
                break;
              } // case 114
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name of the function, similar to op_type in NodeProto.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureInputIsMutable() {
        if (!input_.isModifiable()) {
          input_ = new com.google.protobuf.LazyStringArrayList(input_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @return A list containing the input.
       */
      public com.google.protobuf.ProtocolStringList
          getInputList() {
        input_.makeImmutable();
        return input_;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @return The count of input.
       */
      public int getInputCount() {
        return input_.size();
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param index The index of the element to return.
       * @return The input at the given index.
       */
      public java.lang.String getInput(int index) {
        return input_.get(index);
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param index The index of the value to return.
       * @return The bytes of the input at the given index.
       */
      public com.google.protobuf.ByteString
          getInputBytes(int index) {
        return input_.getByteString(index);
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param index The index to set the value at.
       * @param value The input to set.
       * @return This builder for chaining.
       */
      public Builder setInput(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param value The input to add.
       * @return This builder for chaining.
       */
      public Builder addInput(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param values The input to add.
       * @return This builder for chaining.
       */
      public Builder addAllInput(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, input_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearInput() {
        input_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The inputs and outputs of the function.
       * </pre>
       *
       * <code>repeated string input = 4;</code>
       * @param value The bytes of the input to add.
       * @return This builder for chaining.
       */
      public Builder addInputBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureInputIsMutable();
        input_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureOutputIsMutable() {
        if (!output_.isModifiable()) {
          output_ = new com.google.protobuf.LazyStringArrayList(output_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @return A list containing the output.
       */
      public com.google.protobuf.ProtocolStringList
          getOutputList() {
        output_.makeImmutable();
        return output_;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @return The count of output.
       */
      public int getOutputCount() {
        return output_.size();
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param index The index of the element to return.
       * @return The output at the given index.
       */
      public java.lang.String getOutput(int index) {
        return output_.get(index);
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the output at the given index.
       */
      public com.google.protobuf.ByteString
          getOutputBytes(int index) {
        return output_.getByteString(index);
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param index The index to set the value at.
       * @param value The output to set.
       * @return This builder for chaining.
       */
      public Builder setOutput(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param value The output to add.
       * @return This builder for chaining.
       */
      public Builder addOutput(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param values The output to add.
       * @return This builder for chaining.
       */
      public Builder addAllOutput(
          java.lang.Iterable<java.lang.String> values) {
        ensureOutputIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, output_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearOutput() {
        output_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string output = 5;</code>
       * @param value The bytes of the output to add.
       * @return This builder for chaining.
       */
      public Builder addOutputBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureOutputIsMutable();
        output_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList attribute_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAttributeIsMutable() {
        if (!attribute_.isModifiable()) {
          attribute_ = new com.google.protobuf.LazyStringArrayList(attribute_);
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @return A list containing the attribute.
       */
      public com.google.protobuf.ProtocolStringList
          getAttributeList() {
        attribute_.makeImmutable();
        return attribute_;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @return The count of attribute.
       */
      public int getAttributeCount() {
        return attribute_.size();
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param index The index of the element to return.
       * @return The attribute at the given index.
       */
      public java.lang.String getAttribute(int index) {
        return attribute_.get(index);
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param index The index of the value to return.
       * @return The bytes of the attribute at the given index.
       */
      public com.google.protobuf.ByteString
          getAttributeBytes(int index) {
        return attribute_.getByteString(index);
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param index The index to set the value at.
       * @param value The attribute to set.
       * @return This builder for chaining.
       */
      public Builder setAttribute(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAttributeIsMutable();
        attribute_.set(index, value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param value The attribute to add.
       * @return This builder for chaining.
       */
      public Builder addAttribute(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAttributeIsMutable();
        attribute_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param values The attribute to add.
       * @return This builder for chaining.
       */
      public Builder addAllAttribute(
          java.lang.Iterable<java.lang.String> values) {
        ensureAttributeIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, attribute_);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearAttribute() {
        attribute_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The attribute parameters of the function.
       * It is for function parameters without default values.
       * </pre>
       *
       * <code>repeated string attribute = 6;</code>
       * @param value The bytes of the attribute to add.
       * @return This builder for chaining.
       */
      public Builder addAttributeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAttributeIsMutable();
        attribute_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.AttributeProto> attributeProto_ =
        java.util.Collections.emptyList();
      private void ensureAttributeProtoIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          attributeProto_ = new java.util.ArrayList<Onnx.AttributeProto>(attributeProto_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder> attributeProtoBuilder_;

      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public java.util.List<Onnx.AttributeProto> getAttributeProtoList() {
        if (attributeProtoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(attributeProto_);
        } else {
          return attributeProtoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public int getAttributeProtoCount() {
        if (attributeProtoBuilder_ == null) {
          return attributeProto_.size();
        } else {
          return attributeProtoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Onnx.AttributeProto getAttributeProto(int index) {
        if (attributeProtoBuilder_ == null) {
          return attributeProto_.get(index);
        } else {
          return attributeProtoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder setAttributeProto(
          int index, Onnx.AttributeProto value) {
        if (attributeProtoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeProtoIsMutable();
          attributeProto_.set(index, value);
          onChanged();
        } else {
          attributeProtoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder setAttributeProto(
          int index, Onnx.AttributeProto.Builder builderForValue) {
        if (attributeProtoBuilder_ == null) {
          ensureAttributeProtoIsMutable();
          attributeProto_.set(index, builderForValue.build());
          onChanged();
        } else {
          attributeProtoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder addAttributeProto(Onnx.AttributeProto value) {
        if (attributeProtoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeProtoIsMutable();
          attributeProto_.add(value);
          onChanged();
        } else {
          attributeProtoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder addAttributeProto(
          int index, Onnx.AttributeProto value) {
        if (attributeProtoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAttributeProtoIsMutable();
          attributeProto_.add(index, value);
          onChanged();
        } else {
          attributeProtoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder addAttributeProto(
          Onnx.AttributeProto.Builder builderForValue) {
        if (attributeProtoBuilder_ == null) {
          ensureAttributeProtoIsMutable();
          attributeProto_.add(builderForValue.build());
          onChanged();
        } else {
          attributeProtoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder addAttributeProto(
          int index, Onnx.AttributeProto.Builder builderForValue) {
        if (attributeProtoBuilder_ == null) {
          ensureAttributeProtoIsMutable();
          attributeProto_.add(index, builderForValue.build());
          onChanged();
        } else {
          attributeProtoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder addAllAttributeProto(
          java.lang.Iterable<? extends Onnx.AttributeProto> values) {
        if (attributeProtoBuilder_ == null) {
          ensureAttributeProtoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, attributeProto_);
          onChanged();
        } else {
          attributeProtoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder clearAttributeProto() {
        if (attributeProtoBuilder_ == null) {
          attributeProto_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          attributeProtoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Builder removeAttributeProto(int index) {
        if (attributeProtoBuilder_ == null) {
          ensureAttributeProtoIsMutable();
          attributeProto_.remove(index);
          onChanged();
        } else {
          attributeProtoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Onnx.AttributeProto.Builder getAttributeProtoBuilder(
          int index) {
        return internalGetAttributeProtoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Onnx.AttributeProtoOrBuilder getAttributeProtoOrBuilder(
          int index) {
        if (attributeProtoBuilder_ == null) {
          return attributeProto_.get(index);  } else {
          return attributeProtoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public java.util.List<? extends Onnx.AttributeProtoOrBuilder> 
           getAttributeProtoOrBuilderList() {
        if (attributeProtoBuilder_ != null) {
          return attributeProtoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(attributeProto_);
        }
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Onnx.AttributeProto.Builder addAttributeProtoBuilder() {
        return internalGetAttributeProtoFieldBuilder().addBuilder(
            Onnx.AttributeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public Onnx.AttributeProto.Builder addAttributeProtoBuilder(
          int index) {
        return internalGetAttributeProtoFieldBuilder().addBuilder(
            index, Onnx.AttributeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The attribute protos of the function.
       * It is for function attributes with default values.
       * A function attribute shall be represented either as
       * a string attribute or an AttributeProto, not both.
       * </pre>
       *
       * <code>repeated .AttributeProto attribute_proto = 11;</code>
       */
      public java.util.List<Onnx.AttributeProto.Builder> 
           getAttributeProtoBuilderList() {
        return internalGetAttributeProtoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder> 
          internalGetAttributeProtoFieldBuilder() {
        if (attributeProtoBuilder_ == null) {
          attributeProtoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.AttributeProto, Onnx.AttributeProto.Builder, Onnx.AttributeProtoOrBuilder>(
                  attributeProto_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          attributeProto_ = null;
        }
        return attributeProtoBuilder_;
      }

      private java.util.List<Onnx.NodeProto> node_ =
        java.util.Collections.emptyList();
      private void ensureNodeIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          node_ = new java.util.ArrayList<Onnx.NodeProto>(node_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder> nodeBuilder_;

      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public java.util.List<Onnx.NodeProto> getNodeList() {
        if (nodeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(node_);
        } else {
          return nodeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public int getNodeCount() {
        if (nodeBuilder_ == null) {
          return node_.size();
        } else {
          return nodeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Onnx.NodeProto getNode(int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);
        } else {
          return nodeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder setNode(
          int index, Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.set(index, value);
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder setNode(
          int index, Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.set(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder addNode(Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder addNode(
          int index, Onnx.NodeProto value) {
        if (nodeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNodeIsMutable();
          node_.add(index, value);
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder addNode(
          Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder addNode(
          int index, Onnx.NodeProto.Builder builderForValue) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.add(index, builderForValue.build());
          onChanged();
        } else {
          nodeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder addAllNode(
          java.lang.Iterable<? extends Onnx.NodeProto> values) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, node_);
          onChanged();
        } else {
          nodeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder clearNode() {
        if (nodeBuilder_ == null) {
          node_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          nodeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Builder removeNode(int index) {
        if (nodeBuilder_ == null) {
          ensureNodeIsMutable();
          node_.remove(index);
          onChanged();
        } else {
          nodeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Onnx.NodeProto.Builder getNodeBuilder(
          int index) {
        return internalGetNodeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Onnx.NodeProtoOrBuilder getNodeOrBuilder(
          int index) {
        if (nodeBuilder_ == null) {
          return node_.get(index);  } else {
          return nodeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public java.util.List<? extends Onnx.NodeProtoOrBuilder> 
           getNodeOrBuilderList() {
        if (nodeBuilder_ != null) {
          return nodeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(node_);
        }
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Onnx.NodeProto.Builder addNodeBuilder() {
        return internalGetNodeFieldBuilder().addBuilder(
            Onnx.NodeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public Onnx.NodeProto.Builder addNodeBuilder(
          int index) {
        return internalGetNodeFieldBuilder().addBuilder(
            index, Onnx.NodeProto.getDefaultInstance());
      }
      /**
       * <pre>
       * The nodes in the function.
       * </pre>
       *
       * <code>repeated .NodeProto node = 7;</code>
       */
      public java.util.List<Onnx.NodeProto.Builder> 
           getNodeBuilderList() {
        return internalGetNodeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder> 
          internalGetNodeFieldBuilder() {
        if (nodeBuilder_ == null) {
          nodeBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.NodeProto, Onnx.NodeProto.Builder, Onnx.NodeProtoOrBuilder>(
                  node_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          node_ = null;
        }
        return nodeBuilder_;
      }

      private java.lang.Object docString_ = "";
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @return Whether the docString field is set.
       */
      public boolean hasDocString() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @return The docString.
       */
      public java.lang.String getDocString() {
        java.lang.Object ref = docString_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            docString_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @return The bytes for docString.
       */
      public com.google.protobuf.ByteString
          getDocStringBytes() {
        java.lang.Object ref = docString_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          docString_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @param value The docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocString(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDocString() {
        docString_ = getDefaultInstance().getDocString();
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A human-readable documentation for this function. Markdown is allowed.
       * </pre>
       *
       * <code>optional string doc_string = 8;</code>
       * @param value The bytes for docString to set.
       * @return This builder for chaining.
       */
      public Builder setDocStringBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        docString_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.OperatorSetIdProto> opsetImport_ =
        java.util.Collections.emptyList();
      private void ensureOpsetImportIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          opsetImport_ = new java.util.ArrayList<Onnx.OperatorSetIdProto>(opsetImport_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder> opsetImportBuilder_;

      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public java.util.List<Onnx.OperatorSetIdProto> getOpsetImportList() {
        if (opsetImportBuilder_ == null) {
          return java.util.Collections.unmodifiableList(opsetImport_);
        } else {
          return opsetImportBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public int getOpsetImportCount() {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.size();
        } else {
          return opsetImportBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Onnx.OperatorSetIdProto getOpsetImport(int index) {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.get(index);
        } else {
          return opsetImportBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder setOpsetImport(
          int index, Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.set(index, value);
          onChanged();
        } else {
          opsetImportBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder setOpsetImport(
          int index, Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.set(index, builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder addOpsetImport(Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.add(value);
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder addOpsetImport(
          int index, Onnx.OperatorSetIdProto value) {
        if (opsetImportBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOpsetImportIsMutable();
          opsetImport_.add(index, value);
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder addOpsetImport(
          Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.add(builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder addOpsetImport(
          int index, Onnx.OperatorSetIdProto.Builder builderForValue) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.add(index, builderForValue.build());
          onChanged();
        } else {
          opsetImportBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder addAllOpsetImport(
          java.lang.Iterable<? extends Onnx.OperatorSetIdProto> values) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, opsetImport_);
          onChanged();
        } else {
          opsetImportBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder clearOpsetImport() {
        if (opsetImportBuilder_ == null) {
          opsetImport_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          opsetImportBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Builder removeOpsetImport(int index) {
        if (opsetImportBuilder_ == null) {
          ensureOpsetImportIsMutable();
          opsetImport_.remove(index);
          onChanged();
        } else {
          opsetImportBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Onnx.OperatorSetIdProto.Builder getOpsetImportBuilder(
          int index) {
        return internalGetOpsetImportFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Onnx.OperatorSetIdProtoOrBuilder getOpsetImportOrBuilder(
          int index) {
        if (opsetImportBuilder_ == null) {
          return opsetImport_.get(index);  } else {
          return opsetImportBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public java.util.List<? extends Onnx.OperatorSetIdProtoOrBuilder> 
           getOpsetImportOrBuilderList() {
        if (opsetImportBuilder_ != null) {
          return opsetImportBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(opsetImport_);
        }
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Onnx.OperatorSetIdProto.Builder addOpsetImportBuilder() {
        return internalGetOpsetImportFieldBuilder().addBuilder(
            Onnx.OperatorSetIdProto.getDefaultInstance());
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public Onnx.OperatorSetIdProto.Builder addOpsetImportBuilder(
          int index) {
        return internalGetOpsetImportFieldBuilder().addBuilder(
            index, Onnx.OperatorSetIdProto.getDefaultInstance());
      }
      /**
       * <code>repeated .OperatorSetIdProto opset_import = 9;</code>
       */
      public java.util.List<Onnx.OperatorSetIdProto.Builder> 
           getOpsetImportBuilderList() {
        return internalGetOpsetImportFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder> 
          internalGetOpsetImportFieldBuilder() {
        if (opsetImportBuilder_ == null) {
          opsetImportBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.OperatorSetIdProto, Onnx.OperatorSetIdProto.Builder, Onnx.OperatorSetIdProtoOrBuilder>(
                  opsetImport_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          opsetImport_ = null;
        }
        return opsetImportBuilder_;
      }

      private java.lang.Object domain_ = "";
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @return Whether the domain field is set.
       */
      public boolean hasDomain() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @return The domain.
       */
      public java.lang.String getDomain() {
        java.lang.Object ref = domain_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            domain_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @return The bytes for domain.
       */
      public com.google.protobuf.ByteString
          getDomainBytes() {
        java.lang.Object ref = domain_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          domain_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @param value The domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomain(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDomain() {
        domain_ = getDefaultInstance().getDomain();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The domain which this function belongs to.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string domain = 10;</code>
       * @param value The bytes for domain to set.
       * @return This builder for chaining.
       */
      public Builder setDomainBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        domain_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }

      private java.lang.Object overload_ = "";
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @return Whether the overload field is set.
       */
      public boolean hasOverload() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @return The overload.
       */
      public java.lang.String getOverload() {
        java.lang.Object ref = overload_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            overload_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @return The bytes for overload.
       */
      public com.google.protobuf.ByteString
          getOverloadBytes() {
        java.lang.Object ref = overload_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          overload_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @param value The overload to set.
       * @return This builder for chaining.
       */
      public Builder setOverload(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        overload_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearOverload() {
        overload_ = getDefaultInstance().getOverload();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The overload identifier of the function.
       * This is part of the unique-id (domain, name, overload) of FunctionProtos in a model.
       * </pre>
       *
       * <code>optional string overload = 13;</code>
       * @param value The bytes for overload to set.
       * @return This builder for chaining.
       */
      public Builder setOverloadBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        overload_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private java.util.List<Onnx.ValueInfoProto> valueInfo_ =
        java.util.Collections.emptyList();
      private void ensureValueInfoIsMutable() {
        if (!((bitField0_ & 0x00000400) != 0)) {
          valueInfo_ = new java.util.ArrayList<Onnx.ValueInfoProto>(valueInfo_);
          bitField0_ |= 0x00000400;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> valueInfoBuilder_;

      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public java.util.List<Onnx.ValueInfoProto> getValueInfoList() {
        if (valueInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(valueInfo_);
        } else {
          return valueInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public int getValueInfoCount() {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.size();
        } else {
          return valueInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Onnx.ValueInfoProto getValueInfo(int index) {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.get(index);
        } else {
          return valueInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder setValueInfo(
          int index, Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.set(index, value);
          onChanged();
        } else {
          valueInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder setValueInfo(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder addValueInfo(Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.add(value);
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder addValueInfo(
          int index, Onnx.ValueInfoProto value) {
        if (valueInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureValueInfoIsMutable();
          valueInfo_.add(index, value);
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder addValueInfo(
          Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.add(builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder addValueInfo(
          int index, Onnx.ValueInfoProto.Builder builderForValue) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          valueInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder addAllValueInfo(
          java.lang.Iterable<? extends Onnx.ValueInfoProto> values) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, valueInfo_);
          onChanged();
        } else {
          valueInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder clearValueInfo() {
        if (valueInfoBuilder_ == null) {
          valueInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000400);
          onChanged();
        } else {
          valueInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Builder removeValueInfo(int index) {
        if (valueInfoBuilder_ == null) {
          ensureValueInfoIsMutable();
          valueInfo_.remove(index);
          onChanged();
        } else {
          valueInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder getValueInfoBuilder(
          int index) {
        return internalGetValueInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Onnx.ValueInfoProtoOrBuilder getValueInfoOrBuilder(
          int index) {
        if (valueInfoBuilder_ == null) {
          return valueInfo_.get(index);  } else {
          return valueInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public java.util.List<? extends Onnx.ValueInfoProtoOrBuilder> 
           getValueInfoOrBuilderList() {
        if (valueInfoBuilder_ != null) {
          return valueInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(valueInfo_);
        }
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder addValueInfoBuilder() {
        return internalGetValueInfoFieldBuilder().addBuilder(
            Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public Onnx.ValueInfoProto.Builder addValueInfoBuilder(
          int index) {
        return internalGetValueInfoFieldBuilder().addBuilder(
            index, Onnx.ValueInfoProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Information for the values in the function. The ValueInfoProto.name's
       * must be distinct and refer to names in the function (including inputs,
       * outputs, and intermediate values). It is optional for a value to appear
       * in value_info list.
       * </pre>
       *
       * <code>repeated .ValueInfoProto value_info = 12;</code>
       */
      public java.util.List<Onnx.ValueInfoProto.Builder> 
           getValueInfoBuilderList() {
        return internalGetValueInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder> 
          internalGetValueInfoFieldBuilder() {
        if (valueInfoBuilder_ == null) {
          valueInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.ValueInfoProto, Onnx.ValueInfoProto.Builder, Onnx.ValueInfoProtoOrBuilder>(
                  valueInfo_,
                  ((bitField0_ & 0x00000400) != 0),
                  getParentForChildren(),
                  isClean());
          valueInfo_ = null;
        }
        return valueInfoBuilder_;
      }

      private java.util.List<Onnx.StringStringEntryProto> metadataProps_ =
        java.util.Collections.emptyList();
      private void ensureMetadataPropsIsMutable() {
        if (!((bitField0_ & 0x00000800) != 0)) {
          metadataProps_ = new java.util.ArrayList<Onnx.StringStringEntryProto>(metadataProps_);
          bitField0_ |= 0x00000800;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> metadataPropsBuilder_;

      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto> getMetadataPropsList() {
        if (metadataPropsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(metadataProps_);
        } else {
          return metadataPropsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public int getMetadataPropsCount() {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.size();
        } else {
          return metadataPropsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto getMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);
        } else {
          return metadataPropsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder setMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.set(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto value) {
        if (metadataPropsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, value);
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addMetadataProps(
          int index, Onnx.StringStringEntryProto.Builder builderForValue) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.add(index, builderForValue.build());
          onChanged();
        } else {
          metadataPropsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder addAllMetadataProps(
          java.lang.Iterable<? extends Onnx.StringStringEntryProto> values) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, metadataProps_);
          onChanged();
        } else {
          metadataPropsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder clearMetadataProps() {
        if (metadataPropsBuilder_ == null) {
          metadataProps_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000800);
          onChanged();
        } else {
          metadataPropsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Builder removeMetadataProps(int index) {
        if (metadataPropsBuilder_ == null) {
          ensureMetadataPropsIsMutable();
          metadataProps_.remove(index);
          onChanged();
        } else {
          metadataPropsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder getMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProtoOrBuilder getMetadataPropsOrBuilder(
          int index) {
        if (metadataPropsBuilder_ == null) {
          return metadataProps_.get(index);  } else {
          return metadataPropsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<? extends Onnx.StringStringEntryProtoOrBuilder> 
           getMetadataPropsOrBuilderList() {
        if (metadataPropsBuilder_ != null) {
          return metadataPropsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(metadataProps_);
        }
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder() {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public Onnx.StringStringEntryProto.Builder addMetadataPropsBuilder(
          int index) {
        return internalGetMetadataPropsFieldBuilder().addBuilder(
            index, Onnx.StringStringEntryProto.getDefaultInstance());
      }
      /**
       * <pre>
       * Named metadata values; keys should be distinct.
       * </pre>
       *
       * <code>repeated .StringStringEntryProto metadata_props = 14;</code>
       */
      public java.util.List<Onnx.StringStringEntryProto.Builder> 
           getMetadataPropsBuilderList() {
        return internalGetMetadataPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder> 
          internalGetMetadataPropsFieldBuilder() {
        if (metadataPropsBuilder_ == null) {
          metadataPropsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Onnx.StringStringEntryProto, Onnx.StringStringEntryProto.Builder, Onnx.StringStringEntryProtoOrBuilder>(
                  metadataProps_,
                  ((bitField0_ & 0x00000800) != 0),
                  getParentForChildren(),
                  isClean());
          metadataProps_ = null;
        }
        return metadataPropsBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:FunctionProto)
    }

    // @@protoc_insertion_point(class_scope:FunctionProto)
    private static final Onnx.FunctionProto DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Onnx.FunctionProto();
    }

    public static Onnx.FunctionProto getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FunctionProto>
        PARSER = new com.google.protobuf.AbstractParser<FunctionProto>() {
      @java.lang.Override
      public FunctionProto parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FunctionProto> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FunctionProto> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public Onnx.FunctionProto getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_AttributeProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_AttributeProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_ValueInfoProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_ValueInfoProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_NodeProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_NodeProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_IntIntListEntryProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_IntIntListEntryProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_NodeDeviceConfigurationProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_ShardingSpecProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_ShardingSpecProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_ShardedDimProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_ShardedDimProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_SimpleShardedDimProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TrainingInfoProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TrainingInfoProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_ModelProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_ModelProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_DeviceConfigurationProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_StringStringEntryProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_StringStringEntryProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TensorAnnotation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TensorAnnotation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_GraphProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_GraphProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TensorProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TensorProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TensorProto_Segment_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TensorProto_Segment_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_SparseTensorProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_SparseTensorProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TensorShapeProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TensorShapeProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TensorShapeProto_Dimension_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_Tensor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_Tensor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_Sequence_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_Sequence_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_Map_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_Map_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_Optional_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_Optional_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_TypeProto_SparseTensor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_OperatorSetIdProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_OperatorSetIdProto_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_onnx_FunctionProto_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_onnx_FunctionProto_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\nproto\022\004onnx\"\333\005\n\016AttributeProto\022\014\n" +
      "\004name\030\001 \001(\t\022\025\n\rref_attr_name\030\025 \001(\t\022\022\n\ndo" +
      "c_string\030\r \001(\t\0220\n\004type\030\024 \001(\0162\".Attr" +
      "ibuteProto.AttributeType\022\t\n\001f\030\002 \001(\002\022\t\n\001i" +
      "\030\003 \001(\003\022\t\n\001s\030\004 \001(\014\022\034\n\001t\030\005 \001(\0132\021.Tens" +
      "orProto\022\033\n\001g\030\006 \001(\0132\020.GraphProto\022.\n\r" +
      "sparse_tensor\030\026 \001(\0132\027.SparseTensorP" +
      "roto\022\033\n\002tp\030\016 \001(\0132\017.TypeProto\022\016\n\006flo" +
      "ats\030\007 \003(\002\022\014\n\004ints\030\010 \003(\003\022\017\n\007strings\030\t \003(\014" +
      "\022\"\n\007tensors\030\n \003(\0132\021.TensorProto\022 \n\006" +
      "graphs\030\013 \003(\0132\020.GraphProto\022/\n\016sparse" +
      "_tensors\030\027 \003(\0132\027.SparseTensorProto\022" +
      "$\n\013type_protos\030\017 \003(\0132\017.TypeProto\"\331\001" +
      "\n\rAttributeType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020" +
      "\001\022\007\n\003INT\020\002\022\n\n\006STRING\020\003\022\n\n\006TENSOR\020\004\022\t\n\005GR" +
      "APH\020\005\022\021\n\rSPARSE_TENSOR\020\013\022\016\n\nTYPE_PROTO\020\r" +
      "\022\n\n\006FLOATS\020\006\022\010\n\004INTS\020\007\022\013\n\007STRINGS\020\010\022\013\n\007T" +
      "ENSORS\020\t\022\n\n\006GRAPHS\020\n\022\022\n\016SPARSE_TENSORS\020\014" +
      "\022\017\n\013TYPE_PROTOS\020\016J\004\010\014\020\rJ\004\010\020\020\024R\001v\"\207\001\n\016Val" +
      "ueInfoProto\022\014\n\004name\030\001 \001(\t\022\035\n\004type\030\002 \001(\0132" +
      "\017.TypeProto\022\022\n\ndoc_string\030\003 \001(\t\0224\n\016" +
      "metadata_props\030\004 \003(\0132\034.StringString" +
      "EntryProto\"\241\002\n\tNodeProto\022\r\n\005input\030\001 \003(\t\022" +
      "\016\n\006output\030\002 \003(\t\022\014\n\004name\030\003 \001(\t\022\017\n\007op_type" +
      "\030\004 \001(\t\022\016\n\006domain\030\007 \001(\t\022\020\n\010overload\030\010 \001(\t" +
      "\022\'\n\tattribute\030\005 \003(\0132\024.AttributeProt" +
      "o\022\022\n\ndoc_string\030\006 \001(\t\0224\n\016metadata_props\030" +
      "\t \003(\0132\034.StringStringEntryProto\022A\n\025d" +
      "evice_configurations\030\n \003(\0132\".NodeDe" +
      "viceConfigurationProto\"2\n\024IntIntListEntr" +
      "yProto\022\013\n\003key\030\001 \001(\003\022\r\n\005value\030\002 \003(\003\"\200\001\n\034N" +
      "odeDeviceConfigurationProto\022\030\n\020configura" +
      "tion_id\030\001 \001(\t\022.\n\rsharding_spec\030\002 \003(\0132\027.o" +
      "nnx.ShardingSpecProto\022\026\n\016pipeline_stage\030" +
      "\003 \001(\005\"\243\001\n\021ShardingSpecProto\022\023\n\013tensor_na" +
      "me\030\001 \001(\t\022\016\n\006device\030\002 \003(\003\022=\n\031index_to_dev" +
      "ice_group_map\030\003 \003(\0132\032.IntIntListEnt" +
      "ryProto\022*\n\013sharded_dim\030\004 \003(\0132\025.Shar" +
      "dedDimProto\"U\n\017ShardedDimProto\022\014\n\004axis\030\001" +
      " \001(\003\0224\n\017simple_sharding\030\002 \003(\0132\033.Sim" +
      "pleShardedDimProto\"\\\n\025SimpleShardedDimPr" +
      "oto\022\023\n\tdim_value\030\001 \001(\003H\000\022\023\n\tdim_param\030\002 " +
      "\001(\tH\000\022\022\n\nnum_shards\030\003 \001(\003B\005\n\003dim\"\326\001\n\021Tra" +
      "iningInfoProto\022(\n\016initialization\030\001 \001(\0132\020" +
      ".GraphProto\022#\n\talgorithm\030\002 \001(\0132\020.on" +
      "nx.GraphProto\022<\n\026initialization_binding\030" +
      "\003 \003(\0132\034.StringStringEntryProto\0224\n\016u" +
      "pdate_binding\030\004 \003(\0132\034.StringStringE" +
      "ntryProto\"\242\003\n\nModelProto\022\022\n\nir_version\030\001" +
      " \001(\003\022.\n\014opset_import\030\010 \003(\0132\030.Operat" +
      "orSetIdProto\022\025\n\rproducer_name\030\002 \001(\t\022\030\n\020p" +
      "roducer_version\030\003 \001(\t\022\016\n\006domain\030\004 \001(\t\022\025\n" +
      "\rmodel_version\030\005 \001(\003\022\022\n\ndoc_string\030\006 \001(\t" +
      "\022\037\n\005graph\030\007 \001(\0132\020.GraphProto\0224\n\016met" +
      "adata_props\030\016 \003(\0132\034.StringStringEnt" +
      "ryProto\022.\n\rtraining_info\030\024 \003(\0132\027.Tr" +
      "ainingInfoProto\022&\n\tfunctions\030\031 \003(\0132\023.onn" +
      "x.FunctionProto\0225\n\rconfiguration\030\032 \003(\0132\036" +
      ".DeviceConfigurationProto\"M\n\030Device" +
      "ConfigurationProto\022\014\n\004name\030\001 \001(\t\022\023\n\013num_" +
      "devices\030\002 \001(\005\022\016\n\006device\030\003 \003(\t\"4\n\026StringS" +
      "tringEntryProto\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
      "\001(\t\"k\n\020TensorAnnotation\022\023\n\013tensor_name\030\001" +
      " \001(\t\022B\n\034quant_parameter_tensor_names\030\002 \003" +
      "(\0132\034.StringStringEntryProto\"\324\003\n\nGra" +
      "phProto\022\035\n\004node\030\001 \003(\0132\017.NodeProto\022\014" +
      "\n\004name\030\002 \001(\t\022&\n\013initializer\030\005 \003(\0132\021.onnx" +
      ".TensorProto\0223\n\022sparse_initializer\030\017 \003(\013" +
      "2\027.SparseTensorProto\022\022\n\ndoc_string\030" +
      "\n \001(\t\022#\n\005input\030\013 \003(\0132\024.ValueInfoPro" +
      "to\022$\n\006output\030\014 \003(\0132\024.ValueInfoProto" +
      "\022(\n\nvalue_info\030\r \003(\0132\024.ValueInfoPro" +
      "to\0227\n\027quantization_annotation\030\016 \003(\0132\026.on" +
      "nx.TensorAnnotation\0224\n\016metadata_props\030\020 " +
      "\003(\0132\034.StringStringEntryProtoJ\004\010\003\020\004J" +
      "\004\010\004\020\005J\004\010\006\020\nR\nir_versionR\020producer_versio" +
      "nR\014producer_tagR\006domain\"\335\006\n\013TensorProto\022" +
      "\014\n\004dims\030\001 \003(\003\022\021\n\tdata_type\030\002 \001(\005\022*\n\007segm" +
      "ent\030\003 \001(\0132\031.TensorProto.Segment\022\026\n\n" +
      "float_data\030\004 \003(\002B\002\020\001\022\026\n\nint32_data\030\005 \003(\005" +
      "B\002\020\001\022\023\n\013string_data\030\006 \003(\014\022\026\n\nint64_data\030" +
      "\007 \003(\003B\002\020\001\022\014\n\004name\030\010 \001(\t\022\022\n\ndoc_string\030\014 " +
      "\001(\t\022\020\n\010raw_data\030\t \001(\014\0223\n\rexternal_data\030\r" +
      " \003(\0132\034.StringStringEntryProto\0225\n\rda" +
      "ta_location\030\016 \001(\0162\036.TensorProto.Dat" +
      "aLocation\022\027\n\013double_data\030\n \003(\001B\002\020\001\022\027\n\013ui" +
      "nt64_data\030\013 \003(\004B\002\020\001\0224\n\016metadata_props\030\020 " +
      "\003(\0132\034.StringStringEntryProto\032%\n\007Seg" +
      "ment\022\r\n\005begin\030\001 \001(\003\022\013\n\003end\030\002 \001(\003\"\311\002\n\010Dat" +
      "aType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020\001\022\t\n\005UINT8" +
      "\020\002\022\010\n\004INT8\020\003\022\n\n\006UINT16\020\004\022\t\n\005INT16\020\005\022\t\n\005I" +
      "NT32\020\006\022\t\n\005INT64\020\007\022\n\n\006STRING\020\010\022\010\n\004BOOL\020\t\022" +
      "\013\n\007FLOAT16\020\n\022\n\n\006DOUBLE\020\013\022\n\n\006UINT32\020\014\022\n\n\006" +
      "UINT64\020\r\022\r\n\tCOMPLEX64\020\016\022\016\n\nCOMPLEX128\020\017\022" +
      "\014\n\010BFLOAT16\020\020\022\020\n\014FLOAT8E4M3FN\020\021\022\022\n\016FLOAT" +
      "8E4M3FNUZ\020\022\022\016\n\nFLOAT8E5M2\020\023\022\022\n\016FLOAT8E5M" +
      "2FNUZ\020\024\022\t\n\005UINT4\020\025\022\010\n\004INT4\020\026\022\016\n\nFLOAT4E2" +
      "M1\020\027\")\n\014DataLocation\022\013\n\007DEFAULT\020\000\022\014\n\010EXT" +
      "ERNAL\020\001\"h\n\021SparseTensorProto\022!\n\006values\030\001" +
      " \001(\0132\021.TensorProto\022\"\n\007indices\030\002 \001(\013" +
      "2\021.TensorProto\022\014\n\004dims\030\003 \003(\003\"\225\001\n\020Te" +
      "nsorShapeProto\022-\n\003dim\030\001 \003(\0132 .Tenso" +
      "rShapeProto.Dimension\032R\n\tDimension\022\023\n\tdi" +
      "m_value\030\001 \001(\003H\000\022\023\n\tdim_param\030\002 \001(\tH\000\022\022\n\n" +
      "denotation\030\003 \001(\tB\007\n\005value\"\316\004\n\tTypeProto\022" +
      "-\n\013tensor_type\030\001 \001(\0132\026.TypeProto.Te" +
      "nsorH\000\0221\n\rsequence_type\030\004 \001(\0132\030.Typ" +
      "eProto.SequenceH\000\022\'\n\010map_type\030\005 \001(\0132\023.on" +
      "nx.TypeProto.MapH\000\0221\n\roptional_type\030\t \001(" +
      "\0132\030.TypeProto.OptionalH\000\022:\n\022sparse_" +
      "tensor_type\030\010 \001(\0132\034.TypeProto.Spars" +
      "eTensorH\000\022\022\n\ndenotation\030\006 \001(\t\032B\n\006Tensor\022" +
      "\021\n\telem_type\030\001 \001(\005\022%\n\005shape\030\002 \001(\0132\026.onnx" +
      ".TensorShapeProto\032.\n\010Sequence\022\"\n\telem_ty" +
      "pe\030\001 \001(\0132\017.TypeProto\032<\n\003Map\022\020\n\010key_" +
      "type\030\001 \001(\005\022#\n\nvalue_type\030\002 \001(\0132\017.Ty" +
      "peProto\032.\n\010Optional\022\"\n\telem_type\030\001 \001(\0132\017" +
      ".TypeProto\032H\n\014SparseTensor\022\021\n\telem_" +
      "type\030\001 \001(\005\022%\n\005shape\030\002 \001(\0132\026.TensorS" +
      "hapeProtoB\007\n\005value\"5\n\022OperatorSetIdProto" +
      "\022\016\n\006domain\030\001 \001(\t\022\017\n\007version\030\002 \001(\003\"\206\003\n\rFu" +
      "nctionProto\022\014\n\004name\030\001 \001(\t\022\r\n\005input\030\004 \003(\t" +
      "\022\016\n\006output\030\005 \003(\t\022\021\n\tattribute\030\006 \003(\t\022-\n\017a" +
      "ttribute_proto\030\013 \003(\0132\024.AttributePro" +
      "to\022\035\n\004node\030\007 \003(\0132\017.NodeProto\022\022\n\ndoc" +
      "_string\030\010 \001(\t\022.\n\014opset_import\030\t \003(\0132\030.on" +
      "nx.OperatorSetIdProto\022\016\n\006domain\030\n \001(\t\022\020\n" +
      "\010overload\030\r \001(\t\022(\n\nvalue_info\030\014 \003(\0132\024.on" +
      "nx.ValueInfoProto\0224\n\016metadata_props\030\016 \003(" +
      "\0132\034.StringStringEntryProtoJ\004\010\002\020\003J\004\010" +
      "\003\020\004R\rsince_versionR\006status*\261\002\n\007Version\022\022" +
      "\n\016_START_VERSION\020\000\022\031\n\025IR_VERSION_2017_10" +
      "_10\020\001\022\031\n\025IR_VERSION_2017_10_30\020\002\022\030\n\024IR_V" +
      "ERSION_2017_11_3\020\003\022\030\n\024IR_VERSION_2019_1_" +
      "22\020\004\022\030\n\024IR_VERSION_2019_3_18\020\005\022\030\n\024IR_VER" +
      "SION_2019_9_19\020\006\022\027\n\023IR_VERSION_2020_5_8\020" +
      "\007\022\030\n\024IR_VERSION_2021_7_30\020\010\022\027\n\023IR_VERSIO" +
      "N_2023_5_5\020\t\022\030\n\024IR_VERSION_2024_3_25\020\n\022\016" +
      "\n\nIR_VERSION\020\013*.\n\016OperatorStatus\022\020\n\014EXPE" +
      "RIMENTAL\020\000\022\n\n\006STABLE\020\001B\002H\003"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_onnx_AttributeProto_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_onnx_AttributeProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_AttributeProto_descriptor,
        new java.lang.String[] { "Name", "RefAttrName", "DocString", "Type", "F", "I", "S", "T", "G", "SparseTensor", "Tp", "Floats", "Ints", "Strings", "Tensors", "Graphs", "SparseTensors", "TypeProtos", });
    internal_static_onnx_ValueInfoProto_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_onnx_ValueInfoProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_ValueInfoProto_descriptor,
        new java.lang.String[] { "Name", "Type", "DocString", "MetadataProps", });
    internal_static_onnx_NodeProto_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_onnx_NodeProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_NodeProto_descriptor,
        new java.lang.String[] { "Input", "Output", "Name", "OpType", "Domain", "Overload", "Attribute", "DocString", "MetadataProps", "DeviceConfigurations", });
    internal_static_onnx_IntIntListEntryProto_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_onnx_IntIntListEntryProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_IntIntListEntryProto_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_onnx_NodeDeviceConfigurationProto_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_onnx_NodeDeviceConfigurationProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_NodeDeviceConfigurationProto_descriptor,
        new java.lang.String[] { "ConfigurationId", "ShardingSpec", "PipelineStage", });
    internal_static_onnx_ShardingSpecProto_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_onnx_ShardingSpecProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_ShardingSpecProto_descriptor,
        new java.lang.String[] { "TensorName", "Device", "IndexToDeviceGroupMap", "ShardedDim", });
    internal_static_onnx_ShardedDimProto_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_onnx_ShardedDimProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_ShardedDimProto_descriptor,
        new java.lang.String[] { "Axis", "SimpleSharding", });
    internal_static_onnx_SimpleShardedDimProto_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_onnx_SimpleShardedDimProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_SimpleShardedDimProto_descriptor,
        new java.lang.String[] { "DimValue", "DimParam", "NumShards", "Dim", });
    internal_static_onnx_TrainingInfoProto_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_onnx_TrainingInfoProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TrainingInfoProto_descriptor,
        new java.lang.String[] { "Initialization", "Algorithm", "InitializationBinding", "UpdateBinding", });
    internal_static_onnx_ModelProto_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_onnx_ModelProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_ModelProto_descriptor,
        new java.lang.String[] { "IrVersion", "OpsetImport", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "MetadataProps", "TrainingInfo", "Functions", "Configuration", });
    internal_static_onnx_DeviceConfigurationProto_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_onnx_DeviceConfigurationProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_DeviceConfigurationProto_descriptor,
        new java.lang.String[] { "Name", "NumDevices", "Device", });
    internal_static_onnx_StringStringEntryProto_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_onnx_StringStringEntryProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_StringStringEntryProto_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_onnx_TensorAnnotation_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_onnx_TensorAnnotation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TensorAnnotation_descriptor,
        new java.lang.String[] { "TensorName", "QuantParameterTensorNames", });
    internal_static_onnx_GraphProto_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_onnx_GraphProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_GraphProto_descriptor,
        new java.lang.String[] { "Node", "Name", "Initializer", "SparseInitializer", "DocString", "Input", "Output", "ValueInfo", "QuantizationAnnotation", "MetadataProps", });
    internal_static_onnx_TensorProto_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_onnx_TensorProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TensorProto_descriptor,
        new java.lang.String[] { "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "DocString", "RawData", "ExternalData", "DataLocation", "DoubleData", "Uint64Data", "MetadataProps", });
    internal_static_onnx_TensorProto_Segment_descriptor =
      internal_static_onnx_TensorProto_descriptor.getNestedTypes().get(0);
    internal_static_onnx_TensorProto_Segment_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TensorProto_Segment_descriptor,
        new java.lang.String[] { "Begin", "End", });
    internal_static_onnx_SparseTensorProto_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_onnx_SparseTensorProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_SparseTensorProto_descriptor,
        new java.lang.String[] { "Values", "Indices", "Dims", });
    internal_static_onnx_TensorShapeProto_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_onnx_TensorShapeProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TensorShapeProto_descriptor,
        new java.lang.String[] { "Dim", });
    internal_static_onnx_TensorShapeProto_Dimension_descriptor =
      internal_static_onnx_TensorShapeProto_descriptor.getNestedTypes().get(0);
    internal_static_onnx_TensorShapeProto_Dimension_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TensorShapeProto_Dimension_descriptor,
        new java.lang.String[] { "DimValue", "DimParam", "Denotation", "Value", });
    internal_static_onnx_TypeProto_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_onnx_TypeProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_descriptor,
        new java.lang.String[] { "TensorType", "SequenceType", "MapType", "OptionalType", "SparseTensorType", "Denotation", "Value", });
    internal_static_onnx_TypeProto_Tensor_descriptor =
      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(0);
    internal_static_onnx_TypeProto_Tensor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_Tensor_descriptor,
        new java.lang.String[] { "ElemType", "Shape", });
    internal_static_onnx_TypeProto_Sequence_descriptor =
      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(1);
    internal_static_onnx_TypeProto_Sequence_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_Sequence_descriptor,
        new java.lang.String[] { "ElemType", });
    internal_static_onnx_TypeProto_Map_descriptor =
      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(2);
    internal_static_onnx_TypeProto_Map_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_Map_descriptor,
        new java.lang.String[] { "KeyType", "ValueType", });
    internal_static_onnx_TypeProto_Optional_descriptor =
      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(3);
    internal_static_onnx_TypeProto_Optional_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_Optional_descriptor,
        new java.lang.String[] { "ElemType", });
    internal_static_onnx_TypeProto_SparseTensor_descriptor =
      internal_static_onnx_TypeProto_descriptor.getNestedTypes().get(4);
    internal_static_onnx_TypeProto_SparseTensor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_TypeProto_SparseTensor_descriptor,
        new java.lang.String[] { "ElemType", "Shape", });
    internal_static_onnx_OperatorSetIdProto_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_onnx_OperatorSetIdProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_OperatorSetIdProto_descriptor,
        new java.lang.String[] { "Domain", "Version", });
    internal_static_onnx_FunctionProto_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_onnx_FunctionProto_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_onnx_FunctionProto_descriptor,
        new java.lang.String[] { "Name", "Input", "Output", "Attribute", "AttributeProto", "Node", "DocString", "OpsetImport", "Domain", "Overload", "ValueInfo", "MetadataProps", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
